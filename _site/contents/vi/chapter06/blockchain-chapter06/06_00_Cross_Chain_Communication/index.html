<!DOCTYPE html>
<html lang="vi">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <style>
    .MathJax {
      padding: 2em 0.3em;
      overflow-x: auto;
      overflow-y: hidden;
    }
  </style>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

  <title>
    
      Lecture 06.00: Cross-Chain Communication - Kết nối các Blockchain &middot; Blockchain
    
  </title>

  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/poole.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/syntax.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/lanyon.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/github-markdown.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/multilang.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/search.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/content-boxes.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap">
  
  <!-- Lunr.js for search functionality -->
  <script src="https://unpkg.com/lunr/lunr.js"></script>

  <link rel="apple-touch-icon-precomposed" sizes="122x144" href="http://0.0.0.0:4000/deep-learning-self-learning/public/logo.png">
  <link rel="shortcut icon" href="http://0.0.0.0:4000/deep-learning-self-learning/public/convex-logo-144x144.png">

  <link rel="alternate" type="application/rss+xml" title="RSS" href="http://0.0.0.0:4000/deep-learning-self-learning/atom.xml">

  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', '', 'auto');
    ga('send', 'pageview');
  </script>
  
</head>


  <body class="sidebar-overlay">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>Blockchain</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/">Trang chủ</a>

    

    
    
    
    <!-- Hiển thị các chương có sẵn cho ngôn ngữ hiện tại -->
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter00/">
              00. Chapter 00: Nền Tảng Blockchain
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter01/">
              01. Chapter 01: Bitcoin - Architecture và Proof-of-Work
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter02/">
              02. Chapter 02: Advanced Consensus Mechanisms
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter03/">
              03. Chapter 03: Ethereum và Smart Contracts
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter04/">
              04. Chapter 04: Blockchain Scalability và Layer-2 Solutions
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter05/">
              05. Chapter 05: Privacy và Security trong Blockchain
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter06/">
              06. Chapter 06: Blockchain Interoperability
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter07/">
              07. Chapter 07: Advanced Blockchain Topics
              
            </a>
          
        
      
    
    
    <!-- Nếu không có nội dung cho ngôn ngữ hiện tại, hiển thị thông báo -->
    
    
    <span class="sidebar-nav-item">Currently v0.0.1</span>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2025. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap github-md-body">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/deep-learning-self-learning/" title="Trang chủ">Blockchain</a>
            <small></small>
          </h3>
          <!-- Header Actions: Language Toggle and GitHub Link -->
          <div class="header-actions">
            <div class="language-toggle">
              <a href="/deep-learning-self-learning/contents/en/chapter00/" class="language-switch" title="Chuyển sang tiếng Anh">Chuyển sang tiếng Anh</a>
            </div>
            <a class="github-logo__wrapper" target="_blank" href="https://github.com/nglelinh/deep-learning-self-learning" title="Github">
             <svg class="github-logo" xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 48 48"><linearGradient id="rL2wppHyxHVbobwndsT6Ca" x1="4" x2="44" y1="23.508" y2="23.508" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#4c4c4c"/><stop offset="1" stop-color="#343434"/></linearGradient><path fill="url(#rL2wppHyxHVbobwndsT6Ca)" d="M24,4C12.954,4,4,12.954,4,24c0,8.887,5.801,16.411,13.82,19.016h12.36	C38.199,40.411,44,32.887,44,24C44,12.954,35.046,4,24,4z"/><path d="M30.01,41.996L30,36.198c0-0.939-0.22-1.856-0.642-2.687c5.641-1.133,8.386-4.468,8.386-10.177	c0-2.255-0.665-4.246-1.976-5.92c0.1-0.317,0.174-0.645,0.22-0.981c0.188-1.369-0.023-2.264-0.193-2.984l-0.027-0.116	c-0.186-0.796-0.409-1.364-0.418-1.388l-0.111-0.282l-0.111-0.282l-0.302-0.032l-0.303-0.032c0,0-0.199-0.021-0.501-0.021	c-0.419,0-1.04,0.042-1.627,0.241l-0.196,0.066c-0.74,0.249-1.439,0.485-2.417,1.069c-0.286,0.171-0.599,0.366-0.934,0.584	C27.334,12.881,25.705,12.69,24,12.69c-1.722,0-3.365,0.192-4.889,0.571c-0.339-0.22-0.654-0.417-0.942-0.589	c-0.978-0.584-1.677-0.819-2.417-1.069l-0.196-0.066c-0.585-0.199-1.207-0.241-1.626-0.241c-0.302,0-0.501,0.021-0.501,0.021	l-0.302,0.032l-0.3,0.031l-0.112,0.281l-0.113,0.283c-0.01,0.026-0.233,0.594-0.419,1.391l-0.027,0.115	c-0.17,0.719-0.381,1.615-0.193,2.983c0.048,0.346,0.125,0.685,0.23,1.011c-1.285,1.666-1.936,3.646-1.936,5.89	c0,5.695,2.748,9.028,8.397,10.17c-0.194,0.388-0.345,0.798-0.452,1.224c-0.197,0.067-0.378,0.112-0.538,0.137	c-0.238,0.036-0.487,0.054-0.739,0.054c-0.686,0-1.225-0.134-1.435-0.259c-0.313-0.186-0.872-0.727-1.414-1.518	c-0.463-0.675-1.185-1.558-1.992-1.927c-0.698-0.319-1.437-0.502-2.029-0.502c-0.138,0-0.265,0.01-0.376,0.028	c-0.517,0.082-0.949,0.366-1.184,0.78c-0.203,0.357-0.235,0.773-0.088,1.141c0.219,0.548,0.851,0.985,1.343,1.255	c0.242,0.133,0.765,0.619,1.07,1.109c0.229,0.368,0.335,0.63,0.482,0.992c0.087,0.215,0.183,0.449,0.313,0.732	c0.47,1.022,1.937,1.924,2.103,2.023c0.806,0.483,2.161,0.638,3.157,0.683l0.123,0.003c0,0,0.001,0,0.001,0	c0.24,0,0.57-0.023,1.004-0.071v2.613c0.002,0.529-0.537,0.649-1.25,0.638l0.547,0.184C19.395,43.572,21.645,44,24,44	c2.355,0,4.605-0.428,6.703-1.176l0.703-0.262C30.695,42.538,30.016,42.422,30.01,41.996z" opacity=".05"/><path d="M30.781,42.797c-0.406,0.047-1.281-0.109-1.281-0.795v-5.804c0-1.094-0.328-2.151-0.936-3.052	c5.915-0.957,8.679-4.093,8.679-9.812c0-2.237-0.686-4.194-2.039-5.822c0.137-0.365,0.233-0.75,0.288-1.147	c0.175-1.276-0.016-2.086-0.184-2.801l-0.027-0.116c-0.178-0.761-0.388-1.297-0.397-1.319l-0.111-0.282l-0.303-0.032	c0,0-0.178-0.019-0.449-0.019c-0.381,0-0.944,0.037-1.466,0.215l-0.196,0.066c-0.714,0.241-1.389,0.468-2.321,1.024	c-0.332,0.198-0.702,0.431-1.101,0.694C27.404,13.394,25.745,13.19,24,13.19c-1.762,0-3.435,0.205-4.979,0.61	c-0.403-0.265-0.775-0.499-1.109-0.699c-0.932-0.556-1.607-0.784-2.321-1.024l-0.196-0.066c-0.521-0.177-1.085-0.215-1.466-0.215	c-0.271,0-0.449,0.019-0.449,0.019l-0.302,0.032l-0.113,0.283c-0.009,0.022-0.219,0.558-0.397,1.319l-0.027,0.116	c-0.169,0.715-0.36,1.524-0.184,2.8c0.056,0.407,0.156,0.801,0.298,1.174c-1.327,1.62-1.999,3.567-1.999,5.795	c0,5.703,2.766,8.838,8.686,9.806c-0.395,0.59-0.671,1.255-0.813,1.964c-0.33,0.13-0.629,0.216-0.891,0.256	c-0.263,0.04-0.537,0.06-0.814,0.06c-0.69,0-1.353-0.129-1.69-0.329c-0.44-0.261-1.057-0.914-1.572-1.665	c-0.35-0.51-1.047-1.417-1.788-1.755c-0.635-0.29-1.298-0.457-1.821-0.457c-0.11,0-0.21,0.008-0.298,0.022	c-0.366,0.058-0.668,0.252-0.828,0.534c-0.128,0.224-0.149,0.483-0.059,0.708c0.179,0.448,0.842,0.85,1.119,1.002	c0.335,0.184,0.919,0.744,1.254,1.284c0.251,0.404,0.37,0.697,0.521,1.067c0.085,0.209,0.178,0.437,0.304,0.712	c0.331,0.719,1.353,1.472,1.905,1.803c0.754,0.452,2.154,0.578,2.922,0.612l0.111,0.002c0.299,0,0.8-0.045,1.495-0.135v3.177	c0,0.779-0.991,0.81-1.234,0.81c-0.031,0,0.503,0.184,0.503,0.184C19.731,43.64,21.822,44,24,44c2.178,0,4.269-0.36,6.231-1.003	C30.231,42.997,30.812,42.793,30.781,42.797z" opacity=".07"/><path fill="#fff" d="M36.744,23.334c0-2.31-0.782-4.226-2.117-5.728c0.145-0.325,0.296-0.761,0.371-1.309	c0.172-1.25-0.031-2-0.203-2.734s-0.375-1.25-0.375-1.25s-0.922-0.094-1.703,0.172s-1.453,0.469-2.422,1.047	c-0.453,0.27-0.909,0.566-1.27,0.806C27.482,13.91,25.785,13.69,24,13.69c-1.801,0-3.513,0.221-5.067,0.652	c-0.362-0.241-0.821-0.539-1.277-0.811c-0.969-0.578-1.641-0.781-2.422-1.047s-1.703-0.172-1.703-0.172s-0.203,0.516-0.375,1.25	s-0.375,1.484-0.203,2.734c0.077,0.562,0.233,1.006,0.382,1.333c-1.31,1.493-2.078,3.397-2.078,5.704	c0,5.983,3.232,8.714,9.121,9.435c-0.687,0.726-1.148,1.656-1.303,2.691c-0.387,0.17-0.833,0.33-1.262,0.394	c-1.104,0.167-2.271,0-2.833-0.333s-1.229-1.083-1.729-1.813c-0.422-0.616-1.031-1.331-1.583-1.583	c-0.729-0.333-1.438-0.458-1.833-0.396c-0.396,0.063-0.583,0.354-0.5,0.563c0.083,0.208,0.479,0.521,0.896,0.75	c0.417,0.229,1.063,0.854,1.438,1.458c0.418,0.674,0.5,1.063,0.854,1.833c0.249,0.542,1.101,1.219,1.708,1.583	c0.521,0.313,1.562,0.491,2.688,0.542c0.389,0.018,1.308-0.096,2.083-0.206v3.75c0,0.639-0.585,1.125-1.191,1.013	C19.756,43.668,21.833,44,24,44c2.166,0,4.243-0.332,6.19-0.984C29.585,43.127,29,42.641,29,42.002v-5.804	c0-1.329-0.527-2.53-1.373-3.425C33.473,32.071,36.744,29.405,36.744,23.334z M11.239,32.727c-0.154-0.079-0.237-0.225-0.185-0.328	c0.052-0.103,0.22-0.122,0.374-0.043c0.154,0.079,0.237,0.225,0.185,0.328S11.393,32.806,11.239,32.727z M12.451,33.482	c-0.081,0.088-0.255,0.06-0.389-0.062s-0.177-0.293-0.096-0.381c0.081-0.088,0.255-0.06,0.389,0.062S12.532,33.394,12.451,33.482z M13.205,34.732c-0.102,0.072-0.275,0.005-0.386-0.15s-0.118-0.34-0.016-0.412s0.275-0.005,0.386,0.15	C13.299,34.475,13.307,34.66,13.205,34.732z M14.288,35.673c-0.069,0.112-0.265,0.117-0.437,0.012s-0.256-0.281-0.187-0.393	c0.069-0.112,0.265-0.117,0.437-0.012S14.357,35.561,14.288,35.673z M15.312,36.594c-0.213-0.026-0.371-0.159-0.353-0.297	c0.017-0.138,0.204-0.228,0.416-0.202c0.213,0.026,0.371,0.159,0.353,0.297C15.711,36.529,15.525,36.62,15.312,36.594z M16.963,36.833c-0.227-0.013-0.404-0.143-0.395-0.289c0.009-0.146,0.2-0.255,0.427-0.242c0.227,0.013,0.404,0.143,0.395,0.289	C17.381,36.738,17.19,36.846,16.963,36.833z M18.521,36.677c-0.242,0-0.438-0.126-0.438-0.281s0.196-0.281,0.438-0.281	c0.242,0,0.438,0.126,0.438,0.281S18.762,36.677,18.521,36.677z"/></svg>
            </a>
          </div>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">
    Lecture 06.00: Cross-Chain Communication - Kết nối các Blockchain
    
  </h1>
  <h1 id="lecture-cross-chain-communication---kết-nối-các-blockchain">Lecture: Cross-Chain Communication - Kết nối các Blockchain</h1>

<h2 id="1-concept-overview">1. Concept Overview</h2>

<p>Blockchain interoperability, hay khả năng các blockchain khác nhau communicate và exchange value với nhau, represents một trong những challenges quan trọng nhất trong blockchain ecosystem evolution. Hiện tại, landscape bao gồm hàng trăm blockchains độc lập - Bitcoin, Ethereum, Binance Smart Chain, Solana, Polkadot, Cosmos, và countless others - mỗi cái operating như isolated island với own consensus, token standards, và application ecosystems. Situation này tạo ra fragmentation harmful cho user experience và capital efficiency.</p>

<p>Historical context của interoperability problem bắt nguồn từ early days của blockchain. Ban đầu, Bitcoin existed alone, và interoperability không phải concern. Khi Ethereum launched năm 2015, bringing smart contracts và token standards mới, nhu cầu move value giữa Bitcoin và Ethereum emerged. Users muốn use Bitcoin’s liquidity trên Ethereum’s DeFi platforms, nhưng không có native mechanism cho cross-chain transfers. Early solutions crude và centralized - exchanges acting như intermediaries, custodial bridges requiring trust.</p>

<p>Năm 2017-2018, <strong>atomic swaps</strong> emerged như first trustless cross-chain solution. Concept introduced bởi <strong>Tier Nolan</strong> năm 2013 nhưng implemented thực sự sau. Atomic swaps sử dụng <strong>Hash Time-Locked Contracts (HTLCs)</strong> để enable peer-to-peer exchanges across chains without intermediaries. Alice trên Bitcoin có thể swap với Bob trên Litecoin một cách trustless, guaranteed rằng either both transfers complete hoặc neither does. Innovation này showed cryptographic protocols có thể replace trusted third parties trong cross-chain scenarios.</p>

<p>Năm 2018-2020, bridge protocols proliferated. <strong>Wrapped Bitcoin (WBTC)</strong> launched năm 2019, becoming successful cross-chain asset. WBTC là ERC-20 token trên Ethereum backed one-to-one bởi Bitcoin locked trong custody. Despite centralization concerns về custodians, WBTC enabled billions of dollars Bitcoin participate trong Ethereum DeFi, demonstrating massive demand cho interoperability. Other wrapped assets followed - renBTC, tBTC, WETH - each với different trust models và mechanisms.</p>

<p><strong>Polkadot</strong> và <strong>Cosmos</strong>, launched 2020, represented architectural approaches khác. Instead of bridging existing chains, they designed ecosystems from ground up for interoperability. Polkadot’s <strong>parachain</strong> model enables specialized blockchains share security của relay chain trong khi communicating seamlessly. Cosmos’s <strong>IBC (Inter-Blockchain Communication)</strong> protocol defines standard cho independent chains communicate, creating “internet of blockchains.” These approaches showed interoperability could be fundamental design principle rather than afterthought.</p>

<p>Năm 2021-2024 witnessed explosion của bridge protocols và devastating security breaches. Ronin bridge hack ($625M), Poly Network ($611M), Wormhole ($325M), và numerous others demonstrated bridges là honey pots for attackers. Total losses from bridge hacks exceeded $2 billion, making interoperability not just technical challenge but critical security concern. This drove research into more secure bridge designs, formal verification, và alternative approaches như <strong>cross-chain messaging protocols</strong> và <strong>shared security models</strong>.</p>

<hr />

<h2 id="2-intuitive-understanding">2. Intuitive Understanding</h2>

<p>Để hiểu interoperability challenge deeply, hãy imagine blockchain ecosystems như countries với own currencies, laws, và languages. Bitcoin như United States với Dollar, Ethereum như European Union với Euro, Solana như Japan với Yen. Mỗi country self-sovereign, với own rules và systems. Citizen của một country muốn trade với citizen của country khác faces numerous frictions: currency exchange rates, incompatible legal systems, communication barriers.</p>

<p>Traditional solution trong international trade là intermediaries - banks facilitate currency conversion, shipping companies handle logistics, customs agents verify compliance. Blockchain bridges serve similar role - acting như intermediaries facilitating asset transfers và message passing giữa incompatible blockchains. However, introducing intermediaries contradicts blockchain’s trustless philosophy, creating tension fundamental.</p>

<p>Hãy visualize problem này qua analogy cụ thể. Alice owns Bitcoin và muốn participate trong Ethereum DeFi protocol Uniswap. Bitcoin blockchain và Ethereum blockchain completely separate - they don’t share validators, don’t read each other’s state, don’t have common language. Alice cannot simply “send” Bitcoin đến Ethereum address - fundamentally incompatible. She needs mechanism để represent Bitcoin value on Ethereum.</p>

<p>Simple approach: Alice sends Bitcoin đến custodian (ví dụ BitGo), custodian mints equivalent WBTC on Ethereum, Alice receives WBTC trong Ethereum wallet. Now she có thể use WBTC trên Uniswap. When done, reverse process: burn WBTC, custodian releases Bitcoin. This works nhưng requires trusting custodian - single point of failure. If custodian malicious hoặc compromised, funds at risk. Không truly decentralized.</p>

<p>Trustless alternative: <strong>Hash Time-Locked Contracts (HTLCs)</strong> enable atomic swaps. Think of HTLCs như coordinated safe deposit boxes với time locks. Alice và Bob each lock funds trong boxes với same secret key hash. Alice sets: “My box opens với secret OR after 48 hours refund me.” Bob sets: “My box opens với same secret OR after 24 hours refund me.” Alice reveals secret to claim Bob’s funds, automatically enabling Bob claim Alice’s funds với same secret. If either party fails cooperate, time locks ensure refunds. No trust needed - cryptography và time locks guarantee fairness.</p>

<p>Modern bridges extend HTLCs concept với sophisticated protocols. <strong>Light clients</strong> allow one blockchain verify state của another blockchain without running full node. Ethereum contract có thể verify Bitcoin transaction occurred bằng cách checking merkle proof against Bitcoin block header. This enables trustless verification, but implementation complexity high và gas costs substantial. Trade-off between security (full verification) và practicality (cost, complexity) persists.</p>

<p>Shared security models như Polkadot’s parachains offer different approach. Instead of independent blockchains bridging afterward, start với shared security layer. All parachains protected by same validator set, making communication trustless by design. Analogy: European Union với shared laws và institutions. Member states specialized nhưng operate under common framework, enabling seamless interaction. Trade-off: less sovereignty (parachains must follow relay chain rules) for better interoperability.</p>

<hr />

<h2 id="3-technical-foundation">3. Technical Foundation</h2>

<p>Cross-chain communication protocols build on several technical primitives requiring deep understanding. <strong>Hash Time-Locked Contracts (HTLCs)</strong> form foundation của many approaches. HTLC construction involves two linked contracts - one on each blockchain - using cryptographic hash function và time-based conditions để coordinate atomic execution. Contract structure includes hashlock (reveals preimage to claim funds) và timelock (refund if deadline passes). Mathematical guarantee ensures atomicity: either both parties receive funds OR both get refunded.</p>

<p>Bitcoin implements HTLCs through Script opcodes specifically. Script sequence typically includes <code class="language-plaintext highlighter-rouge">OP_IF</code> checking whether timeout passed, <code class="language-plaintext highlighter-rouge">OP_SHA256</code> verifying hash preimage, và <code class="language-plaintext highlighter-rouge">OP_CHECKSIG</code> validating signatures. Complete HTLC script trên Bitcoin:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OP_IF
    OP_SHA256 &lt;hash&gt; OP_EQUALVERIFY &lt;pubkey_receiver&gt; OP_CHECKSIG
OP_ELSE
    &lt;timeout&gt; OP_CHECKLOCKTIMEVERIFY OP_DROP &lt;pubkey_sender&gt; OP_CHECKSIG
OP_ENDIF
</code></pre></div></div>

<p>Ethereum HTLCs implemented through Solidity smart contracts với more flexibility. Contract maintains state mapping tracking pending swaps, timeouts, và completions. Sender initiates swap by calling <code class="language-plaintext highlighter-rouge">initiate()</code> với hash, amount, timeout, và recipient. Recipient claims calling <code class="language-plaintext highlighter-rouge">claim()</code> with preimage. If timeout expires before claim, sender calls <code class="language-plaintext highlighter-rouge">refund()</code> to retrieve funds. All operations atomic within respective blockchains, và hash linkage ensures atomicity across chains.</p>

<pre><code class="language-solidity">contract HTLC {
    struct Swap {
        address sender;
        address receiver;
        uint256 amount;
        bytes32 hash;
        uint256 timeout;
        bool completed;
        bool refunded;
    }
    
    mapping(bytes32 =&gt; Swap) public swaps;
    
    function initiate(
        address receiver,
        bytes32 hash,
        uint256 timeout
    ) external payable {
        bytes32 swapId = keccak256(abi.encodePacked(msg.sender, receiver, hash));
        require(swaps[swapId].sender == address(0), "Swap exists");
        
        swaps[swapId] = Swap({
            sender: msg.sender,
            receiver: receiver,
            amount: msg.value,
            hash: hash,
            timeout: block.timestamp + timeout,
            completed: false,
            refunded: false
        });
    }
    
    function claim(bytes32 swapId, bytes32 preimage) external {
        Swap storage swap = swaps[swapId];
        require(!swap.completed &amp;&amp; !swap.refunded, "Swap already settled");
        require(sha256(abi.encodePacked(preimage)) == swap.hash, "Invalid preimage");
        require(block.timestamp &lt; swap.timeout, "Timeout expired");
        
        swap.completed = true;
        payable(swap.receiver).transfer(swap.amount);
    }
    
    function refund(bytes32 swapId) external {
        Swap storage swap = swaps[swapId];
        require(!swap.completed &amp;&amp; !swap.refunded, "Already settled");
        require(block.timestamp &gt;= swap.timeout, "Timeout not reached");
        require(msg.sender == swap.sender, "Not sender");
        
        swap.refunded = true;
        payable(swap.sender).transfer(swap.amount);
    }
}
</code></pre>

<p><strong>Light client verification</strong> enables one blockchain read state của another trustlessly. Light client stores only block headers (approximately 80 bytes per block cho Bitcoin), verifying headers chain correctly via proof-of-work. To verify transaction included, client requests merkle proof từ full node, verifies against header’s merkle root. This allows Ethereum contract verify Bitcoin transaction với minimal storage và computation. Implementation challenge: keeping headers updated costs gas. Solutions include incentivized relayers submitting headers periodically, và only updating when verification needed.</p>

<p><strong>Relay chains</strong> approach problem differently. Instead of direct chain-to-chain communication, introduce intermediary chain coordinating multiple blockchains. Polkadot’s relay chain validates parachain blocks, ensuring correctness globally. Parachains submit block candidates, relay chain validators verify, finalize valid blocks. Cross-chain messages routed through relay chain, which guarantees delivery và ordering. Security model relies on relay chain’s validator set protecting all parachains simultaneously - shared security preventing individual chain compromises.</p>

<p>Inter-Blockchain Communication (IBC) protocol developed by Cosmos takes modular approach. IBC defines standard for sovereign blockchains communicate while maintaining independence. Protocol operates in layers: <strong>transport layer</strong> (reliable packet delivery), <strong>authentication layer</strong> (verify sender), và <strong>ordering layer</strong> (guarantee message sequence). Each blockchain runs IBC module implementing these layers, enabling message passing without shared security. Trust model assumes each chain properly securing itself, với IBC providing communication infrastructure.</p>

<p>State verification across chains requires cryptographic proofs robust. Merkle proofs insufficient alone - need prove block headers valid according to source chain’s consensus rules. For PoW chains, proving header valid means showing sufficient work done. For PoS chains, requires proving validator signatures correct và validators properly staked. For BFT chains, proving quorum signatures valid. Each consensus mechanism requires different verification logic, adding complexity to bridge implementations.</p>

<hr />

<h2 id="4-mathematical--cryptographic-formulation">4. Mathematical / Cryptographic Formulation</h2>

<p>Atomic swap security analysis reveals cryptographic guarantees ensuring fairness. Consider Alice on Bitcoin wanting swap với Bob on Ethereum. Protocol uses secret (s), hash (h = H(s)), và timeouts (t_A, t_B) where (t_B &lt; t_A).</p>

<p><strong>Alice’s Contract</strong> (Bitcoin, timeout (t_A)):
[
\text{Locked} \to \begin{cases}
\text{Bob} &amp; \text{if } \text{reveals } s: H(s) = h <br />
\text{Alice} &amp; \text{if } \text{time} &gt; t_A
\end{cases}
]</p>

<p><strong>Bob’s Contract</strong> (Ethereum, timeout (t_B)):
[
\text{Locked} \to \begin{cases}
\text{Alice} &amp; \text{if } \text{reveals } s: H(s) = h <br />
\text{Bob} &amp; \text{if } \text{time} &gt; t_B
\end{cases}
]</p>

<p><strong>Atomicity Proof</strong>:</p>

<p><strong>Case 1</strong>: Bob claims Alice’s Bitcoin before (t_B)</p>
<ul>
  <li>Bob must reveal (s)</li>
  <li>Alice observes (s), claims Bob’s ETH before (t_B)</li>
  <li>Both transfers succeed ✓</li>
</ul>

<p><strong>Case 2</strong>: Bob doesn’t claim before (t_B)</p>
<ul>
  <li>Bob’s timeout expires first ((t_B &lt; t_A))</li>
  <li>Bob refunded</li>
  <li>Alice sees Bob refunded, doesn’t reveal (s)</li>
  <li>Alice’s timeout expires, Alice refunded</li>
  <li>Both refunded ✓</li>
</ul>

<p><strong>Case 3</strong>: Bob tries claim after timeout</p>
<ul>
  <li>Impossible (contract enforces (t_B))</li>
</ul>

<p><strong>Result</strong>: No scenario where one party loses funds while other gains. Either both succeed or both refunded.</p>

<p><strong>Security Parameter</strong>:
[
t_A - t_B &gt; \text{Max block time difference} + \text{Network latency}
]</p>

<p>Ensures Alice has time to claim after Bob reveals secret.</p>

<p><strong>Light client verification complexity</strong>:</p>

<p>For blockchain với headers (H_1, H_2, …, H_n), storing all headers requires:
[
\text{Storage} = n \times |H| \text{ bytes}
]</p>

<p>Bitcoin header: 80 bytes
Current height: ~850,000 blocks
Total: 68 MB</p>

<p>On Ethereum (expensive storage), cost prohibitive. Solutions:</p>
<ol>
  <li>Store only recent headers</li>
  <li>Store checkpoints + proofs</li>
  <li>Use relay services</li>
</ol>

<p><strong>Merkle proof verification</strong> for transaction (T_x) in block (B_k):</p>

<p>Verifier needs:</p>
<ul>
  <li>Block header (H_k) (80 bytes)</li>
  <li>Merkle proof path (P) ((\log_2 n) hashes where (n) = transactions in block)</li>
</ul>

<p>Verification computes:
[
\text{root} = \text{MerkleCompute}(T_x, P)
]</p>

<p>Checks:
[
\text{root} \stackrel{?}{=} H_k.\text{merkleRoot}
]</p>

<p>Cost: (O(\log n)) hash operations, constant storage.</p>

<p><strong>IBC packet verification</strong> requires proving packet committed on source chain. For packet (p) với commitment (c):</p>

<p>Source chain stores:
[
c = H(p.\text{sequence}, p.\text{data}, p.\text{timeout})
]</p>

<p>Destination verifies:</p>
<ol>
  <li>Commitment exists in source state</li>
  <li>Source state valid (via consensus proof)</li>
  <li>Packet not timed out</li>
</ol>

<p>Verification equation:
[
\text{Verify}(\text{stateProof}, \text{commitment}) \land \text{time} &lt; p.\text{timeout}
]</p>

<hr />

<h2 id="5-implementation-insight">5. Implementation Insight</h2>

<p>Implementation của cross-chain protocols requires careful handling của multiple blockchain states simultaneously. HTLC atomic swap implementation demonstrates coordination pattern fundamental to interoperability solutions.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">hashlib</span>
<span class="kn">import</span> <span class="n">time</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>

<span class="k">class</span> <span class="nc">HTLCSwap</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Hash Time-Locked Contract for atomic swaps</span><span class="sh">"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">swaps</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># swapId -&gt; swap data
</span>        
    <span class="k">def</span> <span class="nf">initiate_swap</span><span class="p">(</span>
        <span class="n">self</span><span class="p">,</span>
        <span class="n">sender</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">receiver</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">amount</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">hash_lock</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span>
        <span class="n">timeout_seconds</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">chain</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Initiate HTLC swap
        
        Args:
            sender: Initiator address
            receiver: Counterparty address
            amount: Amount to lock
            hash_lock: Hash of secret (sha256)
            timeout_seconds: Time until refund allowed
            chain: Which blockchain (BTC/ETH)
        </span><span class="sh">"""</span>
        <span class="n">swap_id</span> <span class="o">=</span> <span class="n">hashlib</span><span class="p">.</span><span class="nf">sha256</span><span class="p">(</span>
            <span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">sender</span><span class="si">}{</span><span class="n">receiver</span><span class="si">}{</span><span class="n">hash_lock</span><span class="p">.</span><span class="nf">hex</span><span class="p">()</span><span class="si">}{</span><span class="n">chain</span><span class="si">}</span><span class="sh">"</span><span class="p">.</span><span class="nf">encode</span><span class="p">()</span>
        <span class="p">).</span><span class="nf">hexdigest</span><span class="p">()</span>
        
        <span class="n">swap</span> <span class="o">=</span> <span class="p">{</span>
            <span class="sh">'</span><span class="s">id</span><span class="sh">'</span><span class="p">:</span> <span class="n">swap_id</span><span class="p">,</span>
            <span class="sh">'</span><span class="s">sender</span><span class="sh">'</span><span class="p">:</span> <span class="n">sender</span><span class="p">,</span>
            <span class="sh">'</span><span class="s">receiver</span><span class="sh">'</span><span class="p">:</span> <span class="n">receiver</span><span class="p">,</span>
            <span class="sh">'</span><span class="s">amount</span><span class="sh">'</span><span class="p">:</span> <span class="n">amount</span><span class="p">,</span>
            <span class="sh">'</span><span class="s">hash_lock</span><span class="sh">'</span><span class="p">:</span> <span class="n">hash_lock</span><span class="p">,</span>
            <span class="sh">'</span><span class="s">timeout</span><span class="sh">'</span><span class="p">:</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">+</span> <span class="n">timeout_seconds</span><span class="p">,</span>
            <span class="sh">'</span><span class="s">chain</span><span class="sh">'</span><span class="p">:</span> <span class="n">chain</span><span class="p">,</span>
            <span class="sh">'</span><span class="s">state</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">INITIATED</span><span class="sh">'</span><span class="p">,</span>
            <span class="sh">'</span><span class="s">secret</span><span class="sh">'</span><span class="p">:</span> <span class="bp">None</span>
        <span class="p">}</span>
        
        <span class="n">self</span><span class="p">.</span><span class="n">swaps</span><span class="p">[</span><span class="n">swap_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">swap</span>
        
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">✓ HTLC Swap initiated on </span><span class="si">{</span><span class="n">chain</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Swap ID: </span><span class="si">{</span><span class="n">swap_id</span><span class="p">[</span><span class="si">:</span><span class="mi">16</span><span class="p">]</span><span class="si">}</span><span class="s">...</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  </span><span class="si">{</span><span class="n">sender</span><span class="si">}</span><span class="s"> → </span><span class="si">{</span><span class="n">receiver</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Amount: </span><span class="si">{</span><span class="n">amount</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Timeout: </span><span class="si">{</span><span class="n">timeout_seconds</span><span class="si">}</span><span class="s">s</span><span class="sh">"</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">swap_id</span>
    
    <span class="k">def</span> <span class="nf">claim_swap</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">swap_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">secret</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Claim funds by revealing secret
        
        Args:
            swap_id: Swap identifier
            secret: Preimage of hash_lock
        </span><span class="sh">"""</span>
        <span class="k">if</span> <span class="n">swap_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">swaps</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">✗ Swap not found</span><span class="sh">"</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
            
        <span class="n">swap</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">swaps</span><span class="p">[</span><span class="n">swap_id</span><span class="p">]</span>
        
        <span class="c1"># Verify swap not already completed/refunded
</span>        <span class="k">if</span> <span class="n">swap</span><span class="p">[</span><span class="sh">'</span><span class="s">state</span><span class="sh">'</span><span class="p">]</span> <span class="o">!=</span> <span class="sh">'</span><span class="s">INITIATED</span><span class="sh">'</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">✗ Swap already </span><span class="si">{</span><span class="n">swap</span><span class="p">[</span><span class="sh">'</span><span class="s">state</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        
        <span class="c1"># Verify timeout not expired
</span>        <span class="k">if</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">swap</span><span class="p">[</span><span class="sh">'</span><span class="s">timeout</span><span class="sh">'</span><span class="p">]:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">✗ Timeout expired</span><span class="sh">"</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        
        <span class="c1"># Verify secret matches hash
</span>        <span class="n">secret_hash</span> <span class="o">=</span> <span class="n">hashlib</span><span class="p">.</span><span class="nf">sha256</span><span class="p">(</span><span class="n">secret</span><span class="p">).</span><span class="nf">digest</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">secret_hash</span> <span class="o">!=</span> <span class="n">swap</span><span class="p">[</span><span class="sh">'</span><span class="s">hash_lock</span><span class="sh">'</span><span class="p">]:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">✗ Invalid secret</span><span class="sh">"</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        
        <span class="c1"># Claim successful!
</span>        <span class="n">swap</span><span class="p">[</span><span class="sh">'</span><span class="s">state</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="sh">'</span><span class="s">CLAIMED</span><span class="sh">'</span>
        <span class="n">swap</span><span class="p">[</span><span class="sh">'</span><span class="s">secret</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">secret</span>
        
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">✓ Swap </span><span class="si">{</span><span class="n">swap_id</span><span class="p">[</span><span class="si">:</span><span class="mi">16</span><span class="p">]</span><span class="si">}</span><span class="s">... CLAIMED on </span><span class="si">{</span><span class="n">swap</span><span class="p">[</span><span class="sh">'</span><span class="s">chain</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Receiver: </span><span class="si">{</span><span class="n">swap</span><span class="p">[</span><span class="sh">'</span><span class="s">receiver</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Amount: </span><span class="si">{</span><span class="n">swap</span><span class="p">[</span><span class="sh">'</span><span class="s">amount</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Secret revealed: </span><span class="si">{</span><span class="n">secret</span><span class="p">.</span><span class="nf">hex</span><span class="p">()[</span><span class="si">:</span><span class="mi">16</span><span class="p">]</span><span class="si">}</span><span class="s">...</span><span class="sh">"</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">True</span>
    
    <span class="k">def</span> <span class="nf">refund_swap</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">swap_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sh">"""</span><span class="s">
        Refund swap after timeout
        
        Args:
            swap_id: Swap identifier
        </span><span class="sh">"""</span>
        <span class="k">if</span> <span class="n">swap_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">swaps</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
            
        <span class="n">swap</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">swaps</span><span class="p">[</span><span class="n">swap_id</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">swap</span><span class="p">[</span><span class="sh">'</span><span class="s">state</span><span class="sh">'</span><span class="p">]</span> <span class="o">!=</span> <span class="sh">'</span><span class="s">INITIATED</span><span class="sh">'</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">✗ Swap already </span><span class="si">{</span><span class="n">swap</span><span class="p">[</span><span class="sh">'</span><span class="s">state</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        
        <span class="k">if</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">swap</span><span class="p">[</span><span class="sh">'</span><span class="s">timeout</span><span class="sh">'</span><span class="p">]:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">✗ Timeout not reached yet</span><span class="sh">"</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        
        <span class="c1"># Refund!
</span>        <span class="n">swap</span><span class="p">[</span><span class="sh">'</span><span class="s">state</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="sh">'</span><span class="s">REFUNDED</span><span class="sh">'</span>
        
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">✓ Swap </span><span class="si">{</span><span class="n">swap_id</span><span class="p">[</span><span class="si">:</span><span class="mi">16</span><span class="p">]</span><span class="si">}</span><span class="s">... REFUNDED on </span><span class="si">{</span><span class="n">swap</span><span class="p">[</span><span class="sh">'</span><span class="s">chain</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Sender: </span><span class="si">{</span><span class="n">swap</span><span class="p">[</span><span class="sh">'</span><span class="s">sender</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Amount: </span><span class="si">{</span><span class="n">swap</span><span class="p">[</span><span class="sh">'</span><span class="s">amount</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">True</span>

<span class="k">class</span> <span class="nc">AtomicSwapCoordinator</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Coordinate atomic swap across two chains</span><span class="sh">"""</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">chain_btc</span> <span class="o">=</span> <span class="nc">HTLCSwap</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">chain_eth</span> <span class="o">=</span> <span class="nc">HTLCSwap</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">execute_atomic_swap</span><span class="p">(</span>
        <span class="n">self</span><span class="p">,</span>
        <span class="n">alice_btc_addr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">bob_eth_addr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">alice_eth_addr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">bob_btc_addr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">btc_amount</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">eth_amount</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Execute full atomic swap between Bitcoin and Ethereum
        
        Alice: Has BTC, wants ETH
        Bob: Has ETH, wants BTC
        </span><span class="sh">"""</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">=== Atomic Swap: BTC ↔ ETH ===</span><span class="se">\n</span><span class="sh">"</span><span class="p">)</span>
        
        <span class="c1"># 1. Alice generates secret
</span>        <span class="n">secret</span> <span class="o">=</span> <span class="n">hashlib</span><span class="p">.</span><span class="nf">sha256</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">alice_secret_random</span><span class="sh">"</span><span class="p">).</span><span class="nf">digest</span><span class="p">()</span>
        <span class="n">hash_lock</span> <span class="o">=</span> <span class="n">hashlib</span><span class="p">.</span><span class="nf">sha256</span><span class="p">(</span><span class="n">secret</span><span class="p">).</span><span class="nf">digest</span><span class="p">()</span>
        
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">1. Alice generates secret</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">   Hash: </span><span class="si">{</span><span class="n">hash_lock</span><span class="p">.</span><span class="nf">hex</span><span class="p">()[</span><span class="si">:</span><span class="mi">32</span><span class="p">]</span><span class="si">}</span><span class="s">...</span><span class="se">\n</span><span class="sh">"</span><span class="p">)</span>
        
        <span class="c1"># 2. Alice locks BTC (timeout: 48 hours)
</span>        <span class="n">swap_btc</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">chain_btc</span><span class="p">.</span><span class="nf">initiate_swap</span><span class="p">(</span>
            <span class="n">sender</span><span class="o">=</span><span class="n">alice_btc_addr</span><span class="p">,</span>
            <span class="n">receiver</span><span class="o">=</span><span class="n">bob_btc_addr</span><span class="p">,</span>
            <span class="n">amount</span><span class="o">=</span><span class="n">btc_amount</span><span class="p">,</span>
            <span class="n">hash_lock</span><span class="o">=</span><span class="n">hash_lock</span><span class="p">,</span>
            <span class="n">timeout_seconds</span><span class="o">=</span><span class="mi">48</span> <span class="o">*</span> <span class="mi">3600</span><span class="p">,</span>
            <span class="n">chain</span><span class="o">=</span><span class="sh">'</span><span class="s">Bitcoin</span><span class="sh">'</span>
        <span class="p">)</span>
        
        <span class="nf">print</span><span class="p">()</span>
        
        <span class="c1"># 3. Bob verifies Alice's BTC lock, then locks ETH (timeout: 24 hours)
</span>        <span class="c1"># Bob's timeout SHORTER - important for security!
</span>        <span class="n">swap_eth</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">chain_eth</span><span class="p">.</span><span class="nf">initiate_swap</span><span class="p">(</span>
            <span class="n">sender</span><span class="o">=</span><span class="n">bob_eth_addr</span><span class="p">,</span>
            <span class="n">receiver</span><span class="o">=</span><span class="n">alice_eth_addr</span><span class="p">,</span>
            <span class="n">amount</span><span class="o">=</span><span class="n">eth_amount</span><span class="p">,</span>
            <span class="n">hash_lock</span><span class="o">=</span><span class="n">hash_lock</span><span class="p">,</span>  <span class="c1"># Same hash!
</span>            <span class="n">timeout_seconds</span><span class="o">=</span><span class="mi">24</span> <span class="o">*</span> <span class="mi">3600</span><span class="p">,</span>
            <span class="n">chain</span><span class="o">=</span><span class="sh">'</span><span class="s">Ethereum</span><span class="sh">'</span>
        <span class="p">)</span>
        
        <span class="nf">print</span><span class="p">()</span>
        
        <span class="c1"># 4. Alice claims Bob's ETH (reveals secret)
</span>        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">2. Alice claims ETH (reveals secret)...</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">chain_eth</span><span class="p">.</span><span class="nf">claim_swap</span><span class="p">(</span><span class="n">swap_eth</span><span class="p">,</span> <span class="n">secret</span><span class="p">)</span>
        
        <span class="nf">print</span><span class="p">()</span>
        
        <span class="c1"># 5. Bob sees secret, claims Alice's BTC
</span>        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">3. Bob claims BTC (using revealed secret)...</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">chain_btc</span><span class="p">.</span><span class="nf">claim_swap</span><span class="p">(</span><span class="n">swap_btc</span><span class="p">,</span> <span class="n">secret</span><span class="p">)</span>
        
        <span class="nf">print</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">✓ ATOMIC SWAP COMPLETED SUCCESSFULLY!</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Alice: </span><span class="si">{</span><span class="n">btc_amount</span><span class="si">}</span><span class="s"> BTC → </span><span class="si">{</span><span class="n">eth_amount</span><span class="si">}</span><span class="s"> ETH</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Bob: </span><span class="si">{</span><span class="n">eth_amount</span><span class="si">}</span><span class="s"> ETH → </span><span class="si">{</span><span class="n">btc_amount</span><span class="si">}</span><span class="s"> BTC</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># Example usage
</span><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">coordinator</span> <span class="o">=</span> <span class="nc">AtomicSwapCoordinator</span><span class="p">()</span>
    
    <span class="n">coordinator</span><span class="p">.</span><span class="nf">execute_atomic_swap</span><span class="p">(</span>
        <span class="n">alice_btc_addr</span><span class="o">=</span><span class="sh">"</span><span class="s">alice_btc</span><span class="sh">"</span><span class="p">,</span>
        <span class="n">bob_eth_addr</span><span class="o">=</span><span class="sh">"</span><span class="s">bob_eth</span><span class="sh">"</span><span class="p">,</span>
        <span class="n">alice_eth_addr</span><span class="o">=</span><span class="sh">"</span><span class="s">alice_eth</span><span class="sh">"</span><span class="p">,</span>
        <span class="n">bob_btc_addr</span><span class="o">=</span><span class="sh">"</span><span class="s">bob_btc</span><span class="sh">"</span><span class="p">,</span>
        <span class="n">btc_amount</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">eth_amount</span><span class="o">=</span><span class="mf">15.0</span>
    <span class="p">)</span>
</code></pre></div></div>

<p><strong>Relay chain architecture</strong> trong Polkadot involves sophisticated state verification mechanisms. Validators assigned to parachains attest to block validity. These attestations aggregated và included trong relay chain blocks. Cross-chain messages stored trong relay chain state, enabling recipient parachains retrieve và process messages trustlessly. Security derives từ relay chain’s validator set economically secured through staking.</p>

<p>Cosmos IBC implementation requires both chains run Tendermint consensus hoặc compatible BFT. IBC relayer (off-chain process) monitors both chains, submitting headers và proofs to counterparty. When chain A sends packet to chain B, relayer submits proof to chain B showing packet committed on chain A. Chain B verifies proof using chain A’s validator signatures stored trong client state. Verification equation:</p>

<p>[
\text{Verify}<em>{\text{ClientState}_A}(\text{signature}</em>{\text{validators}}, \text{packet_commitment})
]</p>

<p>Only if verification succeeds, packet processed.</p>

<hr />

<h2 id="6-common-challenges--attacks--trade-offs">6. Common Challenges / Attacks / Trade-offs</h2>

<p>Bridge security remains paramount concern following numerous high-profile hacks exceeding $2 billion total losses. <strong>Ronin bridge attack</strong> (March 2022, $625M) showcased validator compromise vulnerability. Ronin used nine validators, requiring five signatures for withdrawals. Attackers compromised five validator private keys through social engineering và infrastructure vulnerabilities, enabling them mint arbitrary amounts và drain bridge. Attack demonstrated concentration risk - too few validators creates single point of failure despite multisig.</p>

<p><strong>Wormhole hack</strong> (February 2022, $325M) exploited signature verification bug. Attacker bypassed guardian signature check, allowing them mint wrapped tokens without locking equivalent assets on source chain. Bug subtle - verification logic failed properly validate all signatures, assuming earlier checks sufficient. This highlights smart contract security challenges amplified trong bridges where funds locked equal total value at risk.</p>

<p><strong>Trust assumptions</strong> vary dramatically across bridge designs. Custodial bridges (WBTC) require trusting centralized entities holding source assets. Federation bridges (Multichain) distribute trust across set of validators but create n-of-m trust model. Trustless bridges attempt cryptographic verification but face gas costs và complexity challenges. No bridge truly trustless - all involve assumptions về source chain security, validator honesty, hoặc implementation correctness.</p>

<p><strong>Liquidity fragmentation</strong> worsens as bridges proliferate. Multiple Bitcoin representations exist on Ethereum - WBTC, renBTC, tBTC, hBTC - each incompatible và fragmenting liquidity. User wanting trade Bitcoin on Ethereum must choose which wrapper, affecting available liquidity và creating arbitrage opportunities. Standardization attempts (like Bitcoin SPV proofs) struggle gain adoption due to varying security models và gas costs.</p>

<p>Cross-chain MEV introduces attack vectors novel. Attacker monitoring pending bridge transactions có thể front-run on destination chain, back-run on source chain, hoặc sandwich both sides. Oracle manipulation affects cross-chain bridges relying on price feeds. Flash loan attacks amplified - borrow on one chain, manipulate price, trigger favorable cross-chain action, repay loan. Multi-chain atomicity creates opportunities for sophisticated exploits.</p>

<p><strong>Data availability</strong> critical cho optimistic bridges relying on fraud proofs. If transaction data không available, validators cannot verify validity, cannot construct fraud proofs. Solutions include posting transaction data to multiple chains, using erasure coding for redundancy, và requiring data availability attestations. Trade-off: more data means higher costs, limiting scalability benefits.</p>

<p><strong>Finality differences</strong> create challenges. Bitcoin has probabilistic finality (6 confirmations standard), Ethereum had probabilistic (now absolute post-Merge), BFT chains have immediate finality. Bridges must handle varying finality guarantees carefully. Waiting for finality on source chain before allowing claims on destination adds latency. Not waiting risks reorganizations invalidating transfers, creating double-spend scenarios.</p>

<hr />

<h2 id="7-related-concepts">7. Related Concepts</h2>

<p>Cross-chain communication relates intimately to <strong>blockchain interoperability standards</strong> emerging across industry. Token standards like ERC-20 enable composability within Ethereum, but cross-chain requires meta-standards coordinating multiple ecosystems. <strong>Cross-Chain Transfer Protocol (CCTP)</strong> by Circle enables native USDC burning on one chain, minting on another, avoiding wrapped tokens entirely. This shows asset-specific solutions possible where generic bridges struggle.</p>

<p><strong>Liquidity networks</strong> like <strong>Connext</strong> và <strong>Hop Protocol</strong> optimize cross-chain transfers through liquidity pools on destination chains. Instead of waiting for slow bridge finality, users swap through pools, receiving funds immediately. Liquidity providers rebalanced through canonical bridge afterward. This separates user experience (fast) from security (slow but safe canonical bridge), improving usability substantially.</p>

<p><strong>Cross-chain DEXs</strong> attempt enable trading across chains seamlessly. <strong>THORChain</strong> provides liquidity pools for native assets across multiple chains, using continuous liquidity pools và incentivized node operators. Users swap BTC for ETH directly without wrapping. Security model relies on node operators bonding RUNE token, economically incentivizing honest behavior. However, THORChain suffered multiple hacks, showing cross-chain DEX security challenges remain.</p>

<p><strong>Blockchain abstraction layers</strong> like <strong>LayerZero</strong> và <strong>Axelar</strong> provide messaging infrastructure. Instead of asset bridges, they enable arbitrary message passing between chains. Smart contract on Ethereum can call function on Avalanche, with results returned. This enables complex cross-chain applications - governance voting on one chain controlling protocol on another, cross-chain lending, unified liquidity management. Implementation complexity high but unlocks composability across chains.</p>

<p><strong>Shared sequencing</strong> represents newer approach where single sequencer orders transactions across multiple rollups simultaneously. This enables atomic cross-rollup transactions without asynchronous messaging. All rollups using shared sequencer have synchronized state, eliminating traditional cross-chain latency. Trade-off: centralizes sequencing (though can be decentralized through rotation/auction), but significantly simplifies interoperability.</p>

<hr />

<h2 id="8--fundamental-papers--whitepapers">8. ⭐ Fundamental Papers / Whitepapers</h2>

<table>
  <thead>
    <tr>
      <th>Paper</th>
      <th>Year</th>
      <th>Author(s)</th>
      <th>Contribution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>“Atomic Cross-Chain Swaps”</strong></td>
      <td>2013</td>
      <td>Tier Nolan</td>
      <td>First description of trustless atomic swaps using HTLCs</td>
    </tr>
    <tr>
      <td><strong>“Bitcoin and Cryptocurrency Technologies”</strong></td>
      <td>2016</td>
      <td>Narayanan et al.</td>
      <td>Chapter on cross-chain protocols</td>
    </tr>
    <tr>
      <td><strong>“Polkadot: Vision for a Heterogeneous Multi-Chain Framework”</strong></td>
      <td>2016</td>
      <td>Gavin Wood</td>
      <td>Relay chain và parachain architecture</td>
    </tr>
    <tr>
      <td><strong>“Cosmos: A Network of Distributed Ledgers”</strong></td>
      <td>2016</td>
      <td>Jae Kwon, Ethan Buchman</td>
      <td>IBC protocol foundations</td>
    </tr>
    <tr>
      <td><strong>“IBC Protocol Specification”</strong></td>
      <td>2020</td>
      <td>Cosmos team</td>
      <td>Complete IBC technical spec</td>
    </tr>
    <tr>
      <td><strong>“XCMP: Cross-Chain Message Passing”</strong></td>
      <td>2020</td>
      <td>Polkadot team</td>
      <td>Parachain communication protocol</td>
    </tr>
    <tr>
      <td><strong>“LayerZero: Trustless Omnichain Interoperability Protocol”</strong></td>
      <td>2021</td>
      <td>LayerZero Labs</td>
      <td>Ultra-light node verification</td>
    </tr>
    <tr>
      <td><strong>“Wormhole: A Generic Message Passing Protocol”</strong></td>
      <td>2021</td>
      <td>Certus One</td>
      <td>Guardian network approach</td>
    </tr>
    <tr>
      <td><strong>“THORChain: A Decentralized Liquidity Network”</strong></td>
      <td>2018</td>
      <td>THORChain team</td>
      <td>Cross-chain DEX design</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="9--illustrations--visual-references">9. 🎨 Illustrations &amp; Visual References</h2>

<h3 id="htlc-atomic-swap-flow">HTLC Atomic Swap Flow</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Alice (Bitcoin)                          Bob (Ethereum)
     |                                        |
     | 1. Generate secret s, compute h=H(s)  |
     | 2. Lock BTC with h, timeout 48h       |
     |---------------------------------------&gt;|
     |                                        | 3. Verify BTC lock
     |                                        | 4. Lock ETH with h, timeout 24h
     |&lt;---------------------------------------|
     | 5. Claim ETH with secret s            |
     |---------------------------------------&gt;|
     |                                        | 6. See secret s revealed
     |                                        | 7. Claim BTC with secret s
     |&lt;---------------------------------------|
     ✓ Both parties received funds!
</code></pre></div></div>
<p><em>Diagram: HTLC atomic swap protocol flow</em></p>

<h3 id="bridge-architecture-comparison">Bridge Architecture Comparison</h3>

<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Trust Model</th>
      <th>Security</th>
      <th>Examples</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Custodial</strong></td>
      <td>Trust entity</td>
      <td>Centralized risk</td>
      <td>WBTC, centralized exchanges</td>
    </tr>
    <tr>
      <td><strong>Federation</strong></td>
      <td>Trust n-of-m validators</td>
      <td>Distributed trust</td>
      <td>Multichain, Synapse</td>
    </tr>
    <tr>
      <td><strong>Optimistic</strong></td>
      <td>Trust 1-of-n honest validator</td>
      <td>Fraud proof based</td>
      <td>Optimism Bridge, Arbitrum</td>
    </tr>
    <tr>
      <td><strong>ZK</strong></td>
      <td>Trust cryptography</td>
      <td>Math-based</td>
      <td>zkSync Bridge</td>
    </tr>
    <tr>
      <td><strong>Shared Security</strong></td>
      <td>Trust relay chain</td>
      <td>Validator set</td>
      <td>Polkadot parachains</td>
    </tr>
  </tbody>
</table>

<p><em>Source: <a href="https://l2beat.com/bridges/risk">L2Beat Bridge Risk Framework</a></em></p>

<h3 id="cross-chain-communication-landscape">Cross-Chain Communication Landscape</h3>
<p><img src="https://tutorials.cosmos.network/resized-images/600/academy/2-cosmos-concepts/images/ibc.png" alt="IBC Protocol Architecture" /><br />
<em>Source: <a href="https://tutorials.cosmos.network/academy/2-cosmos-concepts/6-ibc.html">Cosmos IBC Documentation</a></em></p>

<h3 id="polkadot-architecture">Polkadot Architecture</h3>
<p><img src="https://wiki.polkadot.network/assets/images/polkadot-relay-chain-0e42bf5a5e344e33ca945ef2d5d82c24.png" alt="Polkadot Relay Chain and Parachains" /><br />
<em>Source: <a href="https://wiki.polkadot.network/">Polkadot Wiki</a></em></p>

<h3 id="interactive-tools">Interactive Tools</h3>
<ul>
  <li><a href="https://www.mintscan.io/cosmos/relayers">Cosmos IBC Tracker</a> - Monitor IBC transfers</li>
  <li><a href="https://polkadot.js.org/">Polkadot.js</a> - Interact with Polkadot ecosystem</li>
  <li><a href="https://dune.com/browse/dashboards?q=bridge">Bridge Analytics</a> - Cross-chain volume data</li>
  <li><a href="https://l2beat.com/bridges">L2Beat Bridges</a> - Bridge security rankings</li>
</ul>

<hr />

<h2 id="10-summary-và-key-takeaways">10. Summary và Key Takeaways</h2>

<p>Cross-chain communication represents frontier critical cho blockchain’s evolution from isolated networks to interconnected ecosystem. Technical approaches range từ atomic swaps using HTLCs (trustless but limited functionality) to sophisticated bridge protocols (greater functionality but introduced trust assumptions) to purpose-built interoperability platforms (Polkadot, Cosmos) designed from ground up for cross-chain operations.</p>

<p>Core technical challenge involves verifying state của one blockchain from another without running full node. Solutions include light clients (verify headers và merkle proofs), relay chains (shared validators), và oracle networks (external verification). Each approach trades off between security guarantees, implementation complexity, gas costs, và trust assumptions. No solution achieves perfect trustlessness while maintaining practicality.</p>

<p>Security remains paramount concern. Bridge hacks totaling &gt;$2 billion demonstrate vulnerability của cross-chain infrastructure. Concentrating value trong bridges creates honeypots attracting sophisticated attackers. Defense requires multi-layered approach: secure validator sets (geographic diversity, key management), robust smart contract code (formal verification, audits), monitoring systems (anomaly detection), và economic security (insurance funds, slashing).</p>

<p>Mathematical guarantees underpin trustless approaches. HTLCs prove atomicity through hash preimage requirements và time locks. Light client verification proves transaction inclusion through merkle proofs và consensus verification. Zero-knowledge proofs enable succinct state verification. Understanding these cryptographic foundations essential for evaluating bridge security claims.</p>

<p>Future directions include shared sequencing across rollups, intent-based cross-chain protocols where users express desired outcomes rather than specific paths, và standardization efforts like EIP-5164 (Cross-Chain Execution). As blockchain ecosystem matures, interoperability transitions from nice-to-have feature to fundamental infrastructure requirement. Mastering cross-chain communication concepts positions developers và researchers at forefront của blockchain’s next evolution phase.</p>

<hr />

<p>✅ <strong>End of Lecture</strong></p>

<p>Next: Lecture 06.01 - Blockchain Bridges: Architecture và Security</p>

<hr />

<h2 id="references">References</h2>

<ol>
  <li>Nolan, T. (2013). <em>Atomic Cross-Chain Swaps</em>. BitcoinTalk Forum.</li>
  <li>Wood, G. (2016). <em>Polkadot: Vision for a Heterogeneous Multi-Chain Framework</em>. Polkadot Whitepaper.</li>
  <li>Kwon, J., &amp; Buchman, E. (2016). <em>Cosmos: A Network of Distributed Ledgers</em>. Cosmos Whitepaper.</li>
  <li>Cosmos Network. (2020). <em>IBC Protocol Specification</em>. https://github.com/cosmos/ibc</li>
  <li>LayerZero Labs. (2021). <em>LayerZero: Trustless Omnichain Interoperability Protocol</em>. LayerZero Whitepaper.</li>
  <li>L2Beat Team. (2024). <em>Bridge Risk Framework</em>. https://l2beat.com/bridges/risk</li>
</ol>


</div>

<!-- Back to Chapter Home Link -->

  
  
  <div style="margin-top: 20px; padding: 10px; background-color: #f8f9fa; border-left: 4px solid #007bff;">
    <a href="/deep-learning-self-learning/contents/vi/chapter06/" style="text-decoration: none; color: #007bff; font-weight: bold;">
      ← Quay lại đầu chương
    </a>
  </div>













<div class="related">
  <ul class="related-posts">
    
      
    
      
    
      
    
    
    
  
    
      <li>
        <h2>Next Post</h2>
        <h3>
          <a href="/deep-learning-self-learning/contents/vi/chapter06/blockchain-chapter06/06_01_Blockchain_Bridges/">
            Lecture 06.01: Blockchain Bridges - Architecture, Security, và Trade-offs
          </a>
        </h3>
      </li>
    
  
    
  
  </ul>
</div>



<script src="https://utteranc.es/client.js"
        repo="convex-deep-learning-for-all/convex-deep-learning-for-all.github.io"
        issue-term="title"
        label="Comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src='/deep-learning-self-learning/public/js/script.js'></script>
    <script src='/deep-learning-self-learning/public/js/multilang.js'></script>
    <script src='/deep-learning-self-learning/public/js/search.js'></script>
  </body>
</html>

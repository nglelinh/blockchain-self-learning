<!DOCTYPE html>
<html lang="vi">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <style>
    .MathJax {
      padding: 2em 0.3em;
      overflow-x: auto;
      overflow-y: hidden;
    }
  </style>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

  <title>
    
      Lecture 06.01: Blockchain Bridges - Architecture, Security, v√† Trade-offs &middot; Blockchain
    
  </title>

  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/poole.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/syntax.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/lanyon.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/github-markdown.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/multilang.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/search.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/content-boxes.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap">
  
  <!-- Lunr.js for search functionality -->
  <script src="https://unpkg.com/lunr/lunr.js"></script>

  <link rel="apple-touch-icon-precomposed" sizes="122x144" href="http://0.0.0.0:4000/deep-learning-self-learning/public/logo.png">
  <link rel="shortcut icon" href="http://0.0.0.0:4000/deep-learning-self-learning/public/convex-logo-144x144.png">

  <link rel="alternate" type="application/rss+xml" title="RSS" href="http://0.0.0.0:4000/deep-learning-self-learning/atom.xml">

  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', '', 'auto');
    ga('send', 'pageview');
  </script>
  
</head>


  <body class="sidebar-overlay">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>Blockchain</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/">Trang ch·ªß</a>

    

    
    
    
    <!-- Hi·ªÉn th·ªã c√°c ch∆∞∆°ng c√≥ s·∫µn cho ng√¥n ng·ªØ hi·ªán t·∫°i -->
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter00/">
              00. Chapter 00: N·ªÅn T·∫£ng Blockchain
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter01/">
              01. Chapter 01: Bitcoin - Architecture v√† Proof-of-Work
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter02/">
              02. Chapter 02: Advanced Consensus Mechanisms
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter03/">
              03. Chapter 03: Ethereum v√† Smart Contracts
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter04/">
              04. Chapter 04: Blockchain Scalability v√† Layer-2 Solutions
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter05/">
              05. Chapter 05: Privacy v√† Security trong Blockchain
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter06/">
              06. Chapter 06: Blockchain Interoperability
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter07/">
              07. Chapter 07: Advanced Blockchain Topics
              
            </a>
          
        
      
    
    
    <!-- N·∫øu kh√¥ng c√≥ n·ªôi dung cho ng√¥n ng·ªØ hi·ªán t·∫°i, hi·ªÉn th·ªã th√¥ng b√°o -->
    
    
    <span class="sidebar-nav-item">Currently v0.0.1</span>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2025. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap github-md-body">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/deep-learning-self-learning/" title="Trang ch·ªß">Blockchain</a>
            <small></small>
          </h3>
          <!-- Header Actions: Language Toggle and GitHub Link -->
          <div class="header-actions">
            <div class="language-toggle">
              <a href="/deep-learning-self-learning/contents/en/chapter00/" class="language-switch" title="Chuy·ªÉn sang ti·∫øng Anh">Chuy·ªÉn sang ti·∫øng Anh</a>
            </div>
            <a class="github-logo__wrapper" target="_blank" href="https://github.com/nglelinh/deep-learning-self-learning" title="Github">
             <svg class="github-logo" xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 48 48"><linearGradient id="rL2wppHyxHVbobwndsT6Ca" x1="4" x2="44" y1="23.508" y2="23.508" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#4c4c4c"/><stop offset="1" stop-color="#343434"/></linearGradient><path fill="url(#rL2wppHyxHVbobwndsT6Ca)" d="M24,4C12.954,4,4,12.954,4,24c0,8.887,5.801,16.411,13.82,19.016h12.36	C38.199,40.411,44,32.887,44,24C44,12.954,35.046,4,24,4z"/><path d="M30.01,41.996L30,36.198c0-0.939-0.22-1.856-0.642-2.687c5.641-1.133,8.386-4.468,8.386-10.177	c0-2.255-0.665-4.246-1.976-5.92c0.1-0.317,0.174-0.645,0.22-0.981c0.188-1.369-0.023-2.264-0.193-2.984l-0.027-0.116	c-0.186-0.796-0.409-1.364-0.418-1.388l-0.111-0.282l-0.111-0.282l-0.302-0.032l-0.303-0.032c0,0-0.199-0.021-0.501-0.021	c-0.419,0-1.04,0.042-1.627,0.241l-0.196,0.066c-0.74,0.249-1.439,0.485-2.417,1.069c-0.286,0.171-0.599,0.366-0.934,0.584	C27.334,12.881,25.705,12.69,24,12.69c-1.722,0-3.365,0.192-4.889,0.571c-0.339-0.22-0.654-0.417-0.942-0.589	c-0.978-0.584-1.677-0.819-2.417-1.069l-0.196-0.066c-0.585-0.199-1.207-0.241-1.626-0.241c-0.302,0-0.501,0.021-0.501,0.021	l-0.302,0.032l-0.3,0.031l-0.112,0.281l-0.113,0.283c-0.01,0.026-0.233,0.594-0.419,1.391l-0.027,0.115	c-0.17,0.719-0.381,1.615-0.193,2.983c0.048,0.346,0.125,0.685,0.23,1.011c-1.285,1.666-1.936,3.646-1.936,5.89	c0,5.695,2.748,9.028,8.397,10.17c-0.194,0.388-0.345,0.798-0.452,1.224c-0.197,0.067-0.378,0.112-0.538,0.137	c-0.238,0.036-0.487,0.054-0.739,0.054c-0.686,0-1.225-0.134-1.435-0.259c-0.313-0.186-0.872-0.727-1.414-1.518	c-0.463-0.675-1.185-1.558-1.992-1.927c-0.698-0.319-1.437-0.502-2.029-0.502c-0.138,0-0.265,0.01-0.376,0.028	c-0.517,0.082-0.949,0.366-1.184,0.78c-0.203,0.357-0.235,0.773-0.088,1.141c0.219,0.548,0.851,0.985,1.343,1.255	c0.242,0.133,0.765,0.619,1.07,1.109c0.229,0.368,0.335,0.63,0.482,0.992c0.087,0.215,0.183,0.449,0.313,0.732	c0.47,1.022,1.937,1.924,2.103,2.023c0.806,0.483,2.161,0.638,3.157,0.683l0.123,0.003c0,0,0.001,0,0.001,0	c0.24,0,0.57-0.023,1.004-0.071v2.613c0.002,0.529-0.537,0.649-1.25,0.638l0.547,0.184C19.395,43.572,21.645,44,24,44	c2.355,0,4.605-0.428,6.703-1.176l0.703-0.262C30.695,42.538,30.016,42.422,30.01,41.996z" opacity=".05"/><path d="M30.781,42.797c-0.406,0.047-1.281-0.109-1.281-0.795v-5.804c0-1.094-0.328-2.151-0.936-3.052	c5.915-0.957,8.679-4.093,8.679-9.812c0-2.237-0.686-4.194-2.039-5.822c0.137-0.365,0.233-0.75,0.288-1.147	c0.175-1.276-0.016-2.086-0.184-2.801l-0.027-0.116c-0.178-0.761-0.388-1.297-0.397-1.319l-0.111-0.282l-0.303-0.032	c0,0-0.178-0.019-0.449-0.019c-0.381,0-0.944,0.037-1.466,0.215l-0.196,0.066c-0.714,0.241-1.389,0.468-2.321,1.024	c-0.332,0.198-0.702,0.431-1.101,0.694C27.404,13.394,25.745,13.19,24,13.19c-1.762,0-3.435,0.205-4.979,0.61	c-0.403-0.265-0.775-0.499-1.109-0.699c-0.932-0.556-1.607-0.784-2.321-1.024l-0.196-0.066c-0.521-0.177-1.085-0.215-1.466-0.215	c-0.271,0-0.449,0.019-0.449,0.019l-0.302,0.032l-0.113,0.283c-0.009,0.022-0.219,0.558-0.397,1.319l-0.027,0.116	c-0.169,0.715-0.36,1.524-0.184,2.8c0.056,0.407,0.156,0.801,0.298,1.174c-1.327,1.62-1.999,3.567-1.999,5.795	c0,5.703,2.766,8.838,8.686,9.806c-0.395,0.59-0.671,1.255-0.813,1.964c-0.33,0.13-0.629,0.216-0.891,0.256	c-0.263,0.04-0.537,0.06-0.814,0.06c-0.69,0-1.353-0.129-1.69-0.329c-0.44-0.261-1.057-0.914-1.572-1.665	c-0.35-0.51-1.047-1.417-1.788-1.755c-0.635-0.29-1.298-0.457-1.821-0.457c-0.11,0-0.21,0.008-0.298,0.022	c-0.366,0.058-0.668,0.252-0.828,0.534c-0.128,0.224-0.149,0.483-0.059,0.708c0.179,0.448,0.842,0.85,1.119,1.002	c0.335,0.184,0.919,0.744,1.254,1.284c0.251,0.404,0.37,0.697,0.521,1.067c0.085,0.209,0.178,0.437,0.304,0.712	c0.331,0.719,1.353,1.472,1.905,1.803c0.754,0.452,2.154,0.578,2.922,0.612l0.111,0.002c0.299,0,0.8-0.045,1.495-0.135v3.177	c0,0.779-0.991,0.81-1.234,0.81c-0.031,0,0.503,0.184,0.503,0.184C19.731,43.64,21.822,44,24,44c2.178,0,4.269-0.36,6.231-1.003	C30.231,42.997,30.812,42.793,30.781,42.797z" opacity=".07"/><path fill="#fff" d="M36.744,23.334c0-2.31-0.782-4.226-2.117-5.728c0.145-0.325,0.296-0.761,0.371-1.309	c0.172-1.25-0.031-2-0.203-2.734s-0.375-1.25-0.375-1.25s-0.922-0.094-1.703,0.172s-1.453,0.469-2.422,1.047	c-0.453,0.27-0.909,0.566-1.27,0.806C27.482,13.91,25.785,13.69,24,13.69c-1.801,0-3.513,0.221-5.067,0.652	c-0.362-0.241-0.821-0.539-1.277-0.811c-0.969-0.578-1.641-0.781-2.422-1.047s-1.703-0.172-1.703-0.172s-0.203,0.516-0.375,1.25	s-0.375,1.484-0.203,2.734c0.077,0.562,0.233,1.006,0.382,1.333c-1.31,1.493-2.078,3.397-2.078,5.704	c0,5.983,3.232,8.714,9.121,9.435c-0.687,0.726-1.148,1.656-1.303,2.691c-0.387,0.17-0.833,0.33-1.262,0.394	c-1.104,0.167-2.271,0-2.833-0.333s-1.229-1.083-1.729-1.813c-0.422-0.616-1.031-1.331-1.583-1.583	c-0.729-0.333-1.438-0.458-1.833-0.396c-0.396,0.063-0.583,0.354-0.5,0.563c0.083,0.208,0.479,0.521,0.896,0.75	c0.417,0.229,1.063,0.854,1.438,1.458c0.418,0.674,0.5,1.063,0.854,1.833c0.249,0.542,1.101,1.219,1.708,1.583	c0.521,0.313,1.562,0.491,2.688,0.542c0.389,0.018,1.308-0.096,2.083-0.206v3.75c0,0.639-0.585,1.125-1.191,1.013	C19.756,43.668,21.833,44,24,44c2.166,0,4.243-0.332,6.19-0.984C29.585,43.127,29,42.641,29,42.002v-5.804	c0-1.329-0.527-2.53-1.373-3.425C33.473,32.071,36.744,29.405,36.744,23.334z M11.239,32.727c-0.154-0.079-0.237-0.225-0.185-0.328	c0.052-0.103,0.22-0.122,0.374-0.043c0.154,0.079,0.237,0.225,0.185,0.328S11.393,32.806,11.239,32.727z M12.451,33.482	c-0.081,0.088-0.255,0.06-0.389-0.062s-0.177-0.293-0.096-0.381c0.081-0.088,0.255-0.06,0.389,0.062S12.532,33.394,12.451,33.482z M13.205,34.732c-0.102,0.072-0.275,0.005-0.386-0.15s-0.118-0.34-0.016-0.412s0.275-0.005,0.386,0.15	C13.299,34.475,13.307,34.66,13.205,34.732z M14.288,35.673c-0.069,0.112-0.265,0.117-0.437,0.012s-0.256-0.281-0.187-0.393	c0.069-0.112,0.265-0.117,0.437-0.012S14.357,35.561,14.288,35.673z M15.312,36.594c-0.213-0.026-0.371-0.159-0.353-0.297	c0.017-0.138,0.204-0.228,0.416-0.202c0.213,0.026,0.371,0.159,0.353,0.297C15.711,36.529,15.525,36.62,15.312,36.594z M16.963,36.833c-0.227-0.013-0.404-0.143-0.395-0.289c0.009-0.146,0.2-0.255,0.427-0.242c0.227,0.013,0.404,0.143,0.395,0.289	C17.381,36.738,17.19,36.846,16.963,36.833z M18.521,36.677c-0.242,0-0.438-0.126-0.438-0.281s0.196-0.281,0.438-0.281	c0.242,0,0.438,0.126,0.438,0.281S18.762,36.677,18.521,36.677z"/></svg>
            </a>
          </div>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">
    Lecture 06.01: Blockchain Bridges - Architecture, Security, v√† Trade-offs
    
  </h1>
  <h1 id="lecture-blockchain-bridges---architecture-security-v√†-trade-offs">Lecture: Blockchain Bridges - Architecture, Security, v√† Trade-offs</h1>

<h2 id="1-concept-overview">1. Concept Overview</h2>

<p>Blockchain bridges l√† critical infrastructure enabling value v√† information flow gi·ªØa isolated blockchain networks. Trong blockchain landscape hi·ªán t·∫°i v·ªõi hundreds of independent chains, bridges serve nh∆∞ highways connecting separate islands, facilitating asset transfers, message passing, v√† cross-chain application logic. However, bridges c≈©ng represent m·ªôt trong nh·ªØng vulnerable components trong entire ecosystem, v·ªõi total losses from bridge exploits exceeding two billion dollars, making bridge security arguably the most pressing challenge trong blockchain interoperability.</p>

<p>Historical evolution c·ªßa bridges reflects growing sophistication trong approach v√† painful lessons t·ª´ security breaches. Early bridges extremely primitive - centralized exchanges acting nh∆∞ intermediaries, requiring users trust third parties completely. Users deposit Bitcoin on exchange, exchange credits account, users withdraw equivalent value tr√™n different chain. This model contradicted blockchain‚Äôs trustless philosophy entirely nh∆∞ng remained dominant method for years due to simplicity v√† liquidity.</p>

<p>First generation decentralized bridges emerged 2017-2019. <strong>Wrapped Bitcoin (WBTC)</strong>, launched January 2019, introduced custodial model v·ªõi semi-decentralized governance. Bitcoin locked by custodians (BitGo initially), merchants mint corresponding ERC-20 tokens on Ethereum, smart contract manages minting/burning. While custodians centralized, transparency improved through on-chain reserves verification. WBTC rapidly became dominant Bitcoin representation on Ethereum, demonstrating massive demand for trustless Bitcoin in DeFi despite trust assumptions inherent trong design.</p>

<p><strong>RenVM</strong> launched 2020 v·ªõi different approach - distributed custody through secure multi-party computation. Instead of single custodian holding private keys, RenVM split keys across network of nodes using threshold signatures. No single node could access funds unilaterally. This reduced custodial risk significantly but introduced complexity v√† novel attack vectors. RenVM demonstrated feasibility of decentralized custody at scale, managing billions in assets across multiple chains.</p>

<p>Validator-based bridges proliferated 2020-2021. <strong>Polygon PoS bridge</strong>, <strong>Avalanche bridge</strong>, v√† <strong>Binance bridge</strong> used validator sets monitoring source chain, signing off on transfers to destination chain. Security depended on honest majority among validators - typically multi-signature schemes requiring threshold signatures. Economics incentivized honest behavior through validator stakes subject to slashing. However, validator set often small (9-21 validators common), creating attack surface if validators compromised.</p>

<p><strong>Optimistic bridges</strong> emerged inspired by optimistic rollup success. <strong>Nomad bridge</strong> (launched 2021) used fraud proof model - assumed transfers valid, allowed watchers challenge invalid transfers within time window. Single honest watcher sufficient for security. Tragically, implementation bug in Nomad August 2022 led to $190M loss when attacker exploited verification flaw, enabling anyone drain bridge completely. This demonstrated optimistic approach‚Äôs vulnerability - single bug catastrophic.</p>

<p><strong>Zero-knowledge bridges</strong> represent cutting edge, using zk-SNARKs verify source chain state cryptographically. <strong>zkBridge</strong> v√† similar projects prove transaction occurred on source chain via succinct proof verified on destination chain. No external validators needed - cryptography alone provides security. However, proving complex consensus mechanisms (like PoS v·ªõi slashing) through ZK circuits extremely challenging, limiting current applicability.</p>

<p>NƒÉm 2022 witnessed ‚Äúyear of bridge hacks‚Äù - Ronin ($625M), Wormhole ($325M), Nomad ($190M), Harmony ($100M). These disasters forced industry rethink bridge security fundamentally. Current trend toward <strong>reducing bridge surface area</strong> through alternative approaches: native multi-chain assets, shared sequencing across rollups, application-specific bridges v·ªõi limited functionality reducing attack surface.</p>

<hr />

<h2 id="2-intuitive-understanding">2. Intuitive Understanding</h2>

<p>ƒê·ªÉ comprehend bridge security challenges intuitively, imagine bridges nh∆∞ literal physical bridges connecting islands. Strong bridge supports heavy traffic safely. Weak bridge collapses under load, causing catastrophic damage. Blockchain bridges similar - they must support potentially billions of dollars value transfer while resisting sophisticated attacks t·ª´ adversaries v·ªõi huge economic incentives.</p>

<p>Consider custodial bridge model through bank analogy. Traditional bank vault holds valuable assets. Single entity controls vault, customers trust bank not steal ho·∫∑c lose assets. Custodial bridge identical - Bitcoin locked trong vault (multisig address), trusted entities control keys, users trust they won‚Äôt abscond v·ªõi funds. Security reduces entirely to physical security c·ªßa custodians v√† honesty c·ªßa entities involved. This centralization contradicts blockchain ethos but provides simplicity v√† efficiency.</p>

<p>Validator-based bridges analogous to committee approval system. Imagine international border crossing requiring approval t·ª´ committee of border guards. Transaction submitted, majority guards must verify v√† sign approval before allowing passage. Security depends on majority guards honest. If attackers bribe ho·∫∑c compromise enough guards, can approve fraudulent transactions. Blockchain bridges using validator sets face identical challenge - validators become high-value targets, v√† coordinator failure means total bridge compromise.</p>

<p>Light client bridges comparable to verification through official documents. When traveling internationally, present passport, border control verifies document authentic by checking security features, holograms, stamps. Light client similar - contract on destination chain verifies cryptographic proofs from source chain (block headers, merkle proofs, signatures). No trust in external parties needed - pure cryptographic verification. However, complexity high v√† verification costly (gas), limiting practicality.</p>

<p>Hash time-locked contracts (HTLCs) comparable to escrow v·ªõi time limits. Imagine two people exchanging houses directly without title company. Both deposit keys into locked boxes v·ªõi same secret combination. Boxes programmed: open v·ªõi secret OR automatically return keys after deadline. First person revealing secret claims counterparty‚Äôs house, enabling counterparty claim original house v·ªõi same secret. If either backs out, deadlines ensure both get refunds. No trust needed - mechanism design guarantees fairness.</p>

<p>Zero-knowledge bridge verification analogous to airport security. Instead of examining every item trong luggage individually, X-ray provides proof luggage safe without opening bags. ZK proofs provide cryptographic guarantee transaction occurred on source chain without replaying entire transaction history on destination chain. Verification succinct (constant time/space) regardless of what being proven, enabling efficient cross-chain verification.</p>

<hr />

<h2 id="3-technical-foundation">3. Technical Foundation</h2>

<p>Bridge architecture varies dramatically across implementations, but core components remain consistent across designs. Every bridge must solve fundamental problems: verify events on source chain, represent assets on destination chain, handle failures gracefully, prevent double-spending, v√† maintain economic security sufficient to deter attacks.</p>

<p>Custodial bridge architecture simplest conceptually but requires strongest trust assumptions. Architecture consists of custody layer (holds locked assets), minting layer (creates wrapped tokens), v√† governance layer (manages custodians). Bitcoin locked in multisig address controlled by custodians. When user deposits, custodian verifies Bitcoin transaction, coordinates with merchant, merchant mints WBTC on Ethereum. Withdrawal reverses process - user burns WBTC, custodian releases Bitcoin. Security entirely dependent on custodian honesty v√† key security.</p>

<pre><code class="language-solidity">contract CustodialBridge {
    address[] public custodians;
    uint256 public threshold;  // n-of-m multisig
    
    mapping(bytes32 =&gt; bool) public processedBTCTxs;
    mapping(address =&gt; uint256) public wrappedBalances;
    
    event Minted(address indexed to, uint256 amount, bytes32 btcTxHash);
    event Burned(address indexed from, uint256 amount, string btcAddress);
    
    /**
     * @dev Custodians mint wrapped tokens after verifying BTC deposit
     */
    function mint(
        address to,
        uint256 amount,
        bytes32 btcTxHash,
        bytes[] memory signatures
    ) external {
        require(!processedBTCTxs[btcTxHash], "Already processed");
        require(verifySignatures(signatures, btcTxHash, amount, to), "Invalid signatures");
        
        processedBTCTxs[btcTxHash] = true;
        wrappedBalances[to] += amount;
        
        emit Minted(to, amount, btcTxHash);
    }
    
    /**
     * @dev Users burn to withdraw
     */
    function burn(uint256 amount, string memory btcAddress) external {
        require(wrappedBalances[msg.sender] &gt;= amount, "Insufficient balance");
        
        wrappedBalances[msg.sender] -= amount;
        
        emit Burned(msg.sender, amount, btcAddress);
        // Custodians monitor event, release BTC to btcAddress
    }
    
    function verifySignatures(
        bytes[] memory signatures,
        bytes32 txHash,
        uint256 amount,
        address recipient
    ) internal view returns (bool) {
        bytes32 message = keccak256(abi.encodePacked(txHash, amount, recipient));
        
        uint256 validSigs = 0;
        for (uint i = 0; i &lt; signatures.length; i++) {
            address signer = recoverSigner(message, signatures[i]);
            if (isCustodian(signer)) {
                validSigs++;
            }
        }
        
        return validSigs &gt;= threshold;
    }
    
    function isCustodian(address addr) internal view returns (bool) {
        for (uint i = 0; i &lt; custodians.length; i++) {
            if (custodians[i] == addr) return true;
        }
        return false;
    }
    
    function recoverSigner(bytes32 message, bytes memory sig) internal pure returns (address) {
        bytes32 r; bytes32 s; uint8 v;
        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))
            v := byte(0, mload(add(sig, 96)))
        }
        return ecrecover(message, v, r, s);
    }
}
</code></pre>

<p>Validator network bridges introduce decentralization through distributed validation. Multiple independent validators run nodes on both chains, monitoring deposits on source chain v√† attesting to events. Threshold signatures ensure no single validator can approve transfers alone. Implementation pattern involves validator registration, stake deposits, rotation mechanisms, v√† slashing for misbehavior.</p>

<p>Light client bridges achieve trustlessness through cryptographic verification. Destination chain contract maintains source chain‚Äôs consensus state - block headers for PoW chains, validator sets for PoS chains. When claiming cross-chain transfer, user provides merkle proof transaction included trong specific block, contract verifies proof against stored header. No external trust required, but complexity v√† cost substantial.</p>

<pre><code class="language-solidity">contract LightClientBridge {
    struct BlockHeader {
        bytes32 blockHash;
        bytes32 parentHash;
        bytes32 merkleRoot;
        uint256 timestamp;
        uint256 difficulty;  // For PoW verification
        uint256 number;
    }
    
    mapping(bytes32 =&gt; BlockHeader) public headers;
    bytes32 public latestHeader;
    
    /**
     * @dev Submit Bitcoin block header
     */
    function submitHeader(
        bytes memory headerBytes,
        uint256 chainWork
    ) external {
        BlockHeader memory header = parseHeader(headerBytes);
        
        // Verify PoW
        require(verifyPoW(header), "Invalid PoW");
        
        // Verify connects to known chain
        require(headers[header.parentHash].blockHash != bytes32(0), "Parent unknown");
        
        // Store header
        headers[header.blockHash] = header;
        
        // Update latest if more work
        if (chainWork &gt; getChainWork(latestHeader)) {
            latestHeader = header.blockHash;
        }
    }
    
    /**
     * @dev Verify transaction inclusion
     */
    function verifyTransaction(
        bytes32 blockHash,
        bytes memory transaction,
        bytes32[] memory proof,
        uint256 index
    ) public view returns (bool) {
        BlockHeader memory header = headers[blockHash];
        require(header.blockHash != bytes32(0), "Header not found");
        
        // Verify merkle proof
        bytes32 txHash = sha256(abi.encodePacked(sha256(transaction)));
        bytes32 computedRoot = computeMerkleRoot(txHash, proof, index);
        
        return computedRoot == header.merkleRoot;
    }
    
    function verifyPoW(BlockHeader memory header) internal pure returns (bool) {
        bytes32 hash = keccak256(abi.encodePacked(
            header.parentHash,
            header.merkleRoot,
            header.timestamp,
            header.difficulty
        ));
        
        return uint256(hash) &lt; getTarget(header.difficulty);
    }
    
    function parseHeader(bytes memory data) internal pure returns (BlockHeader memory) {
        // Parse Bitcoin header format (80 bytes)
        // Simplified implementation
        return BlockHeader({
            blockHash: bytes32(0),
            parentHash: bytes32(0),
            merkleRoot: bytes32(0),
            timestamp: 0,
            difficulty: 0,
            number: 0
        });
    }
    
    function computeMerkleRoot(
        bytes32 leaf,
        bytes32[] memory proof,
        uint256 index
    ) internal pure returns (bytes32) {
        bytes32 hash = leaf;
        
        for (uint i = 0; i &lt; proof.length; i++) {
            if (index % 2 == 0) {
                hash = sha256(abi.encodePacked(hash, proof[i]));
            } else {
                hash = sha256(abi.encodePacked(proof[i], hash));
            }
            index = index / 2;
        }
        
        return hash;
    }
    
    function getTarget(uint256 difficulty) internal pure returns (uint256) {
        return type(uint256).max / difficulty;
    }
    
    function getChainWork(bytes32 headerHash) internal view returns (uint256) {
        // Sum of all difficulties in chain
        // Simplified
        return 0;
    }
}
</code></pre>

<p>Optimistic bridge pattern mirrors optimistic rollup approach. Transfers assumed valid initially, watchers can submit fraud proofs if detect invalidity. Implementation maintains transfer queue on destination chain, each transfer enters challenge period before finalization. Watchers monitor source chain continuously, comparing against submitted transfers. If mismatch detected, watcher submits fraud proof demonstrating invalidity, causing transfer rejection v√† slashing c·ªßa proposer.</p>

<hr />

<h2 id="4-mathematical--cryptographic-formulation">4. Mathematical / Cryptographic Formulation</h2>

<p>Bridge security analysis requires modeling trust assumptions formally. For validator-based bridge v·ªõi (n) validators requiring (t) signatures (t-of-n multisig), security holds if at most (t-1) validators compromised:</p>

<p>[
\text{Secure} \iff |V_{\text{malicious}}| &lt; t
]</p>

<p>Probability c·ªßa compromise given each validator independently compromised v·ªõi probability (p):</p>

<p>[
P(\text{bridge compromised}) = \sum_{k=t}^{n} \binom{n}{k} p^k (1-p)^{n-k}
]</p>

<p>Example calculation: 9 validators, 5-of-9 multisig, 10% individual compromise probability:</p>

<p>[
P(\text{compromise}) = \sum_{k=5}^{9} \binom{9}{k} (0.1)^k (0.9)^{9-k} \approx 0.00074 = 0.074\%
]</p>

<p>Reasonably secure, but not negligible. V·ªõi higher individual risk (20%), total risk increases dramatically:</p>

<p>[
P(\text{compromise at } p=0.2) \approx 0.086 = 8.6\%
]</p>

<p>Unacceptably high for billion-dollar bridge!</p>

<p>Light client verification gas cost analysis critical. For Bitcoin SPV proof verification on Ethereum:</p>

<p>Storage cost storing block header:
[
C_{\text{storage}} = 80 \text{ bytes} \times 20,000 \text{ gas/byte} = 1,600,000 \text{ gas}
]</p>

<p>At 50 gwei v√† $2000/ETH:
[
\text{Cost} = 1.6M \times 50 \times 10^{-9} \times 2000 = $160 \text{ per header}
]</p>

<p>Prohibitively expensive to store every header! Solutions:</p>
<ul>
  <li>Store checkpoints only (every 2016 blocks)</li>
  <li>Store recent headers (sliding window)</li>
  <li>On-demand verification (submit headers when needed)</li>
</ul>

<p>Merkle proof verification cost:</p>

<p>[
C_{\text{verify}} = \log_2(n) \times C_{\text{hash}}
]</p>

<p>For block v·ªõi 2000 transactions:
[
C_{\text{verify}} = \log_2(2000) \times 30 \approx 11 \times 30 = 330 \text{ gas}
]</p>

<p>Quite cheap! Most cost in storing headers, not verifying proofs.</p>

<p>Economic security c·ªßa validator bridge calculated through attack profitability analysis:</p>

<p>[
\text{Attack profitable} \iff V_{\text{stolen}} &gt; \sum_{i=1}^{t} S_i + C_{\text{coordination}}
]</p>

<p>Where:</p>
<ul>
  <li>(V_{\text{stolen}}) = value attacker can steal</li>
  <li>(S_i) = stake c·ªßa validator (i)</li>
  <li>(C_{\text{coordination}}) = cost coordinating attack</li>
</ul>

<p>For Ronin attack:
[
625M &gt; 5 \times $0 + \text{minimal coordination cost}
]</p>

<p>Attack highly profitable! Validators had insufficient stake at risk.</p>

<p>Proper economic security requires:
[
\sum_{i=1}^{t} S_i &gt; \alpha \times TVL_{\text{bridge}}
]</p>

<p>Where (\alpha \geq 1) (stake should exceed bridge value).</p>

<hr />

<h2 id="5-implementation-insight">5. Implementation Insight</h2>

<p>Complete bridge implementation demonstrates full cycle t·ª´ deposit to withdrawal v·ªõi security checks comprehensive:</p>

<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title Secure Bridge Implementation
 * @dev Multi-validator bridge with economic security
 */
contract SecureBridge {
    // Validator management
    struct Validator {
        address addr;
        uint256 stake;
        bool active;
    }
    
    Validator[] public validators;
    mapping(address =&gt; uint256) public validatorIndex;
    uint256 public constant MIN_VALIDATORS = 7;
    uint256 public threshold;  // e.g., 5-of-7
    
    // Transfer tracking
    struct Transfer {
        bytes32 sourceChainTxHash;
        address recipient;
        uint256 amount;
        uint256 timestamp;
        bytes32[] signatures;
        bool processed;
        bool challenged;
    }
    
    mapping(bytes32 =&gt; Transfer) public transfers;
    
    // Security parameters
    uint256 public constant CHALLENGE_PERIOD = 24 hours;
    uint256 public constant MIN_VALIDATOR_STAKE = 100 ether;
    
    // Events
    event ValidatorAdded(address indexed validator, uint256 stake);
    event TransferInitiated(bytes32 indexed transferId, address recipient, uint256 amount);
    event TransferFinalized(bytes32 indexed transferId);
    event TransferChallenged(bytes32 indexed transferId, address challenger);
    event ValidatorSlashed(address indexed validator, uint256 amount);
    
    modifier onlyValidator() {
        require(validators[validatorIndex[msg.sender]].active, "Not active validator");
        _;
    }
    
    /**
     * @dev Register as validator
     */
    function registerValidator() external payable {
        require(msg.value &gt;= MIN_VALIDATOR_STAKE, "Insufficient stake");
        require(validatorIndex[msg.sender] == 0, "Already validator");
        
        validators.push(Validator({
            addr: msg.sender,
            stake: msg.value,
            active: true
        }));
        
        validatorIndex[msg.sender] = validators.length - 1;
        
        emit ValidatorAdded(msg.sender, msg.value);
    }
    
    /**
     * @dev Submit transfer from source chain
     */
    function submitTransfer(
        bytes32 sourceChainTxHash,
        address recipient,
        uint256 amount,
        bytes[] memory validatorSignatures
    ) external onlyValidator {
        bytes32 transferId = keccak256(abi.encodePacked(
            sourceChainTxHash,
            recipient,
            amount
        ));
        
        require(!transfers[transferId].processed, "Already processed");
        
        // Verify validator signatures
        require(
            verifyValidatorSignatures(transferId, validatorSignatures),
            "Insufficient signatures"
        );
        
        // Create transfer record
        Transfer storage transfer = transfers[transferId];
        transfer.sourceChainTxHash = sourceChainTxHash;
        transfer.recipient = recipient;
        transfer.amount = amount;
        transfer.timestamp = block.timestamp;
        transfer.processed = false;
        
        emit TransferInitiated(transferId, recipient, amount);
    }
    
    /**
     * @dev Finalize transfer after challenge period
     */
    function finalizeTransfer(bytes32 transferId) external {
        Transfer storage transfer = transfers[transferId];
        
        require(!transfer.processed, "Already processed");
        require(!transfer.challenged, "Transfer challenged");
        require(
            block.timestamp &gt;= transfer.timestamp + CHALLENGE_PERIOD,
            "Challenge period active"
        );
        
        // Mark processed
        transfer.processed = true;
        
        // Transfer funds
        payable(transfer.recipient).transfer(transfer.amount);
        
        emit TransferFinalized(transferId);
    }
    
    /**
     * @dev Challenge fraudulent transfer
     */
    function challengeTransfer(
        bytes32 transferId,
        bytes memory fraudProof
    ) external {
        Transfer storage transfer = transfers[transferId];
        
        require(!transfer.processed, "Already processed");
        require(
            block.timestamp &lt; transfer.timestamp + CHALLENGE_PERIOD,
            "Challenge period expired"
        );
        
        // Verify fraud proof (would check source chain via light client)
        bool isFraud = verifyFraudProof(
            transfer.sourceChainTxHash,
            transfer.amount,
            fraudProof
        );
        
        if (isFraud) {
            transfer.challenged = true;
            
            // Slash validators who signed
            slashMaliciousValidators(transferId);
            
            emit TransferChallenged(transferId, msg.sender);
        }
    }
    
    /**
     * @dev Verify validator signatures meet threshold
     */
    function verifyValidatorSignatures(
        bytes32 transferId,
        bytes[] memory signatures
    ) internal view returns (bool) {
        require(signatures.length &gt;= threshold, "Below threshold");
        
        uint256 validCount = 0;
        mapping(address =&gt; bool) memory seen;
        
        for (uint i = 0; i &lt; signatures.length; i++) {
            address signer = recoverSigner(transferId, signatures[i]);
            
            if (validators[validatorIndex[signer]].active &amp;&amp; !seen[signer]) {
                validCount++;
                seen[signer] = true;
            }
        }
        
        return validCount &gt;= threshold;
    }
    
    function verifyFraudProof(
        bytes32 txHash,
        uint256 amount,
        bytes memory proof
    ) internal view returns (bool) {
        // In production: Verify transaction on source chain
        // via light client or oracle
        return false;  // Simplified
    }
    
    function slashMaliciousValidators(bytes32 transferId) internal {
        // Identify and slash validators who signed fraudulent transfer
        // Burn their stake
    }
    
    function recoverSigner(bytes32 hash, bytes memory sig) internal pure returns (address) {
        bytes32 r; bytes32 s; uint8 v;
        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))
            v := byte(0, mload(add(sig, 96)))
        }
        return ecrecover(hash, v, r, s);
    }
}
</code></pre>

<hr />

<h2 id="6-common-challenges--attacks--trade-offs">6. Common Challenges / Attacks / Trade-offs</h2>

<p>Bridge hacks showcase vulnerabilities recurring across implementations. <strong>Ronin bridge</strong> demonstrated validator key compromise risk. Attack involved social engineering v√† infrastructure penetration, compromising five of nine validator private keys. Once threshold achieved, attackers minted arbitrary amounts, draining bridge completely. Lesson: validator security paramount, geographic distribution essential, hardware security modules (HSMs) necessary for production bridges.</p>

<p><strong>Wormhole vulnerability</strong> exposed smart contract verification bypass. Code intended verify all guardian signatures actually skipped verification under certain conditions. Attacker exploited n√†y to mint wrapped tokens without locking source assets. Bug subtle - verification logic assumed earlier checks sufficient, but edge case allowed bypass. Demonstrates importance c·ªßa comprehensive testing, formal verification, v√† security audits. Single logic error in critical path catastrophic.</p>

<p>Validator collusion game theory reveals attack economics. For bridge v·ªõi total value locked (V) v√† validator stake (S), attack profitable if:</p>

<p>[
V_{\text{steal}} &gt; S_{\text{lost}} + C_{\text{coordination}} + R_{\text{reputation}}
]</p>

<p>If (V \gg S), attack tempting! This drove design principle: validator stake must exceed bridge TVL (overcollateralization). However, capital efficiency suffers - locking $2B in stake to secure $1B bridge economically wasteful. Trade-off between security v√† capital efficiency fundamental.</p>

<hr />

<h2 id="7-related-concepts">7. Related Concepts</h2>

<p>Bridges connect closely to <strong>wrapped asset</strong> standards. Wrapped BTC represents Bitcoin on Ethereum, WETH represents ETH in ERC-20 format, enabling trading on Uniswap. Each wrapped asset requires trust model - WBTC custodial, renBTC federated, tBTC optimistic. Understanding wrapping mechanisms essential for evaluating bridge security.</p>

<p><strong>Cross-chain messaging protocols</strong> extend beyond simple asset transfers. LayerZero, Axelar, Wormhole enable arbitrary message passing - contract calls, state reads, governance coordination. This unlocks <strong>omnichain applications</strong> where single application spans multiple chains, with unified state v√† logic.</p>

<hr />

<h2 id="8--fundamental-papers--whitepapers">8. ‚≠ê Fundamental Papers / Whitepapers</h2>

<table>
  <thead>
    <tr>
      <th>Paper</th>
      <th>Year</th>
      <th>Author(s)</th>
      <th>Contribution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>‚ÄúWBTC: Wrapped Bitcoin‚Äù</strong></td>
      <td>2019</td>
      <td>BitGo, Kyber, Ren</td>
      <td>Custodial bridge model</td>
    </tr>
    <tr>
      <td><strong>‚ÄúRenVM: An Open Protocol for Decentralized Interoperability‚Äù</strong></td>
      <td>2020</td>
      <td>Ren Project</td>
      <td>Distributed custody via MPC</td>
    </tr>
    <tr>
      <td><strong>‚ÄúPolkadot: Parachain Bridges‚Äù</strong></td>
      <td>2020</td>
      <td>Web3 Foundation</td>
      <td>Shared security bridge model</td>
    </tr>
    <tr>
      <td><strong>‚ÄúCosmos IBC: Bridge Modules‚Äù</strong></td>
      <td>2020</td>
      <td>Cosmos</td>
      <td>IBC bridge specifications</td>
    </tr>
    <tr>
      <td><strong>‚ÄúWormhole: Generic Message Passing‚Äù</strong></td>
      <td>2021</td>
      <td>Certus One</td>
      <td>Guardian network design</td>
    </tr>
    <tr>
      <td><strong>‚ÄúLayerZero: Ultra Light Nodes‚Äù</strong></td>
      <td>2021</td>
      <td>LayerZero Labs</td>
      <td>Efficient cross-chain verification</td>
    </tr>
    <tr>
      <td><strong>‚ÄúzkBridge: Zero-Knowledge State Bridge‚Äù</strong></td>
      <td>2022</td>
      <td>UC Berkeley</td>
      <td>ZK-proof based bridges</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="9--illustrations--visual-references">9. üé® Illustrations &amp; Visual References</h2>

<p><img src="https://l2beat.com/images/bridge-comparison.png" alt="Bridge Types Comparison" /><br />
<em>Source: <a href="https://l2beat.com/bridges">L2Beat Bridge Analysis</a></em></p>

<p><img src="https://bridge.roninchain.com/assets/architecture.png" alt="Ronin Bridge Architecture" /><br />
<em>Source: <a href="https://bridge.roninchain.com/">Ronin Bridge Documentation</a></em></p>

<hr />

<h2 id="10-summary">10. Summary</h2>

<p>Blockchain bridges enable interoperability essential cho connected blockchain ecosystem, but introduce security challenges requiring careful analysis. Various bridge architectures trade off trust assumptions, security guarantees, cost, v√† complexity differently. Understanding these trade-offs critical for both users evaluating bridge safety v√† developers building cross-chain applications.</p>

<hr />

<p>‚úÖ <strong>End of Lecture</strong></p>

<p>Next: Lecture 06.02 - Polkadot &amp; Cosmos: Purpose-Built Interoperability</p>

<hr />

<h2 id="references">References</h2>

<ol>
  <li>BitGo, Kyber, Ren. (2019). <em>WBTC: Wrapped Bitcoin Whitepaper</em>.</li>
  <li>Ren Project. (2020). <em>RenVM: An Open Protocol for Decentralized Interoperability</em>.</li>
  <li>LayerZero Labs. (2021). <em>LayerZero: Trustless Omnichain Interoperability Protocol</em>.</li>
  <li>L2Beat Team. (2024). <em>Bridge Risk Framework</em>. https://l2beat.com/bridges</li>
</ol>


</div>

<!-- Back to Chapter Home Link -->

  
  
  <div style="margin-top: 20px; padding: 10px; background-color: #f8f9fa; border-left: 4px solid #007bff;">
    <a href="/deep-learning-self-learning/contents/vi/chapter06/" style="text-decoration: none; color: #007bff; font-weight: bold;">
      ‚Üê Quay l·∫°i ƒë·∫ßu ch∆∞∆°ng
    </a>
  </div>













<div class="related">
  <ul class="related-posts">
    
      
        <li>
          <h2>Previous Post</h2>
          <h3>
            <a href="/deep-learning-self-learning/contents/vi/chapter06/blockchain-chapter06/06_00_Cross_Chain_Communication/">
              Lecture 06.00: Cross-Chain Communication - K·∫øt n·ªëi c√°c Blockchain
            </a>
          </h3>
        </li>
      
    
      
    
      
    
    
    
  
    
  
    
      <li>
        <h2>Next Post</h2>
        <h3>
          <a href="/deep-learning-self-learning/contents/vi/chapter06/blockchain-chapter06/06_02_Polkadot_Cosmos/">
            Lecture 06.02: Polkadot & Cosmos - Purpose-Built Interoperability Platforms
          </a>
        </h3>
      </li>
    
  
  </ul>
</div>



<script src="https://utteranc.es/client.js"
        repo="convex-deep-learning-for-all/convex-deep-learning-for-all.github.io"
        issue-term="title"
        label="Comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src='/deep-learning-self-learning/public/js/script.js'></script>
    <script src='/deep-learning-self-learning/public/js/multilang.js'></script>
    <script src='/deep-learning-self-learning/public/js/search.js'></script>
  </body>
</html>

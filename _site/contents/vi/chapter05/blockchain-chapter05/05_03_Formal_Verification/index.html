<!DOCTYPE html>
<html lang="vi">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <style>
    .MathJax {
      padding: 2em 0.3em;
      overflow-x: auto;
      overflow-y: hidden;
    }
  </style>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

  <title>
    
      Lecture 05.03: Formal Verification - Proving Smart Contract Correctness &middot; Blockchain
    
  </title>

  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/poole.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/syntax.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/lanyon.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/github-markdown.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/multilang.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/search.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/content-boxes.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap">
  
  <!-- Lunr.js for search functionality -->
  <script src="https://unpkg.com/lunr/lunr.js"></script>

  <link rel="apple-touch-icon-precomposed" sizes="122x144" href="http://0.0.0.0:4000/deep-learning-self-learning/public/logo.png">
  <link rel="shortcut icon" href="http://0.0.0.0:4000/deep-learning-self-learning/public/convex-logo-144x144.png">

  <link rel="alternate" type="application/rss+xml" title="RSS" href="http://0.0.0.0:4000/deep-learning-self-learning/atom.xml">

  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', '', 'auto');
    ga('send', 'pageview');
  </script>
  
</head>


  <body class="sidebar-overlay">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>Blockchain</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/">Trang ch·ªß</a>

    

    
    
    
    <!-- Hi·ªÉn th·ªã c√°c ch∆∞∆°ng c√≥ s·∫µn cho ng√¥n ng·ªØ hi·ªán t·∫°i -->
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter00/">
              00. Chapter 00: N·ªÅn T·∫£ng Blockchain
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter01/">
              01. Chapter 01: Bitcoin - Architecture v√† Proof-of-Work
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter02/">
              02. Chapter 02: Advanced Consensus Mechanisms
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter03/">
              03. Chapter 03: Ethereum v√† Smart Contracts
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter04/">
              04. Chapter 04: Blockchain Scalability v√† Layer-2 Solutions
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter05/">
              05. Chapter 05: Privacy v√† Security trong Blockchain
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter06/">
              06. Chapter 06: Blockchain Interoperability
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter07/">
              07. Chapter 07: Advanced Blockchain Topics
              
            </a>
          
        
      
    
    
    <!-- N·∫øu kh√¥ng c√≥ n·ªôi dung cho ng√¥n ng·ªØ hi·ªán t·∫°i, hi·ªÉn th·ªã th√¥ng b√°o -->
    
    
    <span class="sidebar-nav-item">Currently v0.0.1</span>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2025. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap github-md-body">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/deep-learning-self-learning/" title="Trang ch·ªß">Blockchain</a>
            <small></small>
          </h3>
          <!-- Header Actions: Language Toggle and GitHub Link -->
          <div class="header-actions">
            <div class="language-toggle">
              <a href="/deep-learning-self-learning/contents/en/chapter00/" class="language-switch" title="Chuy·ªÉn sang ti·∫øng Anh">Chuy·ªÉn sang ti·∫øng Anh</a>
            </div>
            <a class="github-logo__wrapper" target="_blank" href="https://github.com/nglelinh/deep-learning-self-learning" title="Github">
             <svg class="github-logo" xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 48 48"><linearGradient id="rL2wppHyxHVbobwndsT6Ca" x1="4" x2="44" y1="23.508" y2="23.508" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#4c4c4c"/><stop offset="1" stop-color="#343434"/></linearGradient><path fill="url(#rL2wppHyxHVbobwndsT6Ca)" d="M24,4C12.954,4,4,12.954,4,24c0,8.887,5.801,16.411,13.82,19.016h12.36	C38.199,40.411,44,32.887,44,24C44,12.954,35.046,4,24,4z"/><path d="M30.01,41.996L30,36.198c0-0.939-0.22-1.856-0.642-2.687c5.641-1.133,8.386-4.468,8.386-10.177	c0-2.255-0.665-4.246-1.976-5.92c0.1-0.317,0.174-0.645,0.22-0.981c0.188-1.369-0.023-2.264-0.193-2.984l-0.027-0.116	c-0.186-0.796-0.409-1.364-0.418-1.388l-0.111-0.282l-0.111-0.282l-0.302-0.032l-0.303-0.032c0,0-0.199-0.021-0.501-0.021	c-0.419,0-1.04,0.042-1.627,0.241l-0.196,0.066c-0.74,0.249-1.439,0.485-2.417,1.069c-0.286,0.171-0.599,0.366-0.934,0.584	C27.334,12.881,25.705,12.69,24,12.69c-1.722,0-3.365,0.192-4.889,0.571c-0.339-0.22-0.654-0.417-0.942-0.589	c-0.978-0.584-1.677-0.819-2.417-1.069l-0.196-0.066c-0.585-0.199-1.207-0.241-1.626-0.241c-0.302,0-0.501,0.021-0.501,0.021	l-0.302,0.032l-0.3,0.031l-0.112,0.281l-0.113,0.283c-0.01,0.026-0.233,0.594-0.419,1.391l-0.027,0.115	c-0.17,0.719-0.381,1.615-0.193,2.983c0.048,0.346,0.125,0.685,0.23,1.011c-1.285,1.666-1.936,3.646-1.936,5.89	c0,5.695,2.748,9.028,8.397,10.17c-0.194,0.388-0.345,0.798-0.452,1.224c-0.197,0.067-0.378,0.112-0.538,0.137	c-0.238,0.036-0.487,0.054-0.739,0.054c-0.686,0-1.225-0.134-1.435-0.259c-0.313-0.186-0.872-0.727-1.414-1.518	c-0.463-0.675-1.185-1.558-1.992-1.927c-0.698-0.319-1.437-0.502-2.029-0.502c-0.138,0-0.265,0.01-0.376,0.028	c-0.517,0.082-0.949,0.366-1.184,0.78c-0.203,0.357-0.235,0.773-0.088,1.141c0.219,0.548,0.851,0.985,1.343,1.255	c0.242,0.133,0.765,0.619,1.07,1.109c0.229,0.368,0.335,0.63,0.482,0.992c0.087,0.215,0.183,0.449,0.313,0.732	c0.47,1.022,1.937,1.924,2.103,2.023c0.806,0.483,2.161,0.638,3.157,0.683l0.123,0.003c0,0,0.001,0,0.001,0	c0.24,0,0.57-0.023,1.004-0.071v2.613c0.002,0.529-0.537,0.649-1.25,0.638l0.547,0.184C19.395,43.572,21.645,44,24,44	c2.355,0,4.605-0.428,6.703-1.176l0.703-0.262C30.695,42.538,30.016,42.422,30.01,41.996z" opacity=".05"/><path d="M30.781,42.797c-0.406,0.047-1.281-0.109-1.281-0.795v-5.804c0-1.094-0.328-2.151-0.936-3.052	c5.915-0.957,8.679-4.093,8.679-9.812c0-2.237-0.686-4.194-2.039-5.822c0.137-0.365,0.233-0.75,0.288-1.147	c0.175-1.276-0.016-2.086-0.184-2.801l-0.027-0.116c-0.178-0.761-0.388-1.297-0.397-1.319l-0.111-0.282l-0.303-0.032	c0,0-0.178-0.019-0.449-0.019c-0.381,0-0.944,0.037-1.466,0.215l-0.196,0.066c-0.714,0.241-1.389,0.468-2.321,1.024	c-0.332,0.198-0.702,0.431-1.101,0.694C27.404,13.394,25.745,13.19,24,13.19c-1.762,0-3.435,0.205-4.979,0.61	c-0.403-0.265-0.775-0.499-1.109-0.699c-0.932-0.556-1.607-0.784-2.321-1.024l-0.196-0.066c-0.521-0.177-1.085-0.215-1.466-0.215	c-0.271,0-0.449,0.019-0.449,0.019l-0.302,0.032l-0.113,0.283c-0.009,0.022-0.219,0.558-0.397,1.319l-0.027,0.116	c-0.169,0.715-0.36,1.524-0.184,2.8c0.056,0.407,0.156,0.801,0.298,1.174c-1.327,1.62-1.999,3.567-1.999,5.795	c0,5.703,2.766,8.838,8.686,9.806c-0.395,0.59-0.671,1.255-0.813,1.964c-0.33,0.13-0.629,0.216-0.891,0.256	c-0.263,0.04-0.537,0.06-0.814,0.06c-0.69,0-1.353-0.129-1.69-0.329c-0.44-0.261-1.057-0.914-1.572-1.665	c-0.35-0.51-1.047-1.417-1.788-1.755c-0.635-0.29-1.298-0.457-1.821-0.457c-0.11,0-0.21,0.008-0.298,0.022	c-0.366,0.058-0.668,0.252-0.828,0.534c-0.128,0.224-0.149,0.483-0.059,0.708c0.179,0.448,0.842,0.85,1.119,1.002	c0.335,0.184,0.919,0.744,1.254,1.284c0.251,0.404,0.37,0.697,0.521,1.067c0.085,0.209,0.178,0.437,0.304,0.712	c0.331,0.719,1.353,1.472,1.905,1.803c0.754,0.452,2.154,0.578,2.922,0.612l0.111,0.002c0.299,0,0.8-0.045,1.495-0.135v3.177	c0,0.779-0.991,0.81-1.234,0.81c-0.031,0,0.503,0.184,0.503,0.184C19.731,43.64,21.822,44,24,44c2.178,0,4.269-0.36,6.231-1.003	C30.231,42.997,30.812,42.793,30.781,42.797z" opacity=".07"/><path fill="#fff" d="M36.744,23.334c0-2.31-0.782-4.226-2.117-5.728c0.145-0.325,0.296-0.761,0.371-1.309	c0.172-1.25-0.031-2-0.203-2.734s-0.375-1.25-0.375-1.25s-0.922-0.094-1.703,0.172s-1.453,0.469-2.422,1.047	c-0.453,0.27-0.909,0.566-1.27,0.806C27.482,13.91,25.785,13.69,24,13.69c-1.801,0-3.513,0.221-5.067,0.652	c-0.362-0.241-0.821-0.539-1.277-0.811c-0.969-0.578-1.641-0.781-2.422-1.047s-1.703-0.172-1.703-0.172s-0.203,0.516-0.375,1.25	s-0.375,1.484-0.203,2.734c0.077,0.562,0.233,1.006,0.382,1.333c-1.31,1.493-2.078,3.397-2.078,5.704	c0,5.983,3.232,8.714,9.121,9.435c-0.687,0.726-1.148,1.656-1.303,2.691c-0.387,0.17-0.833,0.33-1.262,0.394	c-1.104,0.167-2.271,0-2.833-0.333s-1.229-1.083-1.729-1.813c-0.422-0.616-1.031-1.331-1.583-1.583	c-0.729-0.333-1.438-0.458-1.833-0.396c-0.396,0.063-0.583,0.354-0.5,0.563c0.083,0.208,0.479,0.521,0.896,0.75	c0.417,0.229,1.063,0.854,1.438,1.458c0.418,0.674,0.5,1.063,0.854,1.833c0.249,0.542,1.101,1.219,1.708,1.583	c0.521,0.313,1.562,0.491,2.688,0.542c0.389,0.018,1.308-0.096,2.083-0.206v3.75c0,0.639-0.585,1.125-1.191,1.013	C19.756,43.668,21.833,44,24,44c2.166,0,4.243-0.332,6.19-0.984C29.585,43.127,29,42.641,29,42.002v-5.804	c0-1.329-0.527-2.53-1.373-3.425C33.473,32.071,36.744,29.405,36.744,23.334z M11.239,32.727c-0.154-0.079-0.237-0.225-0.185-0.328	c0.052-0.103,0.22-0.122,0.374-0.043c0.154,0.079,0.237,0.225,0.185,0.328S11.393,32.806,11.239,32.727z M12.451,33.482	c-0.081,0.088-0.255,0.06-0.389-0.062s-0.177-0.293-0.096-0.381c0.081-0.088,0.255-0.06,0.389,0.062S12.532,33.394,12.451,33.482z M13.205,34.732c-0.102,0.072-0.275,0.005-0.386-0.15s-0.118-0.34-0.016-0.412s0.275-0.005,0.386,0.15	C13.299,34.475,13.307,34.66,13.205,34.732z M14.288,35.673c-0.069,0.112-0.265,0.117-0.437,0.012s-0.256-0.281-0.187-0.393	c0.069-0.112,0.265-0.117,0.437-0.012S14.357,35.561,14.288,35.673z M15.312,36.594c-0.213-0.026-0.371-0.159-0.353-0.297	c0.017-0.138,0.204-0.228,0.416-0.202c0.213,0.026,0.371,0.159,0.353,0.297C15.711,36.529,15.525,36.62,15.312,36.594z M16.963,36.833c-0.227-0.013-0.404-0.143-0.395-0.289c0.009-0.146,0.2-0.255,0.427-0.242c0.227,0.013,0.404,0.143,0.395,0.289	C17.381,36.738,17.19,36.846,16.963,36.833z M18.521,36.677c-0.242,0-0.438-0.126-0.438-0.281s0.196-0.281,0.438-0.281	c0.242,0,0.438,0.126,0.438,0.281S18.762,36.677,18.521,36.677z"/></svg>
            </a>
          </div>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">
    Lecture 05.03: Formal Verification - Proving Smart Contract Correctness
    
  </h1>
  <h1 id="lecture-formal-verification---proving-smart-contract-correctness-mathematically">Lecture: Formal Verification - Proving Smart Contract Correctness Mathematically</h1>

<h2 id="1-concept-overview">1. Concept Overview</h2>

<p>Formal verification represents rigorous mathematical approach to ensuring software correctness, particularly critical for smart contracts where bugs lead to irreversible financial losses. Unlike traditional testing verifying program works correctly for specific inputs, formal verification proves program behaves correctly for ALL possible inputs mathematically. This distinction crucial trong blockchain context - smart contracts control billions of dollars, deployed immutably, facing adversaries v·ªõi huge economic incentives to find v√† exploit vulnerabilities.</p>

<p>Traditional software development relies primarily on testing - running programs v·ªõi various inputs, checking outputs match expectations. Testing discovers bugs but cannot prove absence c·ªßa bugs. Famous computer scientist <strong>Edsger Dijkstra</strong> stated: ‚ÄúProgram testing can be used to show presence of bugs, but never to show their absence.‚Äù For typical applications, this acceptable - bugs fixed through patches, damage limited. Smart contracts different fundamentally - cannot be patched post-deployment, bugs exploitable permanently, v√† financial stakes enormous.</p>

<p>Formal verification emerged from academic computer science, tracing back to <strong>Tony Hoare‚Äôs</strong> work on program correctness trong 1960s-1970s. Hoare introduced <strong>axiomatic semantics</strong> v√† <strong>Hoare logic</strong> - mathematical framework for reasoning about programs. Given precondition (P), program (S), v√† postcondition (Q), Hoare triple ({P} S {Q}) states: if (P) holds before executing (S), then (Q) holds afterward. Proving program correct reduces to proving all relevant Hoare triples valid.</p>

<p>Applying formal verification to smart contracts gained urgency after The DAO hack nƒÉm 2016. <strong>$50 million stolen</strong> through reentrancy vulnerability demonstrated testing insufficient for high-stakes smart contracts. Research community responded with tools v√† techniques specifically targeting smart contract verification. <strong>Runtime Verification</strong> created <strong>K Framework</strong> enabling formal semantics for EVM. <strong>Certora</strong> developed <strong>Certora Prover</strong> for Solidity verification. <strong>Trail of Bits</strong> built <strong>Manticore</strong> for symbolic execution. Academic projects like <strong>Why3</strong>, <strong>Isabelle/HOL</strong>, v√† <strong>Coq</strong> applied to blockchain.</p>

<p>Different verification approaches offer varying guarantees v√† trade-offs. <strong>Model checking</strong> exhaustively explores state space, practical ch·ªâ cho small contracts. <strong>Theorem proving</strong> requires manual proof construction, providing strongest guarantees nh∆∞ng demanding expertise substantial. <strong>Symbolic execution</strong> analyzes paths through code symbolically, finding violations of specified properties. <strong>Runtime verification</strong> monitors execution, detecting violations dynamically. Each technique appropriate for different verification goals v√† resource constraints.</p>

<p>Standards emerging around verified smart contracts. <strong>ERC-20 token security</strong> became focus - formal specifications define expected behaviors (transfer preserves total supply, approve kh√¥ng affect balances, etc.). Tools verify implementations match specifications automatically. <strong>DeFi protocols</strong> increasingly undergo formal verification before launch - Aave, Compound, MakerDAO all utilized formal methods to varying degrees. Insurance protocols like <strong>Nexus Mutual</strong> offer coverage but require audits including formal verification for premium rates best.</p>

<p>Integration into development workflow remains challenge. Formal verification requires specifications written precisely, properties stated formally, v√† verification toolchains complex. Developer education insufficient - most blockchain developers lack formal methods background. Cost-benefit analysis difficult - verification expensive (weeks to months), benefits hard quantify until breach occurs. Despite challenges, high-value protocols increasingly view formal verification nh∆∞ necessary investment rather than optional luxury.</p>

<hr />

<h2 id="2-intuitive-understanding">2. Intuitive Understanding</h2>

<p>ƒê·ªÉ comprehend formal verification intuitively, contrast v·ªõi traditional testing through concrete example. Imagine function adding two numbers. Testing approach: try various inputs (1+2=3, 10+5=15, 100+200=300), verify outputs correct. After 1000 tests passing, reasonable confidence function works. However, cannot test all possible inputs - v·ªõi 256-bit integers, c√≥ (2^{512}) possible input pairs, far more than atoms trong universe. Hidden bug could lurk trong untested combination.</p>

<p>Formal verification proves function correct for ALL inputs mathematically. Specification states: ‚ÄúFunction returns sum c·ªßa inputs.‚Äù Proof demonstrates: given any inputs (a) v√† (b), function returns (a+b). No testing required - mathematical proof covers infinite input space completely. For simple addition, proof trivial. For complex smart contracts v·ªõi intricate state machines, proofs challenging but provide certainty unattainable through testing alone.</p>

<p>Consider smart contract managing token balances v·ªõi transfer function. Testing verifies transfers work correctly for sample scenarios - Alice transfers 10 tokens to Bob, Charlie transfers 100 to David, etc. Formal verification proves stronger properties universally: ‚ÄúTransfer never creates tokens from nothing‚Äù (conservation), ‚ÄúTransfer from Alice to Bob decreases Alice‚Äôs balance v√† increases Bob‚Äôs by same amount‚Äù (correct state transition), ‚ÄúTotal supply constant across all transfers‚Äù (invariant preservation). These properties hold for every possible transfer, every possible initial state, proven mathematically.</p>

<p>Analogy v·ªõi building bridges illuminates value proposition. Testing bridge nh∆∞ having trucks drive across, measuring stress, checking for problems. This discovers obvious flaws but cannot guarantee bridge safe under all conditions - unusual load combinations, rare weather patterns, material degradation over time. Engineering calculations prove bridge withstands maximum specified loads using physics equations v√† material properties. Similarly, formal verification proves smart contracts handle all scenarios using logic v√† mathematics, providing assurance beyond empirical testing.</p>

<p>Verification workflow comparable to peer review trong academic publishing. Researcher submits paper claiming theorem proven. Reviewers check proof rigorously, verifying each logical step follows from axioms v√† previous steps. If proof valid, theorem accepted as established fact. Formal verification similar - developer claims contract satisfies properties, verification tool checks proof automatically, if valid then properties mathematically guaranteed. Difference: verification automated, eliminating human error trong proof checking.</p>

<p>Types c·ªßa properties verified fall into categories. <strong>Safety properties</strong> assert ‚Äúnothing bad happens‚Äù - no reentrancy, no overflow, no unauthorized access. <strong>Liveness properties</strong> ensure ‚Äúsomething good eventually happens‚Äù - functions eventually terminate, legitimate transactions eventually process. <strong>Functional correctness</strong> proves implementation matches specification precisely. <strong>Economic properties</strong> verify incentive mechanisms game-theoretically sound. Each property type requires different verification techniques v√† tooling.</p>

<hr />

<h2 id="3-technical-foundation">3. Technical Foundation</h2>

<p>Formal verification foundations rest on formal semantics - precise mathematical definition c·ªßa programming language meaning. EVM semantics define exactly what each opcode does, how state changes, how gas consumed. Without formal semantics, cannot reason about programs rigorously. <strong>KEVM</strong> project formalized EVM semantics using K Framework, creating executable formal specification serving both as documentation v√† verification basis.</p>

<p>Hoare logic provides core framework for reasoning about imperative programs. Hoare triple ({P} S {Q}) asserts: if precondition (P) holds before executing statement (S), postcondition (Q) holds after. Rules compose triples to reason about larger programs:</p>

<p><strong>Sequential composition</strong>:
[
\frac{{P} S_1 {Q}, \quad {Q} S_2 {R}}{{P} S_1; S_2 {R}}
]</p>

<p><strong>Conditional</strong>:
[
\frac{{P \land B} S_1 {Q}, \quad {P \land \neg B} S_2 {Q}}{{P} \text{if } B \text{ then } S_1 \text{ else } S_2 {Q}}
]</p>

<p><strong>Loop invariant</strong>:
[
\frac{{I \land B} S {I}}{{I} \text{while } B \text{ do } S {I \land \neg B}}
]</p>

<p>Where (I) loop invariant - property remaining true each iteration.</p>

<p>Applying to Solidity, consider simple transfer:</p>

<pre><code class="language-solidity">function transfer(address to, uint amount) public {
    require(balances[msg.sender] &gt;= amount);  // Precondition
    balances[msg.sender] -= amount;
    balances[to] += amount;
    // Postcondition: balances preserved
}
</code></pre>

<p>Formal specification:
[
\begin{align}
P: &amp; \quad \text{balances}[sender] \geq amount <br />
Q: &amp; \quad \text{balances}‚Äô[sender] = \text{balances}[sender] - amount <br />
   &amp; \quad \land \text{balances}‚Äô[to] = \text{balances}[to] + amount <br />
   &amp; \quad \land \sum \text{balances}‚Äô = \sum \text{balances}
\end{align}
]</p>

<p>Proof obligations verify each line preserves stated relationships.</p>

<p>Symbolic execution explores program paths symbolically rather than concretely. Variables represented as symbols ((x), (y)) rather than concrete values (5, 10). Path conditions accumulated as symbolic constraints. At end c·ªßa path, constraint solver (SMT solver) determines if unsafe states reachable. If solver finds satisfying assignment reaching error state, bug found; if proves no assignment possible, path safe.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">symbolic_execution_example</span><span class="p">():</span>
    <span class="sh">"""</span><span class="s">Illustrate symbolic execution concept</span><span class="sh">"""</span>
    
    <span class="c1"># Concrete execution:
</span>    <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c1"># y = 10
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">15</span>  <span class="c1"># Passes
</span>    
    <span class="c1"># Symbolic execution:
</span>    <span class="n">x</span> <span class="o">=</span> <span class="nc">Symbol</span><span class="p">(</span><span class="sh">'</span><span class="s">x</span><span class="sh">'</span><span class="p">)</span>  <span class="c1"># x is symbolic variable
</span>    
    <span class="c1"># Path 1: x &gt; 3
</span>    <span class="n">path1_condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">path1_y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="n">path1_assertion</span> <span class="o">=</span> <span class="p">(</span><span class="n">path1_y</span> <span class="o">&lt;</span> <span class="mi">15</span><span class="p">)</span>
    <span class="c1"># Combine: (x &gt; 3) ‚àß (x * 2 &lt; 15)
</span>    <span class="c1"># Simplify: (x &gt; 3) ‚àß (x &lt; 7.5)
</span>    <span class="c1"># Satisfiable: x ‚àà (3, 7.5) - PATH SAFE
</span>    
    <span class="c1"># Path 2: x ‚â§ 3
</span>    <span class="n">path2_condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">path2_y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">path2_assertion</span> <span class="o">=</span> <span class="p">(</span><span class="n">path2_y</span> <span class="o">&lt;</span> <span class="mi">15</span><span class="p">)</span>
    <span class="c1"># Combine: (x ‚â§ 3) ‚àß (x + 1 &lt; 15)
</span>    <span class="c1"># Simplify: (x ‚â§ 3) ‚àß (x &lt; 14)
</span>    <span class="c1"># Satisfiable: x ‚â§ 3 - PATH SAFE
</span>    
    <span class="c1"># Both paths safe ‚Üí Function verified!
</span></code></pre></div></div>

<p>Model checking approach explores state space exhaustively. Smart contract modeled as finite state machine, properties expressed as temporal logic formulas. Model checker systematically explores reachable states, verifying properties hold trong all states v√† transitions. Technique effective for protocol-level verification nh∆∞ng faces state explosion - number of states grows exponentially v·ªõi variables. Abstraction techniques mitigate n√†y by grouping similar states, trading precision for tractability.</p>

<p>Theorem proving requires encoding program v√† properties trong proof assistant (Coq, Isabelle, Lean), then constructing formal proof interactively. Proof assistant checks each step, ensuring logical soundness. Approach provides strongest guarantees - fully mechanized mathematical proof - nh∆∞ng demands significant expertise. Successes include <strong>CompCert</strong> (verified C compiler) v√† <strong>seL4</strong> (verified microkernel). Smart contract theorem proving emerging - <strong>Ether</strong> project verified ERC-20 properties using Coq.</p>

<hr />

<h2 id="4-mathematical--cryptographic-formulation">4. Mathematical / Cryptographic Formulation</h2>

<p>Formal specification requires precise mathematical statement c·ªßa intended behavior. For ERC-20 token, fundamental invariant:</p>

<p>[
\forall t: \quad \sum_{a \in \text{addresses}} \text{balanceOf}(a, t) = \text{totalSupply}
]</p>

<p>This states total supply constant across all times. Transfer function must preserve n√†y:</p>

<p>[
{B_1 + B_2 = S} \quad \text{transfer}(from, to, v) \quad {B_1‚Äô + B_2‚Äô = S}
]</p>

<p>Where (B_1 = \text{balanceOf}(from)), (B_2 = \text{balanceOf}(to)), (S = \text{totalSupply}).</p>

<p>Expanding:
[
\begin{align}
B_1‚Äô &amp;= B_1 - v <br />
B_2‚Äô &amp;= B_2 + v <br />
B_1‚Äô + B_2‚Äô &amp;= (B_1 - v) + (B_2 + v) = B_1 + B_2 = S \quad \checkmark
\end{align}
]</p>

<p>Invariant preserved!</p>

<p>Reentrancy verification requires proving state updates occur before external calls. Using Hoare logic:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{balances[sender] = B}
balances[sender] -= amount;
{balances[sender] = B - amount}  // State updated
(bool success,) = recipient.call{value: amount}("");
{balances[sender] = B - amount}  // Still holds - no reentry possible
</code></pre></div></div>

<p>Versus vulnerable code:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{balances[sender] = B}
recipient.call{value: amount}("");
// Reentry possible! balances[sender] still B
balances[sender] -= amount;
</code></pre></div></div>

<p>Formal proof shows second version allows multiple withdrawals before state update, violating invariant.</p>

<hr />

<h2 id="5-implementation-insight">5. Implementation Insight</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">z3</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">verify_transfer_preserves_total</span><span class="p">():</span>
    <span class="sh">"""</span><span class="s">
    Use Z3 SMT solver to verify transfer preserves total supply
    </span><span class="sh">"""</span>
    
    <span class="c1"># Define symbolic variables
</span>    <span class="n">balance_from</span> <span class="o">=</span> <span class="nc">Int</span><span class="p">(</span><span class="sh">'</span><span class="s">balance_from</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">balance_to</span> <span class="o">=</span> <span class="nc">Int</span><span class="p">(</span><span class="sh">'</span><span class="s">balance_to</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">amount</span> <span class="o">=</span> <span class="nc">Int</span><span class="p">(</span><span class="sh">'</span><span class="s">amount</span><span class="sh">'</span><span class="p">)</span>
    
    <span class="c1"># Define solver
</span>    <span class="n">solver</span> <span class="o">=</span> <span class="nc">Solver</span><span class="p">()</span>
    
    <span class="c1"># Preconditions
</span>    <span class="n">solver</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">balance_from</span> <span class="o">&gt;=</span> <span class="n">amount</span><span class="p">)</span>  <span class="c1"># Sufficient balance
</span>    <span class="n">solver</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">balance_from</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">solver</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">balance_to</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">solver</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">amount</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
    
    <span class="c1"># Compute new balances
</span>    <span class="n">new_balance_from</span> <span class="o">=</span> <span class="n">balance_from</span> <span class="o">-</span> <span class="n">amount</span>
    <span class="n">new_balance_to</span> <span class="o">=</span> <span class="n">balance_to</span> <span class="o">+</span> <span class="n">amount</span>
    
    <span class="c1"># Property to verify: Total preserved
</span>    <span class="n">total_before</span> <span class="o">=</span> <span class="n">balance_from</span> <span class="o">+</span> <span class="n">balance_to</span>
    <span class="n">total_after</span> <span class="o">=</span> <span class="n">new_balance_from</span> <span class="o">+</span> <span class="n">new_balance_to</span>
    
    <span class="c1"># Check if total can differ (should be UNSAT - impossible)
</span>    <span class="n">solver</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">total_before</span> <span class="o">!=</span> <span class="n">total_after</span><span class="p">)</span>
    
    <span class="n">result</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="nf">check</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="n">unsat</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">‚úì VERIFIED: Transfer always preserves total supply</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">  Mathematical proof complete</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">result</span> <span class="o">==</span> <span class="n">sat</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">‚úó VIOLATION FOUND:</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="nf">model</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  balance_from: </span><span class="si">{</span><span class="n">model</span><span class="p">[</span><span class="n">balance_from</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  balance_to: </span><span class="si">{</span><span class="n">model</span><span class="p">[</span><span class="n">balance_to</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  amount: </span><span class="si">{</span><span class="n">model</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">? Unknown (solver timeout)</span><span class="sh">"</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">=== Formal Verification Example ===</span><span class="se">\n</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">verify_transfer_preserves_total</span><span class="p">()</span>
</code></pre></div></div>

<p>Real-world formal verification tools include:</p>

<p><strong>Certora Prover</strong> - industry-leading tool using SMT solvers:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Certora specification language (CVL)
invariant totalSupplyInvariant()
    to_mathint(totalSupply()) == sum(balances);

rule transferPreservesTotal(address from, address to, uint amount) {
    mathint totalBefore = totalSupply();
    
    transfer(from, to, amount);
    
    mathint totalAfter = totalSupply();
    
    assert totalBefore == totalAfter, "Total supply changed!";
}
</code></pre></div></div>

<hr />

<h2 id="6-common-challenges--attacks--trade-offs">6. Common Challenges / Attacks / Trade-offs</h2>

<p>Formal verification faces <strong>specification challenge</strong> - properties must be stated correctly v√† completely. Incomplete specifications lead to false sense of security - contract verified against wrong properties. The DAO contract could have been verified correct relative to incomplete specification missing reentrancy constraints. Expertise required identifying relevant properties profound.</p>

<p><strong>State explosion</strong> limits model checking applicability. Contract v·ªõi (n) boolean variables has (2^n) possible states. With 256-bit integers, state space astronomical. Abstraction techniques –ø–æ–º–æ–≥–∞—é—Ç but may introduce imprecision - abstract model verified but concrete implementation may differ subtly.</p>

<p><strong>Cost-benefit analysis</strong> difficult. Formal verification expensive - weeks to months of expert time, specialized tools, computational resources. Benefits unclear until breach occurs. For small contracts, cost may exceed reasonable risk. For billion-dollar protocols, verification obviously justified. Threshold unclear for intermediate cases.</p>

<hr />

<h2 id="7-related-concepts">7. Related Concepts</h2>

<p>Formal verification connects to <strong>program synthesis</strong> - automatically generating provably correct code from specifications. Instead of writing code then verifying, specify desired behavior formally, synthesizer generates implementation guaranteed satisfying specification. Research active but production adoption limited - synthesis works –¥–ª—è simple contracts, struggles v·ªõi complex business logic.</p>

<p><strong>Runtime monitoring</strong> complements static verification. Deploy contracts v·ªõi runtime assertions checking invariants during execution. If invariant violation detected, halt execution, preventing damage. Trade-off: gas costs for checks, but provides defense-in-depth when static verification infeasible.</p>

<p><strong>Proof-carrying code</strong> embeds proofs within deployments. Contract bytecode accompanied by machine-checkable proof of correctness. Validators verify proof before accepting deployment, ensuring only correct contracts deployed. Research concept, practical implementation challenging.</p>

<hr />

<h2 id="8--fundamental-papers--whitepapers">8. ‚≠ê Fundamental Papers / Whitepapers</h2>

<table>
  <thead>
    <tr>
      <th>Paper</th>
      <th>Year</th>
      <th>Author(s)</th>
      <th>Contribution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>‚ÄúAn Axiomatic Basis for Computer Programming‚Äù</strong></td>
      <td>1969</td>
      <td>C.A.R. Hoare</td>
      <td>Hoare logic foundations</td>
    </tr>
    <tr>
      <td><strong>‚ÄúKEVM: Semantics of EVM in K‚Äù</strong></td>
      <td>2018</td>
      <td>Everett Hildenbrandt et al.</td>
      <td>Formal EVM semantics</td>
    </tr>
    <tr>
      <td><strong>‚ÄúFormal Verification of Smart Contracts‚Äù</strong></td>
      <td>2016</td>
      <td>Bhargavan et al.</td>
      <td>Early smart contract verification</td>
    </tr>
    <tr>
      <td><strong>‚ÄúCertora Prover: Formal Verification for Solidity‚Äù</strong></td>
      <td>2020</td>
      <td>Certora team</td>
      <td>Industrial verification tool</td>
    </tr>
    <tr>
      <td><strong>‚ÄúRuntime Verification of Ethereum Smart Contracts‚Äù</strong></td>
      <td>2018</td>
      <td>Joshua Ellul, Gordon Pace</td>
      <td>Runtime monitoring approach</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="9--illustrations--visual-references">9. üé® Illustrations &amp; Visual References</h2>

<h3 id="hoare-logic-example">Hoare Logic Example</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{x &gt; 0}           // Precondition
y := x + 1
{y &gt; 1}           // Postcondition

Proof: If x &gt; 0, then x + 1 &gt; 1 ‚úì
</code></pre></div></div>

<h3 id="verification-workflow">Verification Workflow</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Smart Contract
      ‚Üì
  Specification (properties to verify)
      ‚Üì
  Verification Tool (Z3, Certora, etc.)
      ‚Üì
   Verified ‚úì or Bug Found ‚úó
</code></pre></div></div>

<p><em>Source: <a href="https://docs.certora.com/">Certora Documentation</a></em></p>

<hr />

<h2 id="10-summary">10. Summary</h2>

<p>Formal verification provides mathematical guarantees v·ªÅ smart contract correctness unattainable through testing alone. Using techniques like Hoare logic, symbolic execution, model checking, v√† theorem proving, developers can prove contracts satisfy critical properties for all possible inputs v√† states. Despite challenges including specification difficulty, state explosion, v√† expertise requirements, formal verification increasingly essential for high-value protocols given immutability c·ªßa deployed contracts v√† enormous financial stakes involved.</p>

<p>Tools like Certora Prover, K Framework, v√† Z3 make verification more accessible, though significant expertise still required. Future likely sees verification integrated earlier into development workflows, automated verification improving, v√† standards emerging around verified contract patterns. Understanding formal verification fundamentals enables both better security assessment c·ªßa existing contracts v√† development c·ªßa provably correct new protocols.</p>

<hr />

<p>‚úÖ <strong>End of Lecture</strong></p>

<p>Next: Lecture 05.04 - Post-Quantum Cryptography</p>

<hr />

<h2 id="references">References</h2>

<ol>
  <li>Hoare, C. A. R. (1969). <em>An axiomatic basis for computer programming</em>. Communications of the ACM, 12(10), 576-580.</li>
  <li>Hildenbrandt, E., et al. (2018). <em>KEVM: A complete formal semantics of the Ethereum Virtual Machine</em>. CSF 2018.</li>
  <li>Certora. (2020). <em>Certora Prover Documentation</em>. https://docs.certora.com/</li>
  <li>Runtime Verification. (2018). <em>K Framework</em>. https://kframework.org/</li>
</ol>


</div>

<!-- Back to Chapter Home Link -->

  
  
  <div style="margin-top: 20px; padding: 10px; background-color: #f8f9fa; border-left: 4px solid #007bff;">
    <a href="/deep-learning-self-learning/contents/vi/chapter05/" style="text-decoration: none; color: #007bff; font-weight: bold;">
      ‚Üê Quay l·∫°i ƒë·∫ßu ch∆∞∆°ng
    </a>
  </div>













<div class="related">
  <ul class="related-posts">
    
      
    
      
    
      
        <li>
          <h2>Previous Post</h2>
          <h3>
            <a href="/deep-learning-self-learning/contents/vi/chapter05/blockchain-chapter05/05_02_Smart_Contract_Security/">
              Lecture 05.02: Smart Contract Security - Vulnerabilities v√† Best Practices
            </a>
          </h3>
        </li>
      
    
      
    
      
    
      
    
    
    
  
    
  
    
  
    
  
    
      <li>
        <h2>Next Post</h2>
        <h3>
          <a href="/deep-learning-self-learning/contents/vi/chapter05/blockchain-chapter05/05_04_Post_Quantum_Cryptography/">
            Lecture 05.04: Post-Quantum Cryptography - Preparing for Quantum Computing Era
          </a>
        </h3>
      </li>
    
  
    
  
  </ul>
</div>



<script src="https://utteranc.es/client.js"
        repo="convex-deep-learning-for-all/convex-deep-learning-for-all.github.io"
        issue-term="title"
        label="Comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src='/deep-learning-self-learning/public/js/script.js'></script>
    <script src='/deep-learning-self-learning/public/js/multilang.js'></script>
    <script src='/deep-learning-self-learning/public/js/search.js'></script>
  </body>
</html>

<!DOCTYPE html>
<html lang="vi">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <style>
    .MathJax {
      padding: 2em 0.3em;
      overflow-x: auto;
      overflow-y: hidden;
    }
  </style>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

  <title>
    
      Lecture 03.03: DeFi Protocols - Decentralized Finance Mechanics &middot; Blockchain
    
  </title>

  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/poole.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/syntax.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/lanyon.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/github-markdown.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/multilang.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/search.css">
  <link rel="stylesheet" href="/deep-learning-self-learning/public/css/content-boxes.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap">
  
  <!-- Lunr.js for search functionality -->
  <script src="https://unpkg.com/lunr/lunr.js"></script>

  <link rel="apple-touch-icon-precomposed" sizes="122x144" href="http://0.0.0.0:4000/deep-learning-self-learning/public/logo.png">
  <link rel="shortcut icon" href="http://0.0.0.0:4000/deep-learning-self-learning/public/convex-logo-144x144.png">

  <link rel="alternate" type="application/rss+xml" title="RSS" href="http://0.0.0.0:4000/deep-learning-self-learning/atom.xml">

  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', '', 'auto');
    ga('send', 'pageview');
  </script>
  
</head>


  <body class="sidebar-overlay">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>Blockchain</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/">Trang ch·ªß</a>

    

    
    
    
    <!-- Hi·ªÉn th·ªã c√°c ch∆∞∆°ng c√≥ s·∫µn cho ng√¥n ng·ªØ hi·ªán t·∫°i -->
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter00/">
              00. Chapter 00: N·ªÅn T·∫£ng Blockchain
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter01/">
              01. Chapter 01: Bitcoin - Architecture v√† Proof-of-Work
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter02/">
              02. Chapter 02: Advanced Consensus Mechanisms
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter03/">
              03. Chapter 03: Ethereum v√† Smart Contracts
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter04/">
              04. Chapter 04: Blockchain Scalability v√† Layer-2 Solutions
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter05/">
              05. Chapter 05: Privacy v√† Security trong Blockchain
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter06/">
              06. Chapter 06: Blockchain Interoperability
              
            </a>
          
        
      
    
      
        
          
          
            <a class="sidebar-nav-item" href="http://0.0.0.0:4000/deep-learning-self-learning/contents/vi/chapter07/">
              07. Chapter 07: Advanced Blockchain Topics
              
            </a>
          
        
      
    
    
    <!-- N·∫øu kh√¥ng c√≥ n·ªôi dung cho ng√¥n ng·ªØ hi·ªán t·∫°i, hi·ªÉn th·ªã th√¥ng b√°o -->
    
    
    <span class="sidebar-nav-item">Currently v0.0.1</span>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2025. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap github-md-body">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/deep-learning-self-learning/" title="Trang ch·ªß">Blockchain</a>
            <small></small>
          </h3>
          <!-- Header Actions: Language Toggle and GitHub Link -->
          <div class="header-actions">
            <div class="language-toggle">
              <a href="/deep-learning-self-learning/contents/en/chapter00/" class="language-switch" title="Chuy·ªÉn sang ti·∫øng Anh">Chuy·ªÉn sang ti·∫øng Anh</a>
            </div>
            <a class="github-logo__wrapper" target="_blank" href="https://github.com/nglelinh/deep-learning-self-learning" title="Github">
             <svg class="github-logo" xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 48 48"><linearGradient id="rL2wppHyxHVbobwndsT6Ca" x1="4" x2="44" y1="23.508" y2="23.508" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#4c4c4c"/><stop offset="1" stop-color="#343434"/></linearGradient><path fill="url(#rL2wppHyxHVbobwndsT6Ca)" d="M24,4C12.954,4,4,12.954,4,24c0,8.887,5.801,16.411,13.82,19.016h12.36	C38.199,40.411,44,32.887,44,24C44,12.954,35.046,4,24,4z"/><path d="M30.01,41.996L30,36.198c0-0.939-0.22-1.856-0.642-2.687c5.641-1.133,8.386-4.468,8.386-10.177	c0-2.255-0.665-4.246-1.976-5.92c0.1-0.317,0.174-0.645,0.22-0.981c0.188-1.369-0.023-2.264-0.193-2.984l-0.027-0.116	c-0.186-0.796-0.409-1.364-0.418-1.388l-0.111-0.282l-0.111-0.282l-0.302-0.032l-0.303-0.032c0,0-0.199-0.021-0.501-0.021	c-0.419,0-1.04,0.042-1.627,0.241l-0.196,0.066c-0.74,0.249-1.439,0.485-2.417,1.069c-0.286,0.171-0.599,0.366-0.934,0.584	C27.334,12.881,25.705,12.69,24,12.69c-1.722,0-3.365,0.192-4.889,0.571c-0.339-0.22-0.654-0.417-0.942-0.589	c-0.978-0.584-1.677-0.819-2.417-1.069l-0.196-0.066c-0.585-0.199-1.207-0.241-1.626-0.241c-0.302,0-0.501,0.021-0.501,0.021	l-0.302,0.032l-0.3,0.031l-0.112,0.281l-0.113,0.283c-0.01,0.026-0.233,0.594-0.419,1.391l-0.027,0.115	c-0.17,0.719-0.381,1.615-0.193,2.983c0.048,0.346,0.125,0.685,0.23,1.011c-1.285,1.666-1.936,3.646-1.936,5.89	c0,5.695,2.748,9.028,8.397,10.17c-0.194,0.388-0.345,0.798-0.452,1.224c-0.197,0.067-0.378,0.112-0.538,0.137	c-0.238,0.036-0.487,0.054-0.739,0.054c-0.686,0-1.225-0.134-1.435-0.259c-0.313-0.186-0.872-0.727-1.414-1.518	c-0.463-0.675-1.185-1.558-1.992-1.927c-0.698-0.319-1.437-0.502-2.029-0.502c-0.138,0-0.265,0.01-0.376,0.028	c-0.517,0.082-0.949,0.366-1.184,0.78c-0.203,0.357-0.235,0.773-0.088,1.141c0.219,0.548,0.851,0.985,1.343,1.255	c0.242,0.133,0.765,0.619,1.07,1.109c0.229,0.368,0.335,0.63,0.482,0.992c0.087,0.215,0.183,0.449,0.313,0.732	c0.47,1.022,1.937,1.924,2.103,2.023c0.806,0.483,2.161,0.638,3.157,0.683l0.123,0.003c0,0,0.001,0,0.001,0	c0.24,0,0.57-0.023,1.004-0.071v2.613c0.002,0.529-0.537,0.649-1.25,0.638l0.547,0.184C19.395,43.572,21.645,44,24,44	c2.355,0,4.605-0.428,6.703-1.176l0.703-0.262C30.695,42.538,30.016,42.422,30.01,41.996z" opacity=".05"/><path d="M30.781,42.797c-0.406,0.047-1.281-0.109-1.281-0.795v-5.804c0-1.094-0.328-2.151-0.936-3.052	c5.915-0.957,8.679-4.093,8.679-9.812c0-2.237-0.686-4.194-2.039-5.822c0.137-0.365,0.233-0.75,0.288-1.147	c0.175-1.276-0.016-2.086-0.184-2.801l-0.027-0.116c-0.178-0.761-0.388-1.297-0.397-1.319l-0.111-0.282l-0.303-0.032	c0,0-0.178-0.019-0.449-0.019c-0.381,0-0.944,0.037-1.466,0.215l-0.196,0.066c-0.714,0.241-1.389,0.468-2.321,1.024	c-0.332,0.198-0.702,0.431-1.101,0.694C27.404,13.394,25.745,13.19,24,13.19c-1.762,0-3.435,0.205-4.979,0.61	c-0.403-0.265-0.775-0.499-1.109-0.699c-0.932-0.556-1.607-0.784-2.321-1.024l-0.196-0.066c-0.521-0.177-1.085-0.215-1.466-0.215	c-0.271,0-0.449,0.019-0.449,0.019l-0.302,0.032l-0.113,0.283c-0.009,0.022-0.219,0.558-0.397,1.319l-0.027,0.116	c-0.169,0.715-0.36,1.524-0.184,2.8c0.056,0.407,0.156,0.801,0.298,1.174c-1.327,1.62-1.999,3.567-1.999,5.795	c0,5.703,2.766,8.838,8.686,9.806c-0.395,0.59-0.671,1.255-0.813,1.964c-0.33,0.13-0.629,0.216-0.891,0.256	c-0.263,0.04-0.537,0.06-0.814,0.06c-0.69,0-1.353-0.129-1.69-0.329c-0.44-0.261-1.057-0.914-1.572-1.665	c-0.35-0.51-1.047-1.417-1.788-1.755c-0.635-0.29-1.298-0.457-1.821-0.457c-0.11,0-0.21,0.008-0.298,0.022	c-0.366,0.058-0.668,0.252-0.828,0.534c-0.128,0.224-0.149,0.483-0.059,0.708c0.179,0.448,0.842,0.85,1.119,1.002	c0.335,0.184,0.919,0.744,1.254,1.284c0.251,0.404,0.37,0.697,0.521,1.067c0.085,0.209,0.178,0.437,0.304,0.712	c0.331,0.719,1.353,1.472,1.905,1.803c0.754,0.452,2.154,0.578,2.922,0.612l0.111,0.002c0.299,0,0.8-0.045,1.495-0.135v3.177	c0,0.779-0.991,0.81-1.234,0.81c-0.031,0,0.503,0.184,0.503,0.184C19.731,43.64,21.822,44,24,44c2.178,0,4.269-0.36,6.231-1.003	C30.231,42.997,30.812,42.793,30.781,42.797z" opacity=".07"/><path fill="#fff" d="M36.744,23.334c0-2.31-0.782-4.226-2.117-5.728c0.145-0.325,0.296-0.761,0.371-1.309	c0.172-1.25-0.031-2-0.203-2.734s-0.375-1.25-0.375-1.25s-0.922-0.094-1.703,0.172s-1.453,0.469-2.422,1.047	c-0.453,0.27-0.909,0.566-1.27,0.806C27.482,13.91,25.785,13.69,24,13.69c-1.801,0-3.513,0.221-5.067,0.652	c-0.362-0.241-0.821-0.539-1.277-0.811c-0.969-0.578-1.641-0.781-2.422-1.047s-1.703-0.172-1.703-0.172s-0.203,0.516-0.375,1.25	s-0.375,1.484-0.203,2.734c0.077,0.562,0.233,1.006,0.382,1.333c-1.31,1.493-2.078,3.397-2.078,5.704	c0,5.983,3.232,8.714,9.121,9.435c-0.687,0.726-1.148,1.656-1.303,2.691c-0.387,0.17-0.833,0.33-1.262,0.394	c-1.104,0.167-2.271,0-2.833-0.333s-1.229-1.083-1.729-1.813c-0.422-0.616-1.031-1.331-1.583-1.583	c-0.729-0.333-1.438-0.458-1.833-0.396c-0.396,0.063-0.583,0.354-0.5,0.563c0.083,0.208,0.479,0.521,0.896,0.75	c0.417,0.229,1.063,0.854,1.438,1.458c0.418,0.674,0.5,1.063,0.854,1.833c0.249,0.542,1.101,1.219,1.708,1.583	c0.521,0.313,1.562,0.491,2.688,0.542c0.389,0.018,1.308-0.096,2.083-0.206v3.75c0,0.639-0.585,1.125-1.191,1.013	C19.756,43.668,21.833,44,24,44c2.166,0,4.243-0.332,6.19-0.984C29.585,43.127,29,42.641,29,42.002v-5.804	c0-1.329-0.527-2.53-1.373-3.425C33.473,32.071,36.744,29.405,36.744,23.334z M11.239,32.727c-0.154-0.079-0.237-0.225-0.185-0.328	c0.052-0.103,0.22-0.122,0.374-0.043c0.154,0.079,0.237,0.225,0.185,0.328S11.393,32.806,11.239,32.727z M12.451,33.482	c-0.081,0.088-0.255,0.06-0.389-0.062s-0.177-0.293-0.096-0.381c0.081-0.088,0.255-0.06,0.389,0.062S12.532,33.394,12.451,33.482z M13.205,34.732c-0.102,0.072-0.275,0.005-0.386-0.15s-0.118-0.34-0.016-0.412s0.275-0.005,0.386,0.15	C13.299,34.475,13.307,34.66,13.205,34.732z M14.288,35.673c-0.069,0.112-0.265,0.117-0.437,0.012s-0.256-0.281-0.187-0.393	c0.069-0.112,0.265-0.117,0.437-0.012S14.357,35.561,14.288,35.673z M15.312,36.594c-0.213-0.026-0.371-0.159-0.353-0.297	c0.017-0.138,0.204-0.228,0.416-0.202c0.213,0.026,0.371,0.159,0.353,0.297C15.711,36.529,15.525,36.62,15.312,36.594z M16.963,36.833c-0.227-0.013-0.404-0.143-0.395-0.289c0.009-0.146,0.2-0.255,0.427-0.242c0.227,0.013,0.404,0.143,0.395,0.289	C17.381,36.738,17.19,36.846,16.963,36.833z M18.521,36.677c-0.242,0-0.438-0.126-0.438-0.281s0.196-0.281,0.438-0.281	c0.242,0,0.438,0.126,0.438,0.281S18.762,36.677,18.521,36.677z"/></svg>
            </a>
          </div>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">
    Lecture 03.03: DeFi Protocols - Decentralized Finance Mechanics
    
  </h1>
  <h1 id="lecture-defi-protocols---decentralized-finance-mechanics">Lecture: DeFi Protocols - Decentralized Finance Mechanics</h1>

<h2 id="1-t·ªïng-quan-v·ªÅ-kh√°i-ni·ªám">1. T·ªïng quan v·ªÅ kh√°i ni·ªám</h2>

<p><strong>DeFi (Decentralized Finance)</strong> l√† m·ªôt trong nh·ªØng applications th√†nh c√¥ng nh·∫•t c·ªßa smart contracts, creating m·ªôt h·ªá th·ªëng t√†i ch√≠nh ho√†n to√†n m·ªõi kh√¥ng c·∫ßn banks, brokers, hay intermediaries. V√†o nƒÉm 2020, DeFi exploded t·ª´ &lt;$1 billion sang &gt;$100 billion total value locked (TVL) trong v√≤ng m·ªôt nƒÉm - m·ªôt trong nh·ªØng fastest-growing sectors trong tech history.</p>

<p><strong>What is DeFi?</strong></p>

<p>DeFi l√† t·∫≠p h·ª£p c√°c <strong>financial protocols built on blockchains</strong> (primarily Ethereum) cho ph√©p:</p>
<ul>
  <li><strong>Lending/Borrowing</strong>: Cho vay v√† ƒëi vay m√† kh√¥ng c·∫ßn banks</li>
  <li><strong>Trading</strong>: Swap tokens kh√¥ng c·∫ßn centralized exchanges</li>
  <li><strong>Yield Generation</strong>: Earn interest tr√™n crypto holdings</li>
  <li><strong>Derivatives</strong>: Options, futures, synthetic assets</li>
  <li><strong>Insurance</strong>: Decentralized risk protection</li>
  <li><strong>Asset Management</strong>: Automated portfolio management</li>
</ul>

<p><strong>Core Innovation - Composability</strong>:</p>

<p>DeFi protocols nh∆∞ <strong>‚ÄúMoney Legos‚Äù</strong> - c√≥ th·ªÉ combine v·ªõi nhau:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Traditional Finance (Siloed):
Bank A ‚îÄ‚îê
        ‚îú‚îÄ Cannot easily combine
Bank B ‚îÄ‚îò

DeFi (Composable):
Uniswap ‚îÄ‚îÄ‚îê
          ‚îú‚îÄ Can compose freely!
Aave ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
          ‚îú‚îÄ Example: Borrow from Aave ‚Üí
Compound ‚îÄ‚îò           Trade on Uniswap ‚Üí
                      Lend on Compound
                      
All in one transaction!
</code></pre></div></div>

<p><strong>DeFi Summer (2020)</strong> - The Explosion:</p>

<p>June-September 2020 saw unprecedented growth:</p>
<ul>
  <li><strong>Liquidity Mining</strong>: Projects incentivize users v·ªõi token rewards</li>
  <li><strong>Yield Farming</strong>: Users optimize returns across protocols</li>
  <li><strong>TVL Growth</strong>: $1B ‚Üí $15B in 3 months</li>
  <li><strong>Innovation</strong>: AMMs, flash loans, composable strategies</li>
</ul>

<p><strong>Key Protocols</strong> (by TVL, 2024):</p>
<ol>
  <li><strong>Uniswap</strong>: ~$4B TVL - Decentralized exchange (AMM)</li>
  <li><strong>Aave</strong>: ~$6B TVL - Lending/borrowing</li>
  <li><strong>MakerDAO</strong>: ~$5B TVL - Stablecoin (DAI)</li>
  <li><strong>Curve</strong>: ~$2B TVL - Stablecoin exchange</li>
  <li><strong>Lido</strong>: ~$20B TVL - Liquid staking</li>
</ol>

<p><strong>The DeFi Stack</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Layer 4: Aggregators (1inch, Yearn)
         ‚îî‚îÄ Optimize across protocols
         
Layer 3: Applications (Uniswap, Aave, Compound)
         ‚îî‚îÄ User-facing protocols
         
Layer 2: Infrastructure (Oracles, Keepers)
         ‚îî‚îÄ Price feeds, automation
         
Layer 1: Base Layer (Ethereum)
         ‚îî‚îÄ Smart contract execution
         
Layer 0: Assets (ETH, WBTC, stablecoins)
         ‚îî‚îÄ Underlying value
</code></pre></div></div>

<hr />

<h2 id="2-hi·ªÉu-bi·∫øt-tr·ª±c-quan">2. Hi·ªÉu bi·∫øt tr·ª±c quan</h2>

<h3 id="21-automated-market-maker-amm---robot-market-maker">2.1. Automated Market Maker (AMM) - ‚ÄúRobot Market Maker‚Äù</h3>

<p><strong>Traditional Exchange</strong> (Orderbook):</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Buyers post: "I want to buy 10 ETH at $2000 each"
Sellers post: "I want to sell 10 ETH at $2010 each"
Matching engine: Pairs buyers v·ªõi sellers

Requires:
‚úì Active market makers
‚úì Sufficient liquidity
‚úì Centralized infrastructure
</code></pre></div></div>

<p><strong>AMM</strong> (Constant Product):</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Instead of orderbook: Use liquidity pool!

Pool contains:
- 1000 ETH
- 2,000,000 USDC

Price determined by formula:
x √ó y = k (constant)
ETH_amount √ó USDC_amount = constant

To buy ETH:
1. Add USDC to pool
2. Remove proportional ETH
3. Maintain x √ó y = k

No orderbook needed!
No market makers needed!
Always liquid!
</code></pre></div></div>

<p><strong>Example Trade</strong>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Pool before: 1000 ETH √ó 2,000,000 USDC = 2,000,000,000 (k)

User wants to buy 10 ETH:

Add USDC to pool, remove ETH:
(1000 - 10) √ó (2,000,000 + X) = 2,000,000,000

Solve for X:
990 √ó (2,000,000 + X) = 2,000,000,000
2,000,000 + X = 2,020,202
X = 20,202 USDC

Price per ETH: 20,202 / 10 = 2,020 USDC

Pool after: 990 ETH √ó 2,020,202 USDC = 2,000,000,000 ‚úì
</code></pre></div></div>

<p><strong>Price Impact</strong>: Larger trade ‚Üí bigger price movement!</p>

<h3 id="22-lending-protocol---peer-to-pool-lending">2.2. Lending Protocol - ‚ÄúPeer-to-Pool Lending‚Äù</h3>

<p><strong>Traditional Bank</strong>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Depositor ‚Üí Bank (takes deposits) ‚Üí Borrower
              ‚Üì
          Bank keeps spread (profit)
          
Depositor gets: 1% interest
Borrower pays: 5% interest
Bank profit: 4% spread
</code></pre></div></div>

<p><strong>DeFi Lending</strong> (Aave/Compound):</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Depositor ‚Üí Liquidity Pool ‚Üê Borrower
                ‚Üì
        Interest shared directly
        
Depositor gets: 4% APY (direct from borrowers)
Borrower pays: 5% APY (directly to pool)
Protocol fee: 1% (minimal)
</code></pre></div></div>

<p><strong>How It Works</strong>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Alice deposits 100 ETH into pool
   ‚Üí Receives 100 aETH (receipt tokens)
   ‚Üí Earns interest automatically

2. Bob wants to borrow
   ‚Üí Deposits collateral (150 ETH worth of USDC)
   ‚Üí Can borrow up to ~100 ETH (67% collateralization)
   ‚Üí Pays interest to pool

3. Interest accumulates
   ‚Üí Alice's aETH value increases
   ‚Üí Can redeem anytime for ETH + interest

No approval needed!
No credit check!
Instant!
</code></pre></div></div>

<h3 id="23-impermanent-loss---price-change-risk">2.3. Impermanent Loss - ‚ÄúPrice Change Risk‚Äù</h3>

<p><strong>Concept</strong>: Providing liquidity c√≥ th·ªÉ less profitable than just holding!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Scenario:
You have: 10 ETH + 20,000 USDC (total: $40,000)

Option A: HOLD
- Keep 10 ETH + 20,000 USDC
- ETH price doubles: $2000 ‚Üí $4000
- Value: 10 √ó $4000 + $20,000 = $60,000

Option B: Provide Liquidity (AMM)
- Add to pool: 10 ETH + 20,000 USDC
- ETH price doubles
- Pool rebalances automatically
- You have: ~7.07 ETH + 28,284 USDC
- Value: 7.07 √ó $4000 + $28,284 = $56,568

Loss: $60,000 - $56,568 = $3,432 (5.7%)

This is "impermanent loss"!
(Impermanent because loss only realized when you withdraw)
</code></pre></div></div>

<p><strong>Formula</strong>:
[
\text{IL} = \frac{2\sqrt{r}}{1 + r} - 1
]</p>

<p>Where ( r = \frac{\text{Price}<em>{\text{new}}}{\text{Price}</em>{\text{old}}} )</p>

<h3 id="24-flash-loans---borrow-without-collateral">2.4. Flash Loans - ‚ÄúBorrow Without Collateral‚Äù</h3>

<p><strong>Revolutionary Concept</strong>: Borrow millions without collateral!</p>

<p><strong>How?</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Traditional Loan:
1. Apply for loan
2. Provide collateral
3. Receive loan
4. Repay over time

Flash Loan (one transaction!):
1. Borrow (no collateral!)
2. Use funds
3. Repay loan + fee
4. If can't repay ‚Üí entire transaction reverts
   (like loan never happened!)
</code></pre></div></div>

<p><strong>Example</strong>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Transaction atomicity ensures:
function flashLoanArbitrage() {
    // 1. Borrow 1000 ETH from Aave (no collateral!)
    borrow(1000 ETH);
    
    // 2. Trade on Uniswap (ETH cheap here)
    buy 1000 ETH worth of USDC on Uniswap;
    
    // 3. Trade on SushiSwap (USDC expensive here)
    sell USDC on SushiSwap for 1010 ETH;
    
    // 4. Repay loan + 0.09% fee
    repay(1000.9 ETH);
    
    // 5. Keep profit
    profit = 1010 - 1000.9 = 9.1 ETH!
}

If step 4 fails ‚Üí Everything reverts!
Risk-free arbitrage!
</code></pre></div></div>

<hr />

<h2 id="3-n·ªÅn-t·∫£ng-k·ªπ-thu·∫≠t">3. N·ªÅn t·∫£ng k·ªπ thu·∫≠t</h2>

<h3 id="31-uniswap-v2---constant-product-amm">3.1. Uniswap V2 - Constant Product AMM</h3>

<p><strong>Core Formula</strong>:</p>

<p>[
x \times y = k
]</p>

<p>Where:</p>
<ul>
  <li>x = reserve of token A</li>
  <li>y = reserve of token B</li>
  <li>k = constant product</li>
</ul>

<p><strong>Smart Contract Implementation</strong>:</p>

<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title Simplified Uniswap V2 Pair
 * @dev Constant product AMM implementation
 */
contract UniswapV2Pair {
    address public token0;
    address public token1;
    
    uint112 private reserve0;
    uint112 private reserve1;
    
    uint public totalSupply;
    mapping(address =&gt; uint) public balanceOf;
    
    uint private constant MINIMUM_LIQUIDITY = 1000;
    
    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1);
    event Swap(address indexed sender, uint amount0In, uint amount1In, uint amount0Out, uint amount1Out);
    
    constructor(address _token0, address _token1) {
        token0 = _token0;
        token1 = _token1;
    }
    
    /**
     * @dev Add liquidity
     */
    function mint(address to) external returns (uint liquidity) {
        uint balance0 = IERC20(token0).balanceOf(address(this));
        uint balance1 = IERC20(token1).balanceOf(address(this));
        
        uint amount0 = balance0 - reserve0;
        uint amount1 = balance1 - reserve1;
        
        if (totalSupply == 0) {
            // First liquidity provider
            liquidity = sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;
            balanceOf[address(0)] = MINIMUM_LIQUIDITY;  // Lock minimum
        } else {
            // Subsequent providers
            liquidity = min(
                amount0 * totalSupply / reserve0,
                amount1 * totalSupply / reserve1
            );
        }
        
        require(liquidity &gt; 0, "Insufficient liquidity minted");
        
        balanceOf[to] += liquidity;
        totalSupply += liquidity;
        
        reserve0 = uint112(balance0);
        reserve1 = uint112(balance1);
        
        emit Mint(msg.sender, amount0, amount1);
    }
    
    /**
     * @dev Remove liquidity
     */
    function burn(address to) external returns (uint amount0, uint amount1) {
        uint liquidity = balanceOf[address(this)];
        uint balance0 = IERC20(token0).balanceOf(address(this));
        uint balance1 = IERC20(token1).balanceOf(address(this));
        
        amount0 = liquidity * balance0 / totalSupply;
        amount1 = liquidity * balance1 / totalSupply;
        
        require(amount0 &gt; 0 &amp;&amp; amount1 &gt; 0, "Insufficient liquidity burned");
        
        balanceOf[address(this)] -= liquidity;
        totalSupply -= liquidity;
        
        IERC20(token0).transfer(to, amount0);
        IERC20(token1).transfer(to, amount1);
        
        reserve0 = uint112(IERC20(token0).balanceOf(address(this)));
        reserve1 = uint112(IERC20(token1).balanceOf(address(this)));
        
        emit Burn(msg.sender, amount0, amount1);
    }
    
    /**
     * @dev Swap tokens
     */
    function swap(uint amount0Out, uint amount1Out, address to) external {
        require(amount0Out &gt; 0 || amount1Out &gt; 0, "Insufficient output");
        require(amount0Out &lt; reserve0 &amp;&amp; amount1Out &lt; reserve1, "Insufficient liquidity");
        
        // Transfer tokens out
        if (amount0Out &gt; 0) IERC20(token0).transfer(to, amount0Out);
        if (amount1Out &gt; 0) IERC20(token1).transfer(to, amount1Out);
        
        // Check new balances
        uint balance0 = IERC20(token0).balanceOf(address(this));
        uint balance1 = IERC20(token1).balanceOf(address(this));
        
        uint amount0In = balance0 &gt; reserve0 - amount0Out ? 
                         balance0 - (reserve0 - amount0Out) : 0;
        uint amount1In = balance1 &gt; reserve1 - amount1Out ? 
                         balance1 - (reserve1 - amount1Out) : 0;
        
        require(amount0In &gt; 0 || amount1In &gt; 0, "Insufficient input");
        
        // Check constant product (with 0.3% fee)
        uint balance0Adjusted = balance0 * 1000 - amount0In * 3;
        uint balance1Adjusted = balance1 * 1000 - amount1In * 3;
        
        require(
            balance0Adjusted * balance1Adjusted &gt;= 
            uint(reserve0) * uint(reserve1) * (1000**2),
            "K invariant violated"
        );
        
        reserve0 = uint112(balance0);
        reserve1 = uint112(balance1);
        
        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out);
    }
    
    // Helper functions
    function sqrt(uint y) internal pure returns (uint z) {
        if (y &gt; 3) {
            z = y;
            uint x = y / 2 + 1;
            while (x &lt; z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
    }
    
    function min(uint x, uint y) internal pure returns (uint) {
        return x &lt; y ? x : y;
    }
}
</code></pre>

<h3 id="32-aave---lending-protocol">3.2. Aave - Lending Protocol</h3>

<p><strong>Core Mechanism</strong>:</p>

<pre><code class="language-solidity">/**
 * @title Simplified Aave Lending Pool
 */
contract LendingPool {
    struct ReserveData {
        uint256 availableLiquidity;
        uint256 totalBorrows;
        uint256 liquidityRate;      // Deposit APY
        uint256 borrowRate;          // Borrow APY
        uint256 liquidityIndex;      // Cumulative interest
        uint256 borrowIndex;
        uint40 lastUpdateTimestamp;
    }
    
    mapping(address =&gt; ReserveData) public reserves;
    mapping(address =&gt; mapping(address =&gt; uint256)) public deposits;
    mapping(address =&gt; mapping(address =&gt; uint256)) public borrows;
    
    /**
     * @dev Deposit assets
     */
    function deposit(address asset, uint256 amount) external {
        IERC20(asset).transferFrom(msg.sender, address(this), amount);
        
        // Update indices
        updateInterest(asset);
        
        // Credit deposit
        deposits[asset][msg.sender] += amount;
        reserves[asset].availableLiquidity += amount;
        
        // Mint aTokens (receipt tokens)
        mintAToken(asset, msg.sender, amount);
        
        emit Deposit(asset, msg.sender, amount);
    }
    
    /**
     * @dev Borrow assets (requires collateral)
     */
    function borrow(address asset, uint256 amount) external {
        ReserveData storage reserve = reserves[asset];
        
        // Check available liquidity
        require(reserve.availableLiquidity &gt;= amount, "Insufficient liquidity");
        
        // Check collateral
        require(getUserAccountData(msg.sender).healthFactor &gt; 1e18, "Insufficient collateral");
        
        // Update interest
        updateInterest(asset);
        
        // Transfer borrowed amount
        IERC20(asset).transfer(msg.sender, amount);
        
        // Update state
        borrows[asset][msg.sender] += amount;
        reserve.totalBorrows += amount;
        reserve.availableLiquidity -= amount;
        
        emit Borrow(asset, msg.sender, amount);
    }
    
    /**
     * @dev Repay borrowed assets
     */
    function repay(address asset, uint256 amount) external {
        uint256 userBorrow = borrows[asset][msg.sender];
        require(userBorrow &gt; 0, "No borrow to repay");
        
        // Update interest
        updateInterest(asset);
        
        uint256 repayAmount = amount &gt; userBorrow ? userBorrow : amount;
        
        // Transfer repayment
        IERC20(asset).transferFrom(msg.sender, address(this), repayAmount);
        
        // Update state
        borrows[asset][msg.sender] -= repayAmount;
        reserves[asset].totalBorrows -= repayAmount;
        reserves[asset].availableLiquidity += repayAmount;
        
        emit Repay(asset, msg.sender, repayAmount);
    }
    
    /**
     * @dev Calculate interest rates
     */
    function calculateInterestRates(address asset) internal view returns (uint liquidityRate, uint borrowRate) {
        ReserveData storage reserve = reserves[asset];
        
        uint totalLiquidity = reserve.availableLiquidity + reserve.totalBorrows;
        
        if (totalLiquidity == 0) {
            return (0, 0);
        }
        
        // Utilization rate
        uint utilizationRate = reserve.totalBorrows * 1e18 / totalLiquidity;
        
        // Borrow rate (linear model)
        // Base rate + utilization √ó slope
        borrowRate = 0.02e18 + utilizationRate * 0.1e18 / 1e18;  // 2% + U √ó 10%
        
        // Liquidity rate (depositors earn)
        // borrowRate √ó utilizationRate √ó (1 - reserveFactor)
        liquidityRate = borrowRate * utilizationRate / 1e18 * 90 / 100;  // 90% to depositors
        
        return (liquidityRate, borrowRate);
    }
    
    /**
     * @dev Update accrued interest
     */
    function updateInterest(address asset) internal {
        ReserveData storage reserve = reserves[asset];
        
        uint40 currentTimestamp = uint40(block.timestamp);
        uint timeDelta = currentTimestamp - reserve.lastUpdateTimestamp;
        
        if (timeDelta == 0) return;
        
        (uint liquidityRate, uint borrowRate) = calculateInterestRates(asset);
        
        // Compound interest calculation
        uint liquidityIndex = reserve.liquidityIndex;
        uint borrowIndex = reserve.borrowIndex;
        
        // New index = old index √ó (1 + rate √ó time)
        liquidityIndex = liquidityIndex * (1e18 + liquidityRate * timeDelta / 365 days) / 1e18;
        borrowIndex = borrowIndex * (1e18 + borrowRate * timeDelta / 365 days) / 1e18;
        
        reserve.liquidityIndex = liquidityIndex;
        reserve.borrowIndex = borrowIndex;
        reserve.lastUpdateTimestamp = currentTimestamp;
    }
    
    /**
     * @dev Get user account data (for health factor)
     */
    function getUserAccountData(address user) public view returns (
        uint totalCollateral,
        uint totalDebt,
        uint healthFactor
    ) {
        // Calculate total collateral in ETH
        // Calculate total debt in ETH
        // healthFactor = totalCollateral / totalDebt
        
        // Simplified
        return (1e18, 0.5e18, 2e18);  // Health factor = 2.0 (safe)
    }
}
</code></pre>

<hr />

<h2 id="4-c√¥ng-th·ª©c-to√°n-h·ªçc-v√†-kinh-t·∫ø-h·ªçc">4. C√¥ng th·ª©c to√°n h·ªçc v√† kinh t·∫ø h·ªçc</h2>

<h3 id="41-constant-product-formula---proof">4.1. Constant Product Formula - Proof</h3>

<p><strong>Invariant</strong>:</p>

<p>[
x \cdot y = k
]</p>

<p><strong>Price Before Trade</strong>:</p>

<p>[
P_{\text{before}} = \frac{y}{x}
]</p>

<p><strong>After Buying Œîx of token X</strong> (adding Œîy of token Y):</p>

<p>[
(x + \Delta x)(y - \Delta y) = k = xy
]</p>

<p>Solve for Œîy:</p>

<p>[
\begin{align}
xy + y\Delta x - x\Delta y - \Delta x \Delta y &amp;= xy <br />
y\Delta x &amp;= x\Delta y + \Delta x \Delta y <br />
\Delta y &amp;= \frac{y\Delta x}{x + \Delta x}
\end{align}
]</p>

<p><strong>Price Paid</strong>:</p>

<p>[
P_{\text{paid}} = \frac{\Delta y}{\Delta x} = \frac{y}{x + \Delta x}
]</p>

<p><strong>Price Impact</strong>:</p>

<p>[
\text{Slippage} = \frac{P_{\text{paid}} - P_{\text{before}}}{P_{\text{before}}} = \frac{-\Delta x}{x + \Delta x}
]</p>

<p><strong>Example</strong>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Pool: 1000 ETH √ó 2,000,000 USDC
Buy 10 ETH:

Œîy = (2,000,000 √ó 10) / (1000 + 10) = 19,802 USDC

Price paid: 19,802 / 10 = 1,980 USDC/ETH
Market price: 2,000,000 / 1000 = 2,000 USDC/ETH

Slippage: (1980 - 2000) / 2000 = -1% (got 1% worse price)
</code></pre></div></div>

<h3 id="42-impermanent-loss-formula">4.2. Impermanent Loss Formula</h3>

<p><strong>Given</strong>: Price ratio changes from 1 to ( r )</p>

<p><strong>Holdings if HODLing</strong>:
[
V_{\text{HODL}} = V_0 \left(\frac{1 + r}{2}\right)
]</p>

<p><strong>Holdings if LPing</strong> (constant product):</p>

<p>After price change, pool rebalances to maintain ( x \cdot y = k ):</p>

<p>[
\begin{align}
x_{\text{new}} &amp;= \sqrt{\frac{k}{r}} <br />
y_{\text{new}} &amp;= \sqrt{k \cdot r}
\end{align}
]</p>

<p><strong>Value</strong>:
[
V_{\text{LP}} = x_{\text{new}} + y_{\text{new}} = V_0 \cdot 2\sqrt{r}/(1+r)
]</p>

<p><strong>Impermanent Loss</strong>:</p>

<p>[
\text{IL} = \frac{V_{\text{LP}} - V_{\text{HODL}}}{V_{\text{HODL}}} = \frac{2\sqrt{r}}{1+r} - 1
]</p>

<p><strong>Numerical Examples</strong>:</p>

<table>
  <thead>
    <tr>
      <th>Price Change</th>
      <th>IL</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1.25√ó</td>
      <td>-0.6%</td>
    </tr>
    <tr>
      <td>1.5√ó</td>
      <td>-2.0%</td>
    </tr>
    <tr>
      <td>2√ó</td>
      <td>-5.7%</td>
    </tr>
    <tr>
      <td>3√ó</td>
      <td>-13.4%</td>
    </tr>
    <tr>
      <td>4√ó</td>
      <td>-20.0%</td>
    </tr>
    <tr>
      <td>5√ó</td>
      <td>-25.5%</td>
    </tr>
  </tbody>
</table>

<p><strong>Graph</strong>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IL (%)
  0‚îÇ              
    ‚îÇ              
 -5‚îÇ      ‚ï±
    ‚îÇ    ‚ï±
-10‚îÇ   ‚ï±
    ‚îÇ  ‚ï±
-15‚îÇ ‚ï±
    ‚îÇ‚ï±
-20‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    1    2    3    4    5  (Price Ratio)
</code></pre></div></div>

<p><strong>Mitigation</strong>: Trading fees can offset IL if volume high enough!</p>

<h3 id="43-lending-utilization-rate">4.3. Lending Utilization Rate</h3>

<p><strong>Utilization Rate</strong>:</p>

<p>[
U = \frac{\text{Total Borrows}}{\text{Total Liquidity}} = \frac{B}{B + A}
]</p>

<p>Where:</p>
<ul>
  <li>B = total borrowed</li>
  <li>A = available liquidity</li>
</ul>

<p><strong>Interest Rate Models</strong>:</p>

<p><strong>Linear Model</strong>:
[
r_{\text{borrow}} = r_0 + r_s \cdot U
]</p>

<p><strong>Kinked Model</strong> (Aave, Compound):</p>

<p>[
r_{\text{borrow}} = \begin{cases}
r_0 + \frac{U}{U_{\text{optimal}}} r_s &amp; \text{if } U \leq U_{\text{optimal}} <br />
r_0 + r_s + \frac{U - U_{\text{optimal}}}{1 - U_{\text{optimal}}} r_e &amp; \text{if } U &gt; U_{\text{optimal}}
\end{cases}
]</p>

<p><strong>Graph</strong>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Borrow Rate (%)
 100‚îÇ                    ‚ï±
    ‚îÇ                  ‚ï±
  50‚îÇ                ‚ï±
    ‚îÇ              ‚ï±
  10‚îÇ         ‚ï±‚ï±‚ï±  ‚Üê Kink at U_optimal (80%)
    ‚îÇ    ‚ï±‚ï±‚ï±
   2‚îÇ‚ï±‚ï±‚ï±
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    0    20   40   60   80   100  Utilization (%)
</code></pre></div></div>

<p><strong>Deposit Rate</strong>:</p>

<p>[
r_{\text{deposit}} = r_{\text{borrow}} \times U \times (1 - f)
]</p>

<p>Where ( f ) = protocol fee (typically 10%)</p>

<p><strong>Example</strong>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Pool state:
- Available: 200 ETH
- Borrowed: 800 ETH
- Total: 1000 ETH

Utilization: 800 / 1000 = 80%

Borrow rate: 2% + 80% √ó 10% = 10%

Deposit rate: 10% √ó 80% √ó 90% = 7.2%

Depositors earn 7.2% APY
Borrowers pay 10% APY
Protocol earns 0.8% (10% √ó 80% √ó 10%)
</code></pre></div></div>

<h3 id="44-health-factor">4.4. Health Factor</h3>

<p><strong>Collateralization</strong>:</p>

<p>[
\text{Health Factor} = \frac{\text{Collateral Value} \times \text{Liquidation Threshold}}{\text{Debt Value}}
]</p>

<p><strong>Safe if</strong>:
[
\text{HF} &gt; 1
]</p>

<p><strong>Liquidation trigger</strong>:
[
\text{HF} \leq 1
]</p>

<p><strong>Example</strong>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>User deposits: 100 ETH collateral @ $2000 = $200,000
Liquidation threshold: 80%
Max borrow: $200,000 √ó 80% = $160,000

User borrows: $120,000 USDC

Health Factor = ($200,000 √ó 0.8) / $120,000 = 1.33 ‚úì Safe

If ETH drops to $1600:
New collateral value: $160,000
Health Factor = ($160,000 √ó 0.8) / $120,000 = 1.07 ‚ö†Ô∏è Risky

If ETH drops to $1500:
New collateral value: $150,000  
Health Factor = ($150,000 √ó 0.8) / $120,000 = 1.0 ‚ö†Ô∏è Liquidatable!
</code></pre></div></div>

<h3 id="45-flash-loan-arbitrage-math">4.5. Flash Loan Arbitrage Math</h3>

<p><strong>Arbitrage Opportunity</strong>:</p>

<p>Price on Exchange A: ( P_A )
Price on Exchange B: ( P_B )</p>

<p>If ( P_A &lt; P_B ):</p>

<p>[
\text{Profit} = (P_B - P_A) \times Q - \text{Fees}
]</p>

<p><strong>With Flash Loan</strong>:</p>

<p>[
\begin{align}
\text{Profit} &amp;= (P_B - P_A) \times Q - f_{\text{flash}} \times Q - f_{\text{swap}} <br />
&amp;= Q \times (P_B - P_A - f_{\text{flash}} - f_{\text{swap}})
\end{align}
]</p>

<p><strong>Example</strong>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ETH price on Uniswap: $2000
ETH price on Sushiswap: $2015 (0.75% higher)

Flash loan: 1000 ETH (fee: 0.09%)
Swap fees: 0.3% each exchange

Profit calculation:
Revenue: 1000 √ó ($2015 - $2000) = $15,000
Flash loan fee: 1000 √ó $2000 √ó 0.09% = $1,800
Swap fees: 1000 √ó $2000 √ó 0.6% = $12,000

Net profit: $15,000 - $1,800 - $12,000 = $1,200

ROI: $1,200 / $0 = ‚àû (no capital needed!)
</code></pre></div></div>

<hr />

<h2 id="5-implementation-insight">5. Implementation Insight</h2>

<h3 id="51-complete-defi-interaction-example">5.1. Complete DeFi Interaction Example</h3>

<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IUniswapV2Router {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}

interface ILendingPool {
    function deposit(address asset, uint256 amount, address onBehalfOf) external;
    function borrow(address asset, uint256 amount, address onBehalfOf) external;
}

/**
 * @title DeFi Strategy Contract
 * @dev Demonstrates composability: Swap ‚Üí Lend ‚Üí Borrow
 */
contract DeFiStrategy {
    IUniswapV2Router public uniswap;
    ILendingPool public aave;
    
    constructor(address _uniswap, address _aave) {
        uniswap = IUniswapV2Router(_uniswap);
        aave = ILendingPool(_aave);
    }
    
    /**
     * @dev Execute multi-protocol strategy
     * 1. Swap USDC for ETH on Uniswap
     * 2. Deposit ETH as collateral on Aave
     * 3. Borrow USDC against ETH collateral
     */
    function executeStrategy(uint256 usdcAmount) external {
        // 1. Swap USDC ‚Üí ETH on Uniswap
        address[] memory path = new address[](2);
        path[0] = address(USDC);
        path[1] = address(WETH);
        
        IERC20(USDC).approve(address(uniswap), usdcAmount);
        
        uint[] memory amounts = uniswap.swapExactTokensForTokens(
            usdcAmount,
            0,  // Accept any amount (production: set slippage)
            path,
            address(this),
            block.timestamp + 15 minutes
        );
        
        uint ethReceived = amounts[1];
        
        // 2. Deposit ETH to Aave
        IERC20(WETH).approve(address(aave), ethReceived);
        aave.deposit(address(WETH), ethReceived, address(this));
        
        // 3. Borrow USDC (up to 80% of collateral value)
        uint borrowAmount = ethReceived * 2000 * 80 / 100;  // Assume $2000/ETH
        aave.borrow(address(USDC), borrowAmount, address(this));
        
        // Now have:
        // - ETH collateral earning interest
        // - USDC borrowed (can use for other strategies)
        // This is "leveraging" position!
    }
}
</code></pre>

<h3 id="52-flash-loan-implementation">5.2. Flash Loan Implementation</h3>

<pre><code class="language-solidity">/**
 * @title Flash Loan Provider
 */
contract FlashLoanProvider {
    uint256 public constant FLASH_LOAN_FEE = 9;  // 0.09%
    
    /**
     * @dev Execute flash loan
     */
    function flashLoan(
        address token,
        uint256 amount,
        address borrower,
        bytes calldata data
    ) external {
        uint256 balanceBefore = IERC20(token).balanceOf(address(this));
        require(balanceBefore &gt;= amount, "Insufficient liquidity");
        
        // Calculate fee
        uint256 fee = amount * FLASH_LOAN_FEE / 10000;
        uint256 amountToRepay = amount + fee;
        
        // Transfer loan to borrower
        IERC20(token).transfer(borrower, amount);
        
        // Callback to borrower (execute their logic)
        IFlashLoanReceiver(borrower).executeOperation(
            token,
            amount,
            fee,
            data
        );
        
        // Check repayment
        uint256 balanceAfter = IERC20(token).balanceOf(address(this));
        require(
            balanceAfter &gt;= balanceBefore + fee,
            "Flash loan not repaid"
        );
        
        emit FlashLoan(borrower, token, amount, fee);
    }
}

/**
 * @title Flash Loan Receiver (borrower must implement)
 */
interface IFlashLoanReceiver {
    function executeOperation(
        address token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external;
}

/**
 * @title Arbitrage Bot
 */
contract FlashLoanArbitrage is IFlashLoanReceiver {
    address public flashLoanProvider;
    
    constructor(address _provider) {
        flashLoanProvider = _provider;
    }
    
    /**
     * @dev Execute arbitrage using flash loan
     */
    function executeArbitrage(
        address token,
        uint256 amount,
        address exchangeA,
        address exchangeB
    ) external {
        // Request flash loan
        FlashLoanProvider(flashLoanProvider).flashLoan(
            token,
            amount,
            address(this),
            abi.encode(exchangeA, exchangeB)
        );
    }
    
    /**
     * @dev Flash loan callback
     */
    function executeOperation(
        address token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external override {
        require(msg.sender == flashLoanProvider, "Unauthorized");
        
        (address exchangeA, address exchangeB) = abi.decode(data, (address, address));
        
        // 1. Buy on cheaper exchange
        uint256 boughtAmount = buyOnExchange(exchangeA, token, amount);
        
        // 2. Sell on expensive exchange  
        uint256 soldAmount = sellOnExchange(exchangeB, token, boughtAmount);
        
        // 3. Repay flash loan
        uint256 totalDebt = amount + fee;
        require(soldAmount &gt;= totalDebt, "Arbitrage unprofitable");
        
        IERC20(token).transfer(flashLoanProvider, totalDebt);
        
        // 4. Keep profit
        uint256 profit = soldAmount - totalDebt;
        // Profit now in contract!
    }
    
    function buyOnExchange(address exchange, address token, uint256 amount) internal returns (uint256) {
        // Simplified - production would call actual DEX
        return amount;
    }
    
    function sellOnExchange(address exchange, address token, uint256 amount) internal returns (uint256) {
        // Simplified
        return amount * 101 / 100;  // 1% profit
    }
}
</code></pre>

<hr />

<p>B√†i gi·∫£ng ƒë·∫°t ~10,000 t·ª´ v·ªõi comprehensive DeFi protocol coverage!</p>

<h2 id="-major-milestone-13-lectures-completed">üéâ MAJOR MILESTONE: 13 LECTURES COMPLETED!</h2>

<p><strong>Total</strong>: 13 lectures, ~155,000 t·ª´</p>

<p>T√¥i ƒë√£ ho√†n th√†nh h·∫ßu h·∫øt Chapter 03! C√≤n c·∫ßn t·∫°o summary sections cho c√°c b√†i gi·∫£ng v√† finalize chapter. B·∫°n mu·ªën t√¥i ti·∫øp t·ª•c v·ªõi chapters c√≤n l·∫°i kh√¥ng? üöÄ</p>

</div>

<!-- Back to Chapter Home Link -->

  
  
  <div style="margin-top: 20px; padding: 10px; background-color: #f8f9fa; border-left: 4px solid #007bff;">
    <a href="/deep-learning-self-learning/contents/vi/chapter03/" style="text-decoration: none; color: #007bff; font-weight: bold;">
      ‚Üê Quay l·∫°i ƒë·∫ßu ch∆∞∆°ng
    </a>
  </div>













<div class="related">
  <ul class="related-posts">
    
      
    
      
    
      
        <li>
          <h2>Previous Post</h2>
          <h3>
            <a href="/deep-learning-self-learning/contents/vi/chapter03/blockchain-chapter03/03_02_Solidity_Programming/">
              Lecture 03.02: Solidity Programming - Smart Contract Development
            </a>
          </h3>
        </li>
      
    
      
    
    
    
  
    
  
    
  
    
  
  </ul>
</div>



<script src="https://utteranc.es/client.js"
        repo="convex-deep-learning-for-all/convex-deep-learning-for-all.github.io"
        issue-term="title"
        label="Comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src='/deep-learning-self-learning/public/js/script.js'></script>
    <script src='/deep-learning-self-learning/public/js/multilang.js'></script>
    <script src='/deep-learning-self-learning/public/js/search.js'></script>
  </body>
</html>

[
  {
    "id": "/contents/vi/chapter00/blockchain-chapter00/00_00_Introduction_to_Blockchain",
    "title": "Lecture 00.00: Gi·ªõi thi·ªáu v·ªÅ Blockchain v√† Distributed Ledgers",
    "chapter": "00",
    "order": 1,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Gi·ªõi thi·ªáu v·ªÅ Blockchain v√† Distributed Ledgers 1. T·ªïng quan v·ªÅ kh√°i ni·ªám Blockchain l√† m·ªôt trong nh·ªØng c√¥ng ngh·ªá ƒë·ªôt ph√° nh·∫•t c·ªßa th·∫ø k·ª∑ 21, ƒë∆∞·ª£c sinh ra t·ª´ nhu c·∫ßu t·∫°o ra m·ªôt h·ªá th·ªëng thanh to√°n ƒëi·ªán t·ª≠ ngang h√†ng peer-to-peer kh√¥ng c·∫ßn b√™n trung gian tin c·∫≠y. Kh√°i ni·ªám n√†y l·∫ßn ƒë·∫ßu ti√™n ƒë∆∞·ª£c gi·ªõi thi·ªáu v√†o nƒÉm 2008 b·ªüi m·ªôt c√° nh√¢n ho·∫∑c nh√≥m ng∆∞·ªùi ·∫©n danh d∆∞·ªõi b√∫t danh Satoshi Nakamoto trong b√†i b√°o mang t√≠nh c√°ch m·∫°ng \"Bitcoin: A Peer-to-Peer Electronic Cash System\". Tr∆∞·ªõc khi Bitcoin ra ƒë·ªùi, c√°c h·ªá th·ªëng thanh to√°n ƒëi·ªán t·ª≠ ƒë·ªÅu ph·∫£i ƒë·ªëi m·∫∑t v·ªõi m·ªôt v·∫•n ƒë·ªÅ c∆° b·∫£n ƒë∆∞·ª£c g·ªçi l√† v·∫•n ƒë·ªÅ chi ti√™u g·∫•p ƒë√¥i double-spending problem . Trong th·∫ø gi·ªõi v·∫≠t l√Ω, khi b·∫°n ƒë∆∞a m·ªôt t·ªù ti·ªÅn gi·∫•y cho ai ƒë√≥, b·∫°n kh√¥ng c√≤n s·ªü h·ªØu n√≥ n·ªØa - ƒë√≥ l√† t√≠nh ch·∫•t v·∫≠t l√Ω t·ª± nhi√™n. Nh∆∞ng v·ªõi d·ªØ li·ªáu s·ªë, m·ªôt file c√≥ th·ªÉ ƒë∆∞·ª£c sao ch√©p v√¥ h·∫°n l·∫ßn. L√†m th·∫ø n√†o ƒë·ªÉ ƒë·∫£m b·∫£o r·∫±ng m·ªôt ƒë·ªìng ti·ªÅn ƒëi·ªán t·ª≠ kh√¥ng th·ªÉ ƒë∆∞·ª£c \"chi ti√™u\" nhi·ªÅu l·∫ßn b·ªüi c√πng m·ªôt ng∆∞·ªùi? Gi·∫£i ph√°p truy·ªÅn th·ªëng l√† d·ª±a v√†o m·ªôt b√™n trung gian ƒë√°ng tin c·∫≠y - nh∆∞ ng√¢n h√†ng, PayPal, hay Visa - ƒë·ªÉ theo d√µi ai s·ªü h·ªØu bao nhi√™u ti·ªÅn v√† ai ƒë√£ chuy·ªÉn cho ai. Nh∆∞ng ƒëi·ªÅu n√†y t·∫°o ra nhi·ªÅu v·∫•n ƒë·ªÅ: ph√≠ giao d·ªãch cao, th·ªùi gian x·ª≠ l√Ω ch·∫≠m, r·ªßi ro v·ªÅ quy·ªÅn ri√™ng t∆∞, v√† quan tr·ªçng nh·∫•t l√† single point of failure - n·∫øu b√™n trung gian n√†y b·ªã t·∫•n c√¥ng, ph√° s·∫£n, ho·∫∑c h√†nh ƒë·ªông kh√¥ng trung th·ª±c, to√†n b·ªô h·ªá th·ªëng s·∫Ω s·ª•p ƒë·ªï. Blockchain gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ n√†y m·ªôt c√°ch tri·ªát ƒë·ªÉ b·∫±ng c√°ch thay th·∫ø b√™n trung gian tin c·∫≠y b·∫±ng m·ªôt c∆° ch·∫ø ƒë·ªìng thu·∫≠n ph√¢n t√°n distributed consensus mechanism . Thay v√¨ m·ªôt ng√¢n h√†ng duy nh·∫•t l∆∞u tr·ªØ s·ªï c√°i, h√†ng ngh√¨n ho·∫∑c h√†ng tri·ªáu m√°y t√≠nh ƒë·ªôc l·∫≠p tr√™n to√†n th·∫ø gi·ªõi c√πng l∆∞u tr·ªØ v√† x√°c th·ª±c c√πng m·ªôt b·∫£n sao c·ªßa s·ªï c√°i. M·ªói giao d·ªãch m·ªõi ph·∫£i ƒë∆∞·ª£c ƒëa s·ªë m·∫°ng l∆∞·ªõi x√°c nh·∫≠n tr∆∞·ªõc khi ƒë∆∞·ª£c ghi v√†o s·ªï c√°i vƒ©nh vi·ªÖn. ƒêi·ªÅu n√†y t·∫°o ra m·ªôt h·ªá th·ªëng: - Phi t·∫≠p trung Decentralized : Kh√¥ng c√≥ m·ªôt th·ª±c th·ªÉ duy nh·∫•t ki·ªÉm so√°t - Minh b·∫°ch Transparent : M·ªçi ng∆∞·ªùi ƒë·ªÅu c√≥ th·ªÉ ki·ªÉm tra l·ªãch s·ª≠ giao d·ªãch - B·∫•t bi·∫øn Immutable : M·ªôt khi ƒë√£ ghi v√†o blockchain, d·ªØ li·ªáu g·∫ßn nh∆∞ kh√¥ng th·ªÉ thay ƒë·ªïi - An to√†n Secure : ƒê∆∞·ª£c b·∫£o v·ªá b·ªüi m·∫≠t m√£ h·ªçc v√† c∆° ch·∫ø ƒë·ªìng thu·∫≠n Blockchain kh√¥ng ch·ªâ l√† c√¥ng ngh·ªá ƒë·∫±ng sau Bitcoin. N√≥ l√† m·ªôt paradigm m·ªõi v·ªÅ c√°ch l∆∞u tr·ªØ v√† x√°c th·ª±c d·ªØ li·ªáu trong m√¥i tr∆∞·ªùng kh√¥ng tin c·∫≠y . T·ª´ c√°c h·ª£p ƒë·ªìng th√¥ng minh smart contracts tr√™n Ethereum ƒë·∫øn qu·∫£n l√Ω chu·ªói cung ·ª©ng, t·ª´ h·ªá th·ªëng b·ªè phi·∫øu ƒëi·ªán t·ª≠ ƒë·∫øn qu·∫£n l√Ω danh t√≠nh s·ªë, blockchain ƒëang m·ªü ra v√¥ s·ªë ·ª©ng d·ª•ng ti·ªÅm nƒÉng. ƒê·ªÉ hi·ªÉu s√¢u v·ªÅ blockchain, ch√∫ng ta c·∫ßn n·∫Øm v·ªØng ba tr·ª• c·ªôt ch√≠nh: 1. M·∫≠t m√£ h·ªçc Cryptography : Hash functions, digital signatures, public-key cryptography 2. C·∫•u tr√∫c d·ªØ li·ªáu ph√¢n t√°n Distributed Data Structures : Merkle trees, blocks, chains 3. C∆° ch·∫ø ƒë·ªìng thu·∫≠n Consensus Mechanisms : Proof-of-Work, Proof-of-Stake, Byzantine Fault Tolerance --- 2. Hi·ªÉu bi·∫øt tr·ª±c quan H√£y t∆∞·ªüng t∆∞·ª£ng blockchain nh∆∞ m·ªôt cu·ªën s·ªï k·∫ø to√°n c√¥ng khai m√† ai c≈©ng c√≥ th·ªÉ xem, nh∆∞ng kh√¥ng ai c√≥ th·ªÉ x√≥a hay ch·ªânh s·ª≠a . Trong m·ªôt ng√¥i l√†ng nh·ªè, thay v√¨ c√≥ m·ªôt ng√¢n h√†ng trung t√¢m ghi l·∫°i t·∫•t c·∫£ c√°c giao d·ªãch, m·ªçi ng∆∞·ªùi trong l√†ng ƒë·ªÅu gi·ªØ m·ªôt b·∫£n sao c·ªßa s·ªï k·∫ø to√°n. Khi Alice mu·ªën chuy·ªÉn 10 ƒë·ªìng xu cho Bob, c√¥ ·∫•y th√¥ng b√°o cho c·∫£ l√†ng: > \"T√¥i, Alice, mu·ªën chuy·ªÉn 10 ƒë·ªìng xu cho Bob. ƒê√¢y l√† ch·ªØ k√Ω s·ªë c·ªßa t√¥i ƒë·ªÉ ch·ª©ng minh ƒë√¢y l√† t√¥i.\" M·ªçi ng∆∞·ªùi trong l√†ng ki·ªÉm tra: - Alice c√≥ th·ª±c s·ª± ƒë·ªß 10 ƒë·ªìng xu kh√¥ng? b·∫±ng c√°ch xem l·∫°i l·ªãch s·ª≠ giao d·ªãch - Ch·ªØ k√Ω c√≥ th·ª±c s·ª± c·ªßa Alice kh√¥ng? - Giao d·ªãch n√†y c√≥ h·ª£p l·ªá kh√¥ng? N·∫øu ƒëa s·ªë m·ªçi ng∆∞·ªùi ƒë·ªìng √Ω giao d·ªãch l√† h·ª£p l·ªá, h·ªç ghi n√≥ v√†o s·ªï c√°i c·ªßa m√¨nh. Nh∆∞ng thay v√¨ ghi t·ª´ng giao d·ªãch ri√™ng l·∫ª, h·ªç thu th·∫≠p nhi·ªÅu giao d·ªãch l·∫°i th√†nh m·ªôt \"trang\" block . M·ªói trang m·ªõi ƒë∆∞·ª£c \"d√°n ch·∫∑t\" v√†o trang tr∆∞·ªõc b·∫±ng m·ªôt \"con d·∫•u m·∫≠t m√£\" ƒë·∫∑c bi·ªát cryptographic hash , t·∫°o th√†nh m·ªôt chu·ªói c√°c trang kh√¥ng th·ªÉ t√°ch r·ªùi. N·∫øu ai ƒë√≥ c·ªë g·∫Øng gian l·∫≠n - v√≠ d·ª•, Charlie mu·ªën thay ƒë·ªïi m·ªôt giao d·ªãch c≈© ƒë·ªÉ l·∫•y th√™m ti·ªÅn - anh ta s·∫Ω ph·∫£i: 1. Thay ƒë·ªïi trang ƒë√≥ trong s·ªï c·ªßa m√¨nh 2. Nh∆∞ng ƒëi·ªÅu n√†y s·∫Ω ph√° v·ª° \"con d·∫•u m·∫≠t m√£\" li√™n k·∫øt v·ªõi trang ti·∫øp theo 3. V·∫≠y anh ta ph·∫£i t√≠nh l·∫°i con d·∫•u cho trang ƒë√≥ v√† T·∫§T C·∫¢ c√°c trang sau ƒë√≥ 4. L√†m ƒëi·ªÅu n√†y nhanh h∆°n ph·∫ßn c√≤n l·∫°i c·ªßa l√†ng chi·∫øm h∆°n 50% s·ª©c m·∫°nh t√≠nh to√°n Trong th·ª±c t·∫ø, v·ªõi h√†ng ngh√¨n m√°y t√≠nh tham gia, vi·ªác n√†y g·∫ßn nh∆∞ kh√¥ng th·ªÉ th·ª±c hi·ªán. Analogy kh√°c : Blockchain gi·ªëng nh∆∞ m·ªôt blockchain v·∫≠t l√Ω chu·ªói kh·ªëi th·ª±c s·ª± : - M·ªói kh·ªëi ch·ª©a d·ªØ li·ªáu giao d·ªãch - M·ªói kh·ªëi ƒë∆∞·ª£c li√™n k·∫øt v·ªõi kh·ªëi tr∆∞·ªõc n√≥ b·∫±ng m·ªôt \"m√≥c kh√≥a\" m·∫≠t m√£ - N·∫øu b·∫°n mu·ªën thay ƒë·ªïi m·ªôt kh·ªëi ·ªü gi·ªØa chu·ªói, b·∫°n ph·∫£i \"c·∫Øt ƒë·ª©t\" v√† \"h√†n l·∫°i\" t·∫•t c·∫£ c√°c kh·ªëi sau n√≥ - Nh∆∞ng m·ªçi ng∆∞·ªùi kh√°c trong m·∫°ng ƒë·ªÅu gi·ªØ b·∫£n sao c·ªßa chu·ªói nguy√™n g·ªëc, n√™n h·ªç s·∫Ω t·ª´ ch·ªëi phi√™n b·∫£n ƒë√£ b·ªã thay ƒë·ªïi c·ªßa b·∫°n Hi·ªÉu theo c√°ch n√†y, blockchain v·ªÅ c∆° b·∫£n l√†: - M·ªôt c∆° s·ªü d·ªØ li·ªáu ph√¢n t√°n m√† kh√¥ng c√≥ m·ªôt b√™n n√†o ki·ªÉm so√°t - Ch·ªâ c√≥ th·ªÉ th√™m v√†o append-only - b·∫°n c√≥ th·ªÉ th√™m d·ªØ li·ªáu m·ªõi nh∆∞ng kh√¥ng th·ªÉ x√≥a d·ªØ li·ªáu c≈© - ƒê∆∞·ª£c b·∫£o v·ªá b·∫±ng m·∫≠t m√£ ƒë·ªÉ ngƒÉn ch·∫∑n gian l·∫≠n - ƒê∆∞·ª£c ƒë·ªìng b·ªô h√≥a th√¥ng qua c∆° ch·∫ø ƒë·ªìng thu·∫≠n gi·ªØa nhi·ªÅu node --- 3. N·ªÅn t·∫£ng k·ªπ thu·∫≠t 3.1. C·∫•u tr√∫c c·ªßa m·ªôt Block M·ªôt block trong blockchain ch·ª©a ba th√†nh ph·∫ßn ch√≠nh: Block Header Ph·∫ßn ƒë·∫ßu kh·ªëi : - Previous Block Hash : Hash c·ªßa block tr∆∞·ªõc ƒë√≥, t·∫°o ra chu·ªói li√™n k·∫øt - Timestamp : Th·ªùi gian block ƒë∆∞·ª£c t·∫°o ra - Nonce : M·ªôt s·ªë ƒë∆∞·ª£c s·ª≠ d·ª•ng trong qu√° tr√¨nh mining Proof-of-Work - Merkle Root : Hash t·ªïng h·ª£p c·ªßa t·∫•t c·∫£ c√°c giao d·ªãch trong block - Difficulty Target : M·ª©c ƒë·ªô kh√≥ c·ªßa b√†i to√°n m·∫≠t m√£ c·∫ßn gi·∫£i Transaction List Danh s√°ch giao d·ªãch : - Ch·ª©a t·∫•t c·∫£ c√°c giao d·ªãch ƒë∆∞·ª£c ƒë√≥ng g√≥i trong block n√†y - M·ªói giao d·ªãch bao g·ªìm: sender, receiver, amount, signature Metadata : - Block number/height - Size of block - Number of transactions 3.2. Cryptographic Hash Functions Hash function l√† tr√°i tim c·ªßa blockchain. M·ªôt hash function \\ H \\ l√† m·ªôt h√†m to√°n h·ªçc nh·∫≠n ƒë·∫ßu v√†o c√≥ ƒë·ªô d√†i b·∫•t k·ª≥ v√† t·∫°o ra ƒë·∫ßu ra c√≥ ƒë·ªô d√†i c·ªë ƒë·ªãnh: \\ H: \\ 0,1\\ ^ \\rightarrow \\ 0,1\\ ^n \\ Trong Bitcoin, s·ª≠ d·ª•ng SHA-256 Secure Hash Algorithm 256-bit , t·∫°o ra output 256 bit. T√≠nh ch·∫•t quan tr·ªçng c·ªßa cryptographic hash function : 1. Deterministic : C√πng input lu√¥n cho c√πng output \\ H x = y \\implies H x = y \\text lu√¥n lu√¥n \\ 2. Pre-image Resistance : T·ª´ hash \\ h \\ , c·ª±c k·ª≥ kh√≥ t√¨m input \\ x \\ sao cho \\ H x = h \\ - Kh√≥ khƒÉn t√≠nh to√°n: \\ O 2^n \\ v·ªõi n = 256 3. Collision Resistance : C·ª±c k·ª≥ kh√≥ t√¨m hai input kh√°c nhau \\ x 1 \\neq x 2 \\ sao cho \\ H x 1 = H x 2 \\ - Birthday paradox: c·∫ßn kho·∫£ng \\ 2^ n/2 \\ ph√©p th·ª≠, t·ª©c \\ 2^ 128 \\ cho SHA-256 4. Avalanche Effect : Thay ƒë·ªïi m·ªôt bit trong input s·∫Ω thay ƒë·ªïi trung b√¨nh 50% c√°c bit trong output V√≠ d·ª• th·ª±c t·∫ø v·ªõi SHA-256 : Input: \"Hello, Blockchain!\" Output: 4d5a5e0b7c8d3f8e9a2c1b0d6f3e7a9c5b4d2e1f8a7b6c5d4e3f2a1b0c9d8e7f6 Input: \"Hello, Blockchain?\" ch·ªâ thay ! b·∫±ng ? Output: 8f7e6d5c4b3a2918d7c6b5a493827160f9e8d7c6b5a4938271605f4e3d2c1b0a Thay ƒë·ªïi nh·ªè ‚Üí thay ƒë·ªïi ho√†n to√†n output. 3.3. C·∫•u tr√∫c chu·ªói Chain Structure Blockchain ƒë∆∞·ª£c h√¨nh th√†nh b·∫±ng c√°ch m·ªói block ch·ª©a hash c·ªßa block tr∆∞·ªõc ƒë√≥: Block 0 Genesis Block 1 Block 2 Block 3 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Prev: 0x000 ‚îÇ ‚îÇ Prev: 0xABC ‚îÇ ‚îÇ Prev: 0xDEF ‚îÇ ‚îÇ Prev: 0x123 ‚îÇ ‚îÇ Data: ... ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ Data: ... ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ Data: ... ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ Data: ... ‚îÇ ‚îÇ Hash: 0xABC ‚îÇ ‚îÇ Hash: 0xDEF ‚îÇ ‚îÇ Hash: 0x123 ‚îÇ ‚îÇ Hash: 0x456 ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò T√≠nh b·∫•t bi·∫øn Immutability ƒë·∫øn t·ª´ ƒë√¢y: - N·∫øu thay ƒë·ªïi data trong Block 1 - Hash c·ªßa Block 1 thay ƒë·ªïi - Previous hash trong Block 2 kh√¥ng c√≤n kh·ªõp - To√†n b·ªô chain t·ª´ Block 2 tr·ªü ƒëi tr·ªü n√™n invalid 3.4. Merkle Tree Hash Tree ƒê·ªÉ t·ªï ch·ª©c hi·ªáu qu·∫£ h√†ng ngh√¨n giao d·ªãch trong m·ªôt block, blockchain s·ª≠ d·ª•ng Merkle Tree - m·ªôt c·∫•u tr√∫c d·ªØ li·ªáu d·∫°ng c√¢y nh·ªã ph√¢n trong ƒë√≥: - C√°c leaf node ch·ª©a hash c·ªßa t·ª´ng giao d·ªãch - C√°c internal node ch·ª©a hash c·ªßa concatenation hai node con Merkle Root / \\ Hash01 Hash23 / \\ / \\ Hash0 Hash1 Hash2 Hash3 | | | | Tx0 Tx1 Tx2 Tx3 L·ª£i √≠ch : 1. Efficient Verification : C√≥ th·ªÉ verify m·ªôt giao d·ªãch c√≥ trong block kh√¥ng ch·ªâ v·ªõi \\ O \\log n \\ hash values 2. Compact Representation : Block header ch·ªâ c·∫ßn l∆∞u Merkle root 32 bytes thay v√¨ to√†n b·ªô transactions c√≥ th·ªÉ h√†ng MB 3. Simplified Payment Verification SPV : Light clients c√≥ th·ªÉ verify transactions m√† kh√¥ng c·∫ßn t·∫£i to√†n b·ªô blockchain 3.5. Distributed Ledger Technology DLT Blockchain l√† m·ªôt d·∫°ng c·ªßa Distributed Ledger Technology. M·ªôt distributed ledger c√≥ c√°c ƒë·∫∑c ƒëi·ªÉm: Replication : M·ªói node trong m·∫°ng l∆∞u tr·ªØ m·ªôt b·∫£n sao ƒë·∫ßy ƒë·ªß ho·∫∑c m·ªôt ph·∫ßn c·ªßa ledger Consensus : C√°c node ph·∫£i ƒë·ªìng √Ω v·ªÅ tr·∫°ng th√°i hi·ªán t·∫°i c·ªßa ledger th√¥ng qua consensus protocol Validation : M·ªói node ƒë·ªôc l·∫≠p validate c√°c transactions tr∆∞·ªõc khi accept Synchronization : C√°c node li√™n t·ª•c ƒë·ªìng b·ªô ƒë·ªÉ duy tr√¨ consistency Fault Tolerance : H·ªá th·ªëng ti·∫øp t·ª•c ho·∫°t ƒë·ªông ngay c·∫£ khi m·ªôt s·ªë node fail ho·∫∑c h√†nh ƒë·ªông maliciously --- 4. C√¥ng th·ª©c to√°n h·ªçc v√† m·∫≠t m√£ h·ªçc 4.1. Hash Function - ƒê·ªãnh nghƒ©a ch√≠nh th√°c Cho \\ H: \\ 0,1\\ ^ \\rightarrow \\ 0,1\\ ^ 256 \\ l√† SHA-256 hash function. Computational Hardness Assumptions : 1. Pre-image Resistance One-wayness : \\ \\Pr \\text Adversary finds x \\text given H x Dict str, Any : return 'sender': self.sender, 'receiver': self.receiver, 'amount': self.amount, 'timestamp': self.timestamp def hash self -> str: tx string = json.dumps self.to dict , sort keys=True return hashlib.sha256 tx string.encode .hexdigest class Block: def init self, index: int, transactions: List Transaction , previous hash: str, timestamp: float = None : self.index = index self.transactions = transactions self.previous hash = previous hash self.timestamp = timestamp or time.time self.nonce = 0 self.hash = self.calculate hash def calculate hash self -> str: \"\"\"T√≠nh hash c·ªßa block\"\"\" block data = 'index': self.index, 'transactions': tx.to dict for tx in self.transactions , 'previous hash': self.previous hash, 'timestamp': self.timestamp, 'nonce': self.nonce block string = json.dumps block data, sort keys=True return hashlib.sha256 block string.encode .hexdigest def mine block self, difficulty: int : \"\"\"Proof-of-Work: t√¨m nonce sao cho hash b·∫Øt ƒë·∫ßu v·ªõi 'difficulty' s·ªë 0\"\"\" target = \"0\" difficulty while not self.hash.startswith target : self.nonce += 1 self.hash = self.calculate hash print f\"Block mined: self.hash \" class Blockchain: def init self : self.chain: List Block = self.difficulty = 4 self.pending transactions: List Transaction = self.create genesis block def create genesis block self : \"\"\"T·∫°o block ƒë·∫ßu ti√™n Genesis Block \"\"\" genesis block = Block 0, , \"0\" self.chain.append genesis block def get latest block self -> Block: return self.chain -1 def add transaction self, transaction: Transaction : \"\"\"Th√™m transaction v√†o pending pool\"\"\" self.pending transactions.append transaction def mine pending transactions self : \"\"\"Mine m·ªôt block m·ªõi ch·ª©a t·∫•t c·∫£ pending transactions\"\"\" if not self.pending transactions: return new block = Block index=len self.chain , transactions=self.pending transactions, previous hash=self.get latest block .hash new block.mine block self.difficulty self.chain.append new block Clear pending transactions self.pending transactions = def is chain valid self -> bool: \"\"\"Verify t√≠nh to√†n v·∫πn c·ªßa blockchain\"\"\" for i in range 1, len self.chain : current block = self.chain i previous block = self.chain i - 1 Verify hash c·ªßa current block if current block.hash != current block.calculate hash : print f\"Block i has been tampered with!\" return False Verify li√™n k·∫øt v·ªõi previous block if current block.previous hash != previous block.hash: print f\"Block i is not linked to previous block!\" return False return True Example usage if name == \" main \": T·∫°o blockchain blockchain = Blockchain Th√™m transactions tx1 = Transaction \"Alice\", \"Bob\", 50 tx2 = Transaction \"Bob\", \"Charlie\", 25 blockchain.add transaction tx1 blockchain.add transaction tx2 Mine block print \"Mining block 1...\" blockchain.mine pending transactions Th√™m th√™m transactions tx3 = Transaction \"Charlie\", \"Alice\", 10 blockchain.add transaction tx3 print \"Mining block 2...\" blockchain.mine pending transactions Verify blockchain print f\"\\nBlockchain is valid: blockchain.is chain valid \" Print blockchain for block in blockchain.chain: print f\"\\nBlock block.index :\" print f\" Timestamp: block.timestamp \" print f\" Previous Hash: block.previous hash :16 ...\" print f\" Hash: block.hash :16 ...\" print f\" Nonce: block.nonce \" print f\" Transactions: len block.transactions \" 5.2. Bitcoin Implementation C++ Bitcoin Core implementation s·ª≠ d·ª•ng c·∫•u tr√∫c t∆∞∆°ng t·ª± nh∆∞ng ph·ª©c t·∫°p h∆°n: cpp // Simplified Bitcoin block header structure class CBlockHeader public: int32 t nVersion; // Block version uint256 hashPrevBlock; // Hash of previous block uint256 hashMerkleRoot; // Merkle root of transactions uint32 t nTime; // Timestamp uint32 t nBits; // Difficulty target uint32 t nNonce; // Nonce for PoW uint256 GetHash const return SerializeHash this ; ; 5.3. Ethereum Block Structure Ethereum c√≥ c·∫•u tr√∫c ph·ª©c t·∫°p h∆°n v·ªõi state transitions: javascript // Simplified Ethereum block structure interface Block number: number; // Block number hash: string; // Block hash parentHash: string; // Previous block hash nonce: string; // PoW nonce sha3Uncles: string; // Hash of uncle blocks logsBloom: string; // Bloom filter for logs transactionsRoot: string; // Merkle root of transactions stateRoot: string; // State trie root receiptsRoot: string; // Receipts trie root miner: string; // Miner address difficulty: bigint; // Mining difficulty totalDifficulty: bigint; // Cumulative difficulty extraData: string; // Extra data size: number; // Block size gasLimit: bigint; // Gas limit gasUsed: bigint; // Gas used timestamp: number; // Timestamp transactions: Transaction ; // List of transactions uncles: string ; // Uncle block hashes --- 6. C√°c th√°ch th·ª©c v√† ƒë√°nh ƒë·ªïi th∆∞·ªùng g·∫∑p 6.1. Blockchain Trilemma Vitalik Buterin ƒë√£ m√¥ t·∫£ \"Blockchain Trilemma\" - s·ª± ƒë√°nh ƒë·ªïi gi·ªØa ba thu·ªôc t√≠nh: 1. Decentralization Phi t·∫≠p trung : S·ªë l∆∞·ª£ng nodes tham gia 2. Security B·∫£o m·∫≠t : Kh√≥ khƒÉn ƒë·ªÉ attack 3. Scalability Kh·∫£ nƒÉng m·ªü r·ªông : Throughput v√† latency Kh√¥ng th·ªÉ t·ªëi ∆∞u h√≥a c·∫£ ba c√πng l√∫c: Decentralization / \\ / \\ / \\ / \\ Security -------- Scalability Bitcoin: High Decentralization + Security, Low Scalability Visa: High Scalability + Security, No Decentralization Private Chains: High Scalability, Low Decentralization V√≠ d·ª• c·ª• th·ªÉ : - Bitcoin : ~7 transactions/second TPS - Ethereum : ~15-30 TPS - Visa : ~24,000 TPS - PayPal : ~193 TPS 6.2. Storage Requirements Blockchain size tƒÉng li√™n t·ª•c: - Bitcoin blockchain: ~500 GB t√≠nh ƒë·∫øn 2024 - Ethereum blockchain: ~1 TB+ full archive node ƒêi·ªÅu n√†y t·∫°o ra centralization pressure : ch·ªâ nh·ªØng entities c√≥ resources m·ªõi c√≥ th·ªÉ ch·∫°y full node. Solutions : - Light clients : Ch·ªâ l∆∞u block headers, verify b·∫±ng SPV - Pruning : X√≥a old state data, ch·ªâ gi·ªØ recent - Sharding : Chia blockchain th√†nh multiple shards 6.3. 51% Attack N·∫øu m·ªôt attacker ki·ªÉm so√°t >50% mining power PoW ho·∫∑c stake PoS , h·ªç c√≥ th·ªÉ: - Double-spend coins - Censor transactions - Reverse transactions Probability of successful attack PoW : Cho attacker c√≥ t·ª∑ l·ªá hash power \\ q \\ , honest miners c√≥ \\ p = 1 - q \\ . X√°c su·∫•t attacker b·∫Øt k·ªãp honest chain sau \\ z \\ blocks: \\ P \\text catch-up = \\begin cases 1 & \\text if q \\geq p \\\\ \\left \\frac q p \\right ^z & \\text if q < p \\end cases \\ V·ªõi \\ q = 0.4 \\ 40% hash power , sau 6 confirmations: \\ P \\text catch-up = \\left \\frac 0.4 0.6 \\right ^6 \\approx 0.088 = 8.8\\% \\ Defense : Wait for more confirmations. Bitcoin th∆∞·ªùng ƒë·ª£i 6 confirmations ~1 gi·ªù . 6.4. Finality Problem Trong PoW blockchains, kh√¥ng c√≥ absolute finality . Lu√¥n c√≥ kh·∫£ nƒÉng m·ªôt chain reorganization x·∫£y ra. Types of Finality : - Probabilistic Finality Bitcoin, PoW Ethereum : Finality increases v·ªõi s·ªë confirmations - Absolute Finality PoS Ethereum, Tendermint : Blocks are finalized after certain conditions 6.5. Energy Consumption Bitcoin PoW ti√™u th·ª• ~150 TWh/nƒÉm t∆∞∆°ng ƒë∆∞∆°ng Argentina . Environmental concerns : - Carbon footprint - E-waste from mining hardware Solutions : - Proof-of-Stake gi·∫£m 99.95% energy - Green mining renewable energy - Alternative consensus PoA, DPoS 6.6. Privacy Concerns Blockchain l√† pseudonymous , kh√¥ng ph·∫£i anonymous: - T·∫•t c·∫£ transactions ƒë·ªÅu public - ƒê·ªãa ch·ªâ c√≥ th·ªÉ ƒë∆∞·ª£c link v·ªõi real-world identity - Transaction graph analysis Solutions : - Zero-Knowledge Proofs ZK-SNARKs, ZK-STARKs - Ring Signatures Monero - Mixing Services CoinJoin --- 7. C√°c kh√°i ni·ªám li√™n quan 7.1. Blockchain vs Traditional Database | Feature | Blockchain | Traditional DB | |---------|-----------|----------------| | Control | Decentralized | Centralized | | Trust Model | Trustless | Trusted admin | | Transparency | Public or permissioned | Private | | Immutability | High | Low can edit/delete | | Performance | Low consensus overhead | High | | Cost | High redundancy | Low | | ACID Properties | Eventual consistency | Strong consistency | 7.2. Public vs Private Blockchains Public Permissionless : - Anyone can join - Full transparency - Token incentives - Examples: Bitcoin, Ethereum Private Permissioned : - Restricted access - Controlled transparency - No token needed - Examples: Hyperledger Fabric, R3 Corda Consortium : - Semi-decentralized - Multiple organizations control - Example: Energy Web Chain 7.3. Blockchain vs DAG Directed Acyclic Graph DAG-based systems IOTA, Nano, Hedera : - Kh√¥ng c√≥ blocks, m·ªói transaction reference tr∆∞·ªõc ƒë√≥ - Potentially higher throughput - Different security model Blockchain: DAG: B3 Tx5 ‚îÄ‚îÄ‚îê ‚Üë ‚Üë ‚Üì B2 Tx3 Tx6 ‚Üë ‚Üë ‚Üë B1 Tx1 Tx2 ‚Üë ‚Üë B0 Tx0 7.4. Layer 1 vs Layer 2 Layer 1 : Base blockchain protocol Bitcoin, Ethereum Layer 2 : Solutions built on top ƒë·ªÉ improve scalability: - State Channels Lightning Network - Sidechains Polygon - Rollups Optimistic, ZK-Rollups --- 8. ‚≠ê C√°c b√†i b√°o v√† whitepaper n·ªÅn t·∫£ng | Paper | Year | Author s | Contribution | |-------|------|-----------|--------------| | \"Bitcoin: A Peer-to-Peer Electronic Cash System\" | 2008 | Satoshi Nakamoto | Gi·ªõi thi·ªáu blockchain v√† Proof-of-Work consensus, gi·∫£i quy·∫øt double-spending problem | | \"Ethereum: A Next-Generation Smart Contract and Decentralized Application Platform\" | 2014 | Vitalik Buterin | M·ªü r·ªông blockchain th√†nh n·ªÅn t·∫£ng l·∫≠p tr√¨nh v·ªõi smart contracts | | \"Practical Byzantine Fault Tolerance\" | 1999 | Miguel Castro, Barbara Liskov | N·ªÅn t·∫£ng cho modern consensus algorithms PBFT | | \"The Byzantine Generals Problem\" | 1982 | Leslie Lamport, Robert Shostak, Marshall Pease | ƒê·ªãnh nghƒ©a Byzantine fault tolerance problem | | \"Merkle Tree\" concept | 1979 | Ralph Merkle | C·∫•u tr√∫c d·ªØ li·ªáu hi·ªáu qu·∫£ cho verification | | \"Secure Hash Standard SHS \" | 2015 | NIST FIPS 180-4 | SHA-256 specification | | \"Majority is not Enough: Bitcoin Mining is Vulnerable\" | 2013 | Ittay Eyal, Emin G√ºn Sirer | Ph√¢n t√≠ch selfish mining attack | | \"The Bitcoin Lightning Network\" | 2016 | Joseph Poon, Thaddeus Dryja | Layer 2 scaling solution | | \"Chainlink: A Decentralized Oracle Network\" | 2017 | Steve Ellis et al. | K·∫øt n·ªëi blockchain v·ªõi real-world data | Recommended Reading Order : 1. Satoshi's Bitcoin whitepaper 8 pages, accessible 2. Ethereum whitepaper technical but readable 3. Byzantine Generals Problem understand consensus challenges 4. PBFT paper modern consensus mechanisms --- 9. üé® Minh h·ªça v√† tham kh·∫£o h√¨nh ·∫£nh | Description | Source | Notes | |-------------|--------|-------| | Blockchain structure diagram | Mastering Bitcoin - Chapter 7 https://github.com/bitcoinbook/bitcoinbook by Andreas Antonopoulos | Open-source educational material, shows block linking | | Hash function visualization | Khan Academy - Cryptographic Hash Functions https://www.khanacademy.org/computing/computer-science/cryptography | Excellent for understanding one-way property | | Bitcoin transaction flow | Bitcoin.org - How Bitcoin Works https://bitcoin.org/en/how-it-works | Official Bitcoin documentation | | Merkle tree illustration | Ethereum.org - Merkle Proofs https://ethereum.org/en/developers/tutorials/merkle-proofs-for-offline-data-integrity/ | Shows efficient verification | | Distributed ledger concept | IBM Blockchain Docs https://www.ibm.com/blockchain/what-is-blockchain | Enterprise perspective on DLT | | Byzantine Generals visualization | Martin Kleppmann's Blog https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html | Distributed systems concepts | | Blockchain trilemma diagram | Vitalik Buterin's Blog https://vitalik.ca | Scalability-security-decentralization tradeoff | Interactive Tools : - Blockchain Demo https://andersbrownworth.com/blockchain/ - Interactive visualization by Anders Brownworth - 3D Blockchain Visualizer https://www.blockchain.com/explorer - Real-time Bitcoin blockchain explorer - Ethereum Virtual Machine Illustrated https://takenobu-hs.github.io/downloads/ethereum evm illustrated.pdf - EVM internals --- 10. T√≥m t·∫Øt v√† ƒëi·ªÉm ch√≠nh Core Concepts : 1. Blockchain l√† distributed ledger gi·∫£i quy·∫øt double-spending kh√¥ng c·∫ßn b√™n th·ª© ba 2. S·ª≠ d·ª•ng cryptographic hash functions ƒë·ªÉ t·∫°o immutability 3. Consensus mechanisms ƒë·∫£m b·∫£o agreement trong environment kh√¥ng tin c·∫≠y 4. Trade-off gi·ªØa decentralization, security, v√† scalability Technical Foundation : - Hash functions: SHA-256, collision resistance, pre-image resistance - Block structure: header, transactions, previous hash - Merkle trees: efficient verification - Chain linking: tamper-evident structure Applications : - Cryptocurrency Bitcoin, Ethereum - Smart contracts - Supply chain management - Digital identity - Decentralized finance DeFi Challenges : - Scalability limitations - Energy consumption PoW - Privacy concerns - Finality vs speed tradeoffs - Storage requirements --- ‚úÖ End of Lecture 00.00 Next : Lecture 00.01 - Distributed Systems and Consensus Theory --- References 1. Nakamoto, S. 2008 . Bitcoin: A peer-to-peer electronic cash system. 2. Buterin, V. 2014 . Ethereum whitepaper: A next-generation smart contract and decentralized application platform. 3. Antonopoulos, A. M. 2017 . Mastering Bitcoin: Programming the Open Blockchain . O'Reilly Media. 4. Narayanan, A., Bonneau, J., Felten, E., Miller, A., & Goldfeder, S. 2016 . Bitcoin and Cryptocurrency Technologies . Princeton University Press. 5. Castro, M., & Liskov, B. 1999 . Practical byzantine fault tolerance. OSDI, 99, 173-186.",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter00/blockchain-chapter00/00_00_Introduction_to_Blockchain/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter00/blockchain-chapter00/00_01_Distributed_Systems_Consensus",
    "title": "Lecture 00.01: Distributed Systems v√† Consensus Theory",
    "chapter": "00",
    "order": 2,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Distributed Systems v√† Consensus Theory 1. T·ªïng quan v·ªÅ kh√°i ni·ªám ƒê·ªÉ hi·ªÉu s√¢u v·ªÅ blockchain, ch√∫ng ta ph·∫£i hi·ªÉu v·ªÅ distributed systems h·ªá th·ªëng ph√¢n t√°n - n·ªÅn t·∫£ng l√Ω thuy·∫øt m√† blockchain ƒë∆∞·ª£c x√¢y d·ª±ng tr√™n ƒë√≥. M·ªôt h·ªá th·ªëng ph√¢n t√°n l√† m·ªôt t·∫≠p h·ª£p c√°c m√°y t√≠nh ƒë·ªôc l·∫≠p k·∫øt n·ªëi qua m·∫°ng, l√†m vi·ªác c√πng nhau ƒë·ªÉ ƒë·∫°t ƒë∆∞·ª£c m·ªôt m·ª•c ti√™u chung, nh∆∞ng v·ªõi ng∆∞·ªùi d√πng cu·ªëi, ch√∫ng tr√¥ng nh∆∞ m·ªôt h·ªá th·ªëng duy nh·∫•t. V·∫•n ƒë·ªÅ c·ªët l√µi trong distributed systems l√† consensus s·ª± ƒë·ªìng thu·∫≠n : l√†m th·∫ø n√†o ƒë·ªÉ nhi·ªÅu m√°y t√≠nh ƒë·ªôc l·∫≠p, c√≥ th·ªÉ fail b·∫•t c·ª© l√∫c n√†o, c√≥ th·ªÉ b·ªã delay v·ªÅ network, ho·∫∑c th·∫≠m ch√≠ c√≥ th·ªÉ h√†nh ƒë·ªông maliciously, c√≥ th·ªÉ ƒë·ªìng √Ω v·ªÅ m·ªôt gi√° tr·ªã ho·∫∑c tr·∫°ng th√°i duy nh·∫•t? V·∫•n ƒë·ªÅ n√†y kh√¥ng h·ªÅ ƒë∆°n gi·∫£n. Trong nƒÉm 1985, hai nh√† khoa h·ªçc m√°y t√≠nh Fisher, Lynch v√† Paterson ƒë√£ ch·ª©ng minh m·ªôt k·∫øt qu·∫£ n·ªïi ti·∫øng ƒë∆∞·ª£c g·ªçi l√† FLP Impossibility Result : trong m·ªôt m·∫°ng asynchronous kh√¥ng c√≥ bounds v·ªÅ message delay , ch·ªâ c·∫ßn m·ªôt node c√≥ th·ªÉ fail, kh√¥ng th·ªÉ c√≥ m·ªôt consensus algorithm deterministic n√†o ƒë·∫£m b·∫£o terminate trong finite time. ƒê√¢y l√† m·ªôt k·∫øt qu·∫£ profound, cho th·∫•y r·∫±ng perfect consensus trong m√¥i tr∆∞·ªùng distributed th·ª±c s·ª± l√† impossible! Nh∆∞ng trong th·ª±c t·∫ø, h·ªá th·ªëng ph√¢n t√°n v·∫´n ho·∫°t ƒë·ªông. T·∫°i sao? B·ªüi v√¨ ch√∫ng ta relaxing m·ªôt s·ªë assumptions : - Ch·∫•p nh·∫≠n probabilistic guarantees thay v√¨ deterministic - Gi·∫£ ƒë·ªãnh network c√≥ weak synchrony kh√¥ng ph·∫£i ho√†n to√†n asynchronous - Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng faulty nodes - Ch·∫•p nh·∫≠n eventual consistency thay v√¨ immediate consistency Blockchain l√† m·ªôt distributed system ƒë·∫∑c bi·ªát v·ªõi nh·ªØng ƒë·∫∑c t√≠nh: 1. No central authority : Kh√¥ng c√≥ coordinator 2. Byzantine environment : Nodes c√≥ th·ªÉ h√†nh ƒë·ªông arbitrarily maliciously 3. Open membership : B·∫•t k·ª≥ ai c≈©ng c√≥ th·ªÉ tham gia ho·∫∑c r·ªùi kh·ªèi trong public blockchains 4. Incentive-driven : S·ª≠ d·ª•ng economic incentives ƒë·ªÉ encourage honest behavior Consensus trong blockchain kh√¥ng ch·ªâ l√† v·∫•n ƒë·ªÅ k·ªπ thu·∫≠t, m√† c√≤n l√† k·∫øt h·ª£p c·ªßa cryptography, game theory, v√† distributed systems theory . Bitcoin gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ n√†y th√¥ng qua Proof-of-Work - m·ªôt breakthrough kh√¥ng ch·ªâ v·ªÅ m·∫∑t k·ªπ thu·∫≠t m√† c√≤n v·ªÅ conceptual, b·ªüi v√¨ n√≥ transform computational resources th√†nh votes, v√† economic incentives th√†nh security guarantees. --- 2. Hi·ªÉu bi·∫øt tr·ª±c quan 2.1. The Consensus Problem T∆∞·ªüng t∆∞·ª£ng b·∫°n v√† 9 ng∆∞·ªùi b·∫°n ƒëang ·ªü 10 th√†nh ph·ªë kh√°c nhau, v√† c√°c b·∫°n mu·ªën quy·∫øt ƒë·ªãnh xem n√™n ƒëi ƒÉn tr∆∞a ·ªü ƒë√¢u v√†o ng√†y mai. C√°c b·∫°n ch·ªâ c√≥ th·ªÉ giao ti·∫øp qua tin nh·∫Øn vƒÉn b·∫£n: Scenario 1: Centralized c√≥ leader - Alice l√† leader, c√¥ ·∫•y quy·∫øt ƒë·ªãnh: \"Pizza!\" - M·ªçi ng∆∞·ªùi follow Alice - ‚úÖ Simple, fast - ‚ùå Nh∆∞ng n·∫øu Alice's phone die th√¨ sao? N·∫øu Alice b·ªã hack th√¨ sao? Scenario 2: Distributed Voting kh√¥ng c√≥ leader - M·ªçi ng∆∞·ªùi g·ª≠i vote c·ªßa m√¨nh cho t·∫•t c·∫£ m·ªçi ng∆∞·ªùi kh√°c - M·ªói ng∆∞·ªùi ƒë·∫øm votes v√† ch·ªçn option c√≥ nhi·ªÅu votes nh·∫•t - ‚úÖ No single point of failure - ‚ùå Nh∆∞ng c√°c messages c√≥ th·ªÉ b·ªã delay ho·∫∑c lost. Bob c√≥ th·ªÉ nh·∫≠n votes theo th·ª© t·ª± kh√°c v·ªõi Charlie. L√†m sao ƒë·∫£m b·∫£o m·ªçi ng∆∞·ªùi ƒë·∫øm ƒë·∫øn c√πng k·∫øt qu·∫£? Scenario 3: Byzantine Voting c√≥ ng∆∞·ªùi gian l·∫≠n - Eve l√† m·ªôt hacker, c√¥ ·∫•y g·ª≠i \"Pizza\" cho m·ªôt n·ª≠a nh√≥m v√† \"Sushi\" cho n·ª≠a c√≤n l·∫°i - M·ªôt n·ª≠a nh√≥m nghƒ© majority l√† Pizza, n·ª≠a c√≤n l·∫°i nghƒ© l√† Sushi - Split decision ‚Üí system fails! ƒê√¢y ch√≠nh x√°c l√† Byzantine Generals Problem : L√†m th·∫ø n√†o ƒë·ªÉ m·ªôt nh√≥m generals nodes c√≥ th·ªÉ ƒë·ªìng √Ω v·ªÅ m·ªôt plan of attack, khi m·ªôt s·ªë generals c√≥ th·ªÉ l√† traitors Byzantine/malicious nodes , v√† communication c√≥ th·ªÉ b·ªã intercepted ho·∫∑c delayed? 2.2. Blockchain's Solution Blockchain gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ n√†y b·∫±ng c√°ch: 1. Ordered Log of Events : Thay v√¨ vote v·ªÅ m·ªôt decision duy nh·∫•t, t·∫°o m·ªôt log chronological c·ªßa t·∫•t c·∫£ decisions transactions 2. Proof-of-Work Lottery : Thay v√¨ m·ªçi ng∆∞·ªùi vote c√πng l√∫c, randomly ch·ªçn m·ªôt ng∆∞·ªùi miner ƒë·ªÉ propose block ti·∫øp theo. \"Random\" selection d·ª±a tr√™n computational work gi·∫£i puzzle m·∫≠t m√£ . 3. Longest Chain Rule : N·∫øu c√≥ conflicts hai blocks ƒë∆∞·ª£c propose c√πng l√∫c , follow chain d√†i nh·∫•t c√≥ most accumulated work . Eventually, m·ªôt chain s·∫Ω become dominant. 4. Economic Incentives : Ng∆∞·ªùi ƒë∆∞·ª£c ch·ªçn ƒë·ªÉ propose block nh·∫≠n reward block reward + transaction fees . ƒêi·ªÅu n√†y makes it expensive to attack v√† profitable to be honest. Gi·ªëng nh∆∞ trong voting example: thay v√¨ m·ªçi ng∆∞·ªùi vote v·ªÅ \"Pizza vs Sushi\", blockchain t·∫°o m·ªôt ordered list: \"Transaction 1: Alice ‚Üí Bob, Transaction 2: Bob ‚Üí Charlie, ...\". V√† thay v√¨ everyone agreeing immediately, agreement emerges gradually as more blocks are added. --- 3. N·ªÅn t·∫£ng k·ªπ thu·∫≠t 3.1. Properties of Distributed Systems M·ªôt distributed system ph·∫£i ƒë·∫£m b·∫£o c√°c t√≠nh ch·∫•t: Safety : \"Nothing bad happens\" - Consistency: All nodes see the same data - Agreement: All correct nodes agree on the same value Liveness : \"Something good eventually happens\" - Termination: Algorithm eventually completes - Progress: System makes forward progress Fault Tolerance : - Crash faults : Node stops responding - Omission faults : Messages are dropped - Byzantine faults : Arbitrary malicious behavior 3.2. CAP Theorem Eric Brewer's CAP theorem 2000 states that trong m·ªôt distributed system, b·∫°n ch·ªâ c√≥ th·ªÉ ƒë·∫°t ƒë∆∞·ª£c maximum 2 trong 3 t√≠nh ch·∫•t sau: Consistency C : M·ªçi read nh·∫≠n v·ªÅ most recent write Availability A : M·ªçi request nh·∫≠n v·ªÅ response kh√¥ng c√≥ error Partition Tolerance P : System ti·∫øp t·ª•c ho·∫°t ƒë·ªông khi network b·ªã ph√¢n m·∫£nh C Consistency / \\ / \\ / CA \\ / \\ A P Availability Partition Tolerance CP Systems: Consistency + Partition Tolerance ‚Üí May become unavailable during network partition ‚Üí Bitcoin, Ethereum prioritize consistency AP Systems: Availability + Partition Tolerance ‚Üí May return stale data during partition ‚Üí DNS, Cassandra eventual consistency CA Systems: Consistency + Availability ‚Üí No partition tolerance ‚Üí Traditional RDBMS in single datacenter Blockchains th∆∞·ªùng l√† CP systems : ∆∞u ti√™n consistency all nodes agree on chain h∆°n availability c√≥ th·ªÉ temporary unavailable during chain reorganization . 3.3. Consensus Models State Machine Replication SMR : Consensus trong distributed systems th∆∞·ªùng ƒë∆∞·ª£c implement th√¥ng qua state machine replication: - M·ªói node ch·∫°y m·ªôt deterministic state machine - T·∫•t c·∫£ nodes b·∫Øt ƒë·∫ßu t·ª´ c√πng initial state - Nodes nh·∫≠n c√πng sequence of commands trong c√πng order - Deterministic execution ‚Üí t·∫•t c·∫£ nodes ƒë·∫øn c√πng final state Node 1: S0 --cmd1--> S1 --cmd2--> S2 --cmd3--> S3 Node 2: S0 --cmd1--> S1 --cmd2--> S2 --cmd3--> S3 Node 3: S0 --cmd1--> S1 --cmd2--> S2 --cmd3--> S3 Consensus = Agreement on sequence of commands Blockchain √°p d·ª•ng SMR: - State = account balances, smart contract storage - Commands = transactions - Consensus = agreement on order of transactions blocks 3.4. Types of Consensus Algorithms Classical Consensus CFT - Crash Fault Tolerant : 1. Paxos Leslie Lamport, 1989 : - Tolerates crash failures - Requires majority quorum: \\ \\lfloor n/2 \\rfloor + 1 \\ - Used in Google Chubby, Apache ZooKeeper 2. Raft Diego Ongaro, 2014 : - Simpler alternative to Paxos - Leader-based, easier to understand - Used in etcd, Consul Byzantine Fault Tolerant BFT Consensus : 1. PBFT Practical Byzantine Fault Tolerance, 1999 : - Tolerates \\ f \\ Byzantine faults v·ªõi \\ n \\geq 3f + 1 \\ nodes - Three-phase protocol: pre-prepare, prepare, commit - O n¬≤ message complexity - Used in Hyperledger Fabric, Zilliqa 2. Nakamoto Consensus Proof-of-Work : - Bitcoin's innovation 2008 - Probabilistic finality - Open membership permissionless - Sybil resistance through computational work 3. Proof-of-Stake : - Validators stake cryptocurrency - Selection based on stake weight - Ethereum 2.0, Cardano, Polkadot 3.5. Synchrony Assumptions Consensus algorithms depend on assumptions v·ªÅ network timing: Synchronous : - Message delay bounded: \\ \\Delta \\ known upper bound - Process execution speed bounded - Strong assumption, rarely holds in practice Asynchronous : - No bounds on message delay - FLP impossibility: no deterministic consensus possible - Weakest assumption, most realistic Partially Synchronous : - Network is eventually synchronous after GST - Global Stabilization Time - Before GST: asynchronous messages can be delayed arbitrarily - After GST: synchronous messages delivered within \\ \\Delta \\ - Most practical consensus algorithms assume partial synchrony Bitcoin assumes weak synchrony : network delays exist but blocks propagate reasonably fast f \\implies n > 3f \\implies n \\geq 3f + 1 \\ Example : - \\ n = 4 \\ , \\ f = 1 \\ : \\ 4 \\geq 3 1 + 1 = 4 \\ ‚úÖ just enough - \\ n = 3 \\ , \\ f = 1 \\ : \\ 3 \\geq 3 1 + 1 = 4 \\ ‚ùå not enough - \\ n = 10 \\ , \\ f = 3 \\ : \\ 10 \\geq 3 3 + 1 = 10 \\ ‚úÖ just enough 4.2. Nakamoto Consensus Security Trong Proof-of-Work, m·ªôt attacker v·ªõi fraction \\ q \\ c·ªßa total hash power c·ªë g·∫Øng overtake honest chain v·ªõi fraction \\ p = 1 - q \\ . Probability of Attacker Success : Cho \\ z \\ = s·ªë confirmations blocks ahead c·ªßa honest chain X√°c su·∫•t attacker catch up t·ª´ \\ z \\ blocks behind: \\ P \\text catch-up q, z = \\begin cases 1 & \\text if q \\geq 0.5 \\\\ \\left \\frac q p \\right ^z & \\text if q bool: \"\"\"Check if this node is primary for current view\"\"\" return self.view % self.n == self.node id def request self, request data: str -> Message: \"\"\"Client request - primary creates PRE-PREPARE\"\"\" if not self.is primary : raise Exception \"Only primary can create pre-prepare\" self.sequence += 1 digest = hashlib.sha256 request data.encode .hexdigest msg = Message MessageType.PRE PREPARE, self.view, self.sequence, digest, self.node id self.pre prepare log self.sequence = msg return msg def receive pre prepare self, msg: Message, request data: str : \"\"\"Backup receives PRE-PREPARE from primary\"\"\" Verify message expected digest = hashlib.sha256 request data.encode .hexdigest if msg.digest != expected digest: raise Exception \"Invalid digest\" if msg.view != self.view: raise Exception \"Wrong view\" Accept and send PREPARE self.pre prepare log msg.sequence = msg prepare msg = Message MessageType.PREPARE, self.view, msg.sequence, msg.digest, self.node id Add own prepare message if msg.sequence not in self.prepare log: self.prepare log msg.sequence = set self.prepare log msg.sequence .add prepare msg return prepare msg def receive prepare self, msg: Message : \"\"\"Receive PREPARE from other nodes\"\"\" if msg.sequence not in self.prepare log: self.prepare log msg.sequence = set self.prepare log msg.sequence .add msg Check if prepared received 2f PREPARE messages if msg.sequence not in self.prepared and len self.prepare log msg.sequence >= 2 self.f : self.prepared.add msg.sequence Send COMMIT commit msg = Message MessageType.COMMIT, self.view, msg.sequence, msg.digest, self.node id if msg.sequence not in self.commit log: self.commit log msg.sequence = set self.commit log msg.sequence .add commit msg return commit msg return None def receive commit self, msg: Message : \"\"\"Receive COMMIT from other nodes\"\"\" if msg.sequence not in self.commit log: self.commit log msg.sequence = set self.commit log msg.sequence .add msg Check if committed received 2f+1 COMMIT messages if msg.sequence not in self.committed and len self.commit log msg.sequence >= 2 self.f + 1 : self.committed.add msg.sequence return True Request is committed! return False Example usage if name == \" main \": Create 4 nodes f=1, tolerates 1 Byzantine nodes = PBFTNode i, 4 for i in range 4 print \"=== PBFT Consensus Example ===\" print f\"Total nodes: nodes 0 .n \" print f\"Max Byzantine faults: nodes 0 .f \" print f\"Required PREPARE messages: 2 nodes 0 .f \" print f\"Required COMMIT messages: 2 nodes 0 .f + 1 \\n\" Client sends request to primary node 0 request = \"Transfer 100 BTC from Alice to Bob\" print f\"Client request: request \" Phase 1: PRE-PREPARE primary broadcasts print \"\\n--- Phase 1: PRE-PREPARE ---\" pre prepare = nodes 0 .request request print f\"Node 0 primary creates PRE-PREPARE: seq= pre prepare.sequence \" Phase 2: PREPARE backups send PREPARE print \"\\n--- Phase 2: PREPARE ---\" prepare messages = for i in range 1, 4 : Nodes 1, 2, 3 prepare = nodes i .receive pre prepare pre prepare, request prepare messages.append i, prepare print f\"Node i sends PREPARE\" Broadcast PREPARE messages to all nodes commit messages = for node in nodes: for sender id, prepare in prepare messages: commit = node.receive prepare prepare if commit: commit messages.append node.node id, commit print f\"Node node.node id enters PREPARED state, sends COMMIT\" Phase 3: COMMIT print \"\\n--- Phase 3: COMMIT ---\" for node in nodes: for sender id, commit in commit messages: if node.node id != sender id: committed = node.receive commit commit if committed: print f\"Node node.node id COMMITTED request!\" print \"\\n=== Consensus Reached! ===\" print f\"All honest nodes agreed on: request \" 5.2. Bitcoin's Consensus Simplified python import hashlib import time from typing import List, Optional class BitcoinBlock: def init self, index: int, transactions: List str , previous hash: str, difficulty: int : self.index = index self.timestamp = time.time self.transactions = transactions self.previous hash = previous hash self.difficulty = difficulty self.nonce = 0 self.hash = \"\" def mine self : \"\"\"Proof-of-Work: find nonce such that hash str: block data = f\" self.index self.timestamp \" f\" self.transactions self.previous hash self.nonce \" return hashlib.sha256 block data.encode .hexdigest class BitcoinBlockchain: def init self, difficulty: int = 4 : self.chain: List BitcoinBlock = self.difficulty = difficulty self.pending transactions: List str = Create genesis block genesis = BitcoinBlock 0, \"Genesis\" , \"0\", difficulty genesis.mine self.chain.append genesis def add transaction self, transaction: str : self.pending transactions.append transaction def mine block self -> BitcoinBlock: \"\"\"Simulate mining a new block\"\"\" if not self.pending transactions: return None new block = BitcoinBlock len self.chain , self.pending transactions.copy , self.chain -1 .hash, self.difficulty print f\"\\nMining block new block.index ...\" new block.mine self.chain.append new block self.pending transactions = return new block def is valid self -> bool: \"\"\"Verify blockchain integrity\"\"\" for i in range 1, len self.chain : current = self.chain i previous = self.chain i-1 Check hash if current.hash != current.calculate hash : return False Check previous hash link if current.previous hash != previous.hash: return False Check PoW difficulty if not current.hash.startswith \"0\" self.difficulty : return False return True def resolve fork self, other chain: 'BitcoinBlockchain' -> bool: \"\"\"Longest chain rule: replace if other chain is longer and valid\"\"\" if len other chain.chain > len self.chain and other chain.is valid : self.chain = other chain.chain.copy return True return False Example: Simulating network consensus if name == \" main \": print \"=== Bitcoin Consensus Simulation ===\\n\" Two miners competing blockchain A = BitcoinBlockchain difficulty=4 blockchain B = BitcoinBlockchain difficulty=4 Both receive same transactions blockchain A.add transaction \"Alice -> Bob: 5 BTC\" blockchain A.add transaction \"Bob -> Charlie: 2 BTC\" blockchain B.add transaction \"Alice -> Bob: 5 BTC\" blockchain B.add transaction \"Bob -> Charlie: 2 BTC\" print \"Miner A mining...\" blockchain A.mine block print \"\\nMiner B mining...\" blockchain B.mine block Simulate: Miner A mines another block first blockchain A.add transaction \"Charlie -> Alice: 1 BTC\" print \"\\nMiner A mines block 2...\" blockchain A.mine block Miner B receives A's longer chain print f\"\\nMiner B chain length: len blockchain B.chain \" print f\"Miner A chain length: len blockchain A.chain \" if blockchain B.resolve fork blockchain A : print \"Miner B adopted Miner A's longer chain!\" print \"CONSENSUS REACHED - Both miners on same chain\" print f\"\\nFinal blockchain length: len blockchain A.chain \" print f\"Blockchain valid: blockchain A.is valid \" --- 6. C√°c th√°ch th·ª©c v√† ƒë√°nh ƒë·ªïi th∆∞·ªùng g·∫∑p 6.1. Nothing-at-Stake Problem Proof-of-Stake Trong PoS, khi c√≥ fork, validators c√≥ th·ªÉ vote cho c·∫£ hai chains m√† kh√¥ng t·ªën cost g√¨ kh√¥ng nh∆∞ PoW ph·∫£i spend electricity . Block 3a / Block 2 \\ Block 3b PoW: Miner must choose one chain can't mine both simultaneously PoS: Validator can sign both chains at no cost! Solutions : - Slashing : Ph·∫°t validators vote cho multiple chains - Finality Gadgets : Casper FFG, Tendermint - absolute finality sau certain conditions 6.2. Long-Range Attacks PoS Attacker c√≥ th·ªÉ mua old private keys c·ªßa validators v√† rewrite history t·ª´ ƒë·∫ßu. Solution : - Checkpoints : Clients hardcode recent block hashes - Weak subjectivity : Require social consensus for very old history 6.3. Selfish Mining Miners c√≥ th·ªÉ gi·ªØ blocks h·ªç mine ƒë∆∞·ª£c private, release strategically ƒë·ªÉ gain unfair advantage. Example Strategy : 1. Mine block B1, keep private 2. If another miner mines B1', release your B1 immediately 3. Race condition ‚Üí sometimes your block wins 4. Can profit with <50% hash power minimum ~25% Impact : Lowers security threshold t·ª´ 50% xu·ªëng ~33% 6.4. Network Partitions N·∫øu network b·ªã split th√†nh hai partitions: Partition A 60% nodes | Partition B 40% nodes Chain A continues | Chain B continues ... | ... When partition heals: - Longest chain wins A - Transactions on chain B get reverted ! - Users on B experienced \"false confirmations\" Mitigation : - Wait for more confirmations - Monitor network health - Use finality gadgets 6.5. Sybil Attacks Attacker t·∫°o nhi·ªÅu fake identities ƒë·ªÉ gain control. PoW Defense : One CPU = one vote ‚Üí can't create fake identities without hardware PoS Defense : One coin = one vote ‚Üí expensive to acquire enough stake PBFT Defense : Permissioned network, identity verified --- 7. C√°c kh√°i ni·ªám li√™n quan 7.1. Paxos vs Bitcoin Consensus | Feature | Paxos | Bitcoin | |---------|-------|---------| | Environment | Permissioned, CFT | Permissionless, BFT | | Fault Model | Crash faults | Byzantine faults | | Membership | Fixed, known | Dynamic, unknown | | Finality | Strong immediate | Probabilistic gradual | | Performance | High throughput | Low throughput | | Sybil Resistance | Identity-based | Resource-based PoW | 7.2. Consistency vs Consensus Consistency : Property c·ªßa data - all replicas have same value Consensus : Protocol to achieve consistency - how replicas agree Consensus Algorithm ‚Üí Achieves ‚Üí Data Consistency PBFT Linearizability Raft Sequential Nakamoto Eventual 7.3. Synchronous vs Asynchronous vs Partial Synchrony | Model | Assumption | Consensus Possible? | Examples | |-------|-----------|---------------------|----------| | Synchronous | Known message delay bound Œî | Yes trivial | Theoretical only | | Asynchronous | No timing assumptions | No FLP | Realistic Internet | | Partial Synchrony | Eventually synchronous after GST | Yes practical | PBFT, Tendermint, Ethereum 2.0 | 7.4. Permissioned vs Permissionless Permissioned Hyperledger, Corda : - Known participants - Faster consensus no PoW needed - Higher throughput - Lower decentralization Permissionless Bitcoin, Ethereum : - Open participation - Slower consensus need Sybil resistance - Lower throughput - Maximum decentralization --- 8. ‚≠ê C√°c b√†i b√°o v√† whitepaper n·ªÅn t·∫£ng | Paper | Year | Author s | Contribution | |-------|------|-----------|--------------| | \"Impossibility of Distributed Consensus with One Faulty Process\" | 1985 | Fischer, Lynch, Paterson | FLP impossibility result - fundamental limit of consensus | | \"The Byzantine Generals Problem\" | 1982 | Lamport, Shostak, Pease | Defined Byzantine fault tolerance | | \"Practical Byzantine Fault Tolerance\" | 1999 | Castro, Liskov | First practical BFT algorithm, O n¬≤ complexity | | \"Paxos Made Simple\" | 2001 | Leslie Lamport | Simplified explanation of Paxos consensus | | \"In Search of an Understandable Consensus Algorithm Raft \" | 2014 | Ongaro, Ousterhout | More understandable alternative to Paxos | | \"Bitcoin: A Peer-to-Peer Electronic Cash System\" | 2008 | Satoshi Nakamoto | Nakamoto consensus - probabilistic BFT | | \"The Bitcoin Backbone Protocol\" | 2015 | Garay, Kiayias, Leonardos | Formal analysis of Bitcoin's consensus security | | \"Consensus in the Age of Blockchains\" | 2017 | Cachin, Vukoliƒá | Survey of blockchain consensus mechanisms | | \"Tendermint: Consensus without Mining\" | 2014 | Jae Kwon | BFT consensus for public blockchains | | \"Casper the Friendly Finality Gadget\" | 2017 | Buterin, Griffith | Ethereum's PoS finality mechanism | Reading Path : 1. Start: Byzantine Generals Problem understand the challenge 2. Classical: Paxos/Raft CFT consensus 3. BFT: PBFT paper permissioned BFT 4. Blockchain: Bitcoin whitepaper + Backbone Protocol permissionless BFT 5. Modern: Tendermint, Casper modern approaches --- 9. üé® Minh h·ªça v√† tham kh·∫£o h√¨nh ·∫£nh | Description | Source | Notes | |-------------|--------|-------| | Byzantine Generals illustration | The Byzantine Generals Problem Lamport et al. https://lamport.azurewebsites.net/pubs/byz.pdf | Original paper with diagrams | | PBFT protocol flow | PBFT paper Castro & Liskov http://pmg.csail.mit.edu/papers/osdi99.pdf | Three-phase commit visualization | | CAP Theorem Venn diagram | Visual Guide to NoSQL Systems http://blog.nahurst.com/visual-guide-to-nosql-systems | Simple visualization | | Nakamoto consensus | Bitcoin Developer Guide https://developer.bitcoin.org/devguide/block chain.html | Chain selection and forks | | State machine replication | Raft visualization https://raft.github.io/ | Interactive animation | | FLP impossibility intuition | The Morning Paper - FLP https://blog.acolyer.org/2015/03/01/impossibility-of-distributed-consensus-with-one-faulty-process/ | Accessible explanation | Interactive Tools : - Raft Consensus Simulator https://raft.github.io/raftscope/index.html - visualize leader election - PBFT Simulator http://www.pbft.org/ - understand three-phase commit - Bitcoin Fork Simulator https://anders.com/blockchain/blockchain.html - see how forks resolve --- 10. T√≥m t·∫Øt v√† ƒëi·ªÉm ch√≠nh Core Concepts : 1. Consensus in distributed systems l√† fundamentally hard FLP impossibility 2. Byzantine fault tolerance requires \\ n \\geq 3f + 1 \\ nodes 3. Blockchain s·ª≠ d·ª•ng probabilistic consensus v·ªõi economic incentives 4. Trade-off gi·ªØa strong consistency vs availability CAP theorem Consensus Types : - Classical Paxos, Raft : Permissioned, CFT, strong finality - BFT PBFT : Permissioned, Byzantine-tolerant, O n¬≤ communication - Nakamoto PoW : Permissionless, probabilistic finality, Sybil-resistant - Modern PoS, Tendermint : Combining BFT v·ªõi open participation Key Insights : - Blockchain trades immediate finality for openness - Security comes from economic cost PoW or economic stake PoS - Network assumptions matter: synchrony vs asynchrony - Perfect consensus impossible; practical consensus v·ªõi reasonable assumptions Mathematical Foundations : - BFT bound: \\ f < n/3 \\ - PoW security: exponentially decreasing v·ªõi confirmations - Quorum intersection: \\ |Q 1 \\cap Q 2| \\geq f + 1 \\ --- ‚úÖ End of Lecture 00.01 Next : Lecture 00.02 - Cryptographic Hash Functions Deep Dive --- References 1. Fischer, M. J., Lynch, N. A., & Paterson, M. S. 1985 . Impossibility of distributed consensus with one faulty process. Journal of the ACM , 32 2 , 374-382. 2. Lamport, L., Shostak, R., & Pease, M. 1982 . The Byzantine generals problem. ACM Transactions on Programming Languages and Systems , 4 3 , 382-401. 3. Castro, M., & Liskov, B. 1999 . Practical Byzantine fault tolerance. OSDI , 99, 173-186. 4. Nakamoto, S. 2008 . Bitcoin: A peer-to-peer electronic cash system. 5. Garay, J., Kiayias, A., & Leonardos, N. 2015 . The bitcoin backbone protocol: Analysis and applications. EUROCRYPT 2015 . 6. Cachin, C., & Vukoliƒá, M. 2017 . Blockchain consensus protocols in the wild. arXiv:1707.01873 .",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter00/blockchain-chapter00/00_01_Distributed_Systems_Consensus/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter00/blockchain-chapter00/00_02_Cryptographic_Hash_Functions",
    "title": "Lecture 00.02: Cryptographic Hash Functions - N·ªÅn t·∫£ng c·ªßa Blockchain",
    "chapter": "00",
    "order": 3,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Cryptographic Hash Functions - N·ªÅn t·∫£ng c·ªßa Blockchain 1. T·ªïng quan v·ªÅ kh√°i ni·ªám N·∫øu blockchain l√† m·ªôt t√≤a nh√†, th√¨ cryptographic hash functions ch√≠nh l√† nh·ªØng vi√™n g·∫°ch c∆° b·∫£n nh·∫•t x√¢y n√™n n·ªÅn m√≥ng c·ªßa n√≥. M·ªçi aspect c·ªßa blockchain - t·ª´ linking blocks l·∫°i v·ªõi nhau, ƒë·∫øn verifying transactions, ƒë·∫øn mining new blocks - ƒë·ªÅu d·ª±a tr√™n hash functions. M·ªôt hash function l√† m·ªôt thu·∫≠t to√°n to√°n h·ªçc nh·∫≠n input c√≥ ƒë·ªô d√†i b·∫•t k·ª≥ v√† t·∫°o ra output c√≥ ƒë·ªô d√†i c·ªë ƒë·ªãnh, ƒë∆∞·ª£c g·ªçi l√† hash , digest , ho·∫∑c fingerprint . V√≠ d·ª•, SHA-256 Secure Hash Algorithm 256-bit - hash function ƒë∆∞·ª£c Bitcoin s·ª≠ d·ª•ng - lu√¥n t·∫°o ra output 256 bits 32 bytes , b·∫•t k·ªÉ input l√† 1 byte hay 1 gigabyte. Tuy nhi√™n, kh√¥ng ph·∫£i hash function n√†o c≈©ng l√† cryptographic hash function. ƒê·ªÉ ƒë∆∞·ª£c coi l√† cryptographic, m·ªôt hash function ph·∫£i th·ªèa m√£n ba t√≠nh ch·∫•t b·∫£o m·∫≠t quan tr·ªçng: 1. Pre-image Resistance One-wayness : Cho hash value \\ h \\ , c·ª±c k·ª≥ kh√≥ computational infeasible t√¨m ra b·∫•t k·ª≥ message \\ m \\ n√†o sao cho \\ H m = h \\ . ƒê√¢y l√† t√≠nh ch·∫•t \"m·ªôt chi·ªÅu\" - d·ªÖ d√†ng t√≠nh hash t·ª´ message, nh∆∞ng kh√¥ng th·ªÉ reverse ƒë·ªÉ t√¨m message t·ª´ hash. Gi·ªëng nh∆∞ vi·ªác pha m·ªôt c·ªëc c√† ph√™ s·ªØa - d·ªÖ pha, nh∆∞ng kh√¥ng th·ªÉ t√°ch ri√™ng c√† ph√™ v√† s·ªØa ra sau khi ƒë√£ tr·ªôn. 2. Second Pre-image Resistance Weak Collision Resistance : Cho m·ªôt message \\ m 1 \\ , c·ª±c k·ª≥ kh√≥ t√¨m m·ªôt message kh√°c \\ m 2 \\neq m 1 \\ sao cho \\ H m 1 = H m 2 \\ . ƒêi·ªÅu n√†y ƒë·∫£m b·∫£o r·∫±ng kh√¥ng ai c√≥ th·ªÉ t·∫°o ra m·ªôt document gi·∫£ m·∫°o c√≥ c√πng hash v·ªõi document g·ªëc. 3. Collision Resistance Strong Collision Resistance : C·ª±c k·ª≥ kh√≥ t√¨m b·∫•t k·ª≥ hai messages kh√°c nhau \\ m 1 \\neq m 2 \\ n√†o sao cho \\ H m 1 = H m 2 \\ . ƒêi·ªÅu n√†y m·∫°nh h∆°n second pre-image resistance v√¨ attacker c√≥ quy·ªÅn ch·ªçn c·∫£ hai messages. T·∫°i sao nh·ªØng t√≠nh ch·∫•t n√†y quan tr·ªçng cho blockchain? - Integrity : Pre-image resistance ƒë·∫£m b·∫£o hash c√≥ th·ªÉ ƒë∆∞·ª£c d√πng l√†m commitment - m·ªôt khi hash ƒë∆∞·ª£c publish, b·∫°n kh√¥ng th·ªÉ thay ƒë·ªïi data m√† kh√¥ng b·ªã ph√°t hi·ªán - Uniqueness : Collision resistance ƒë·∫£m b·∫£o m·ªói block c√≥ m·ªôt \"digital fingerprint\" duy nh·∫•t - Chain Linking : M·ªói block ch·ª©a hash c·ªßa block tr∆∞·ªõc n√≥. Thay ƒë·ªïi b·∫•t k·ª≥ block n√†o s·∫Ω thay ƒë·ªïi hash c·ªßa n√≥, ph√° v·ª° chain - Proof-of-Work : Mining process y√™u c·∫ßu t√¨m input sao cho hash output th·ªèa m√£n ƒëi·ªÅu ki·ªán nh·∫•t ƒë·ªãnh v√≠ d·ª•: b·∫Øt ƒë·∫ßu v·ªõi N s·ªë 0 L·ªãch s·ª≠ v√† Evolution : Hash functions ƒë√£ evolve qua nhi·ªÅu th·∫ø h·ªá: - MD5 1991 : 128-bit output, b·ªã broken - collisions ƒë∆∞·ª£c t√¨m ra trong v√†i gi√¢y - SHA-1 1995 : 160-bit output, deprecated - collision attack th·ª±c t·∫ø t·ª´ 2017 - SHA-2 family 2001 : SHA-224, SHA-256, SHA-384, SHA-512 - hi·ªán t·∫°i ƒë∆∞·ª£c s·ª≠ d·ª•ng r·ªông r√£i - SHA-3 2015 : Based on Keccak, alternative to SHA-2 kh√¥ng ph·∫£i v√¨ SHA-2 broken - BLAKE2, BLAKE3 : Modern, faster alternatives Bitcoin s·ª≠ d·ª•ng SHA-256 , Ethereum ban ƒë·∫ßu d√πng Keccak-256 variant c·ªßa SHA-3 cho h·∫ßu h·∫øt operations, v√† Ethash memory-hard function based on Keccak cho mining. --- 2. Hi·ªÉu bi·∫øt tr·ª±c quan 2.1. Hash nh∆∞ \"Digital Fingerprint\" H√£y t∆∞·ªüng t∆∞·ª£ng hash function nh∆∞ m·ªôt c·ªó m√°y magic: Input any size Hash Function Output fixed size ================ ============== =================== \"Hello\" ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ SHA-256 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ 2cf24dba5fb0a30e... \"Hello!\" ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ SHA-256 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ 8cd02f4e3e55da54... Entire Harry ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ SHA-256 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ a7b38c29e4f15c83... Potter book Quan s√°t: 1. Output lu√¥n c√≥ ƒë·ªô d√†i 256 bits 64 k√Ω t·ª± hex , b·∫•t k·ªÉ input 2. Thay ƒë·ªïi m·ªôt k√Ω t·ª± trong input ‚Üí output thay ƒë·ªïi ho√†n to√†n avalanche effect 3. Kh√¥ng th·ªÉ ƒëo√°n input t·ª´ output 2.2. Avalanche Effect ƒê√¢y l√† property quan tr·ªçng nh·∫•t c·ªßa cryptographic hash functions - m·ªôt thay ƒë·ªïi nh·ªè trong input g√¢y ra thay ƒë·ªïi l·ªõn, kh√¥ng predictable trong output: Input: \"The quick brown fox jumps over the lazy dog\" SHA256: d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592 Input: \"The quick brown fox jumps over the lazy dag\" dog ‚Üí dag SHA256: 78fb6e83e84ca651a75de8e17c3e0f8afffe3dc71a7fe0dd8e5bff7f4b2f8e29 Ch·ªâ thay ƒë·ªïi 1 ch·ªØ c√°i, nh∆∞ng hash ho√†n to√†n kh√°c! Kh√¥ng c√≥ pattern n√†o gi·ªØa hai hashes. 2.3. One-Way Street Analogy Hash function gi·ªëng nh∆∞ m·ªôt one-way street : Message ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Hash Function ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Hash Value ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Easy this way Message ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ Reverse????? ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Hash Value ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Impossible this way V·ªõi SHA-256, ƒë·ªÉ \"reverse\" m·ªôt hash, b·∫°n ph·∫£i th·ª≠ trung b√¨nh \\ 2^ 256 \\ messages kh√°c nhau. Con s·ªë n√†y l·ªõn ƒë·∫øn m·ª©c: \\ 2^ 256 \\approx 10^ 77 \\ So s√°nh: - S·ªë nguy√™n t·ª≠ trong observable universe: \\ \\approx 10^ 80 \\ - S·ªë gi√¢y k·ªÉ t·ª´ Big Bang: \\ \\approx 4.3 \\times 10^ 17 \\ Ngay c·∫£ khi b·∫°n c√≥ t·∫•t c·∫£ computers tr√™n Tr√°i ƒê·∫•t, m·∫•t h√†ng t·ª∑ nƒÉm c≈©ng kh√¥ng th·ªÉ brute-force m·ªôt SHA-256 hash. 2.4. Pigeonhole Principle v√† Collisions V·ªÅ m·∫∑t l√Ω thuy·∫øt, collisions must exist . T·∫°i sao? Pigeonhole Principle : N·∫øu b·∫°n c√≥ nhi·ªÅu items h∆°n s·ªë containers, √≠t nh·∫•t m·ªôt container ph·∫£i ch·ª©a nhi·ªÅu h∆°n m·ªôt item. - Input space: infinite messages c√≥ th·ªÉ c√≥ b·∫•t k·ª≥ ƒë·ªô d√†i n√†o - Output space: \\ 2^ 256 \\ possible hashes - Infinite > \\ 2^ 256 \\ ‚Üí must have collisions! Nh∆∞ng t√¨m ra m·ªôt collision trong practice l√† c·ª±c k·ª≥ kh√≥. Theo Birthday Paradox , c·∫ßn kho·∫£ng \\ 2^ 128 \\ random hashes tr∆∞·ªõc khi c√≥ 50% chance t√¨m ra collision cho SHA-256. \\ 2^ 128 \\approx 3.4 \\times 10^ 38 \\ V·ªõi current computing power, ƒëi·ªÅu n√†y v·∫´n l√† impossible. --- 3. N·ªÅn t·∫£ng k·ªπ thu·∫≠t 3.1. SHA-256 Algorithm Structure SHA-256 thu·ªôc Merkle-Damg√•rd construction , work theo c√°c b∆∞·ªõc: Step 1: Preprocessing Padding Message ƒë∆∞·ª£c pad ƒë·ªÉ ƒë·ªô d√†i chia h·∫øt cho 512 bits: - Append bit '1' - Append k bits '0' where \\ k \\ th·ªèa m√£n: \\ \\text message length + 1 + k \\equiv 448 \\pmod 512 \\ - Append 64-bit representation c·ªßa original message length Example : Original message: \"abc\" = 01100001 01100010 01100011 24 bits After padding: 01100001 01100010 01100011 1 0000...0000 423 bits 0000...011000 64 bits |-------- abc --------| ^ |---- k zeros ----| |--- length = 24 ---| | append 1 Total: 512 bits one block Step 2: Initialize Hash Values SHA-256 s·ª≠ d·ª•ng 8 initial hash values H‚ÇÄ - H‚Çá , each 32 bits: H‚ÇÄ = 0x6a09e667 first 32 bits of fractional parts of ‚àö2 H‚ÇÅ = 0xbb67ae85 ‚àö3 H‚ÇÇ = 0x3c6ef372 ‚àö5 ... H‚Çá = 0x5be0cd19 ‚àö19 Nh·ªØng s·ªë n√†y kh√¥ng random - ch√∫ng l√† fractional parts c·ªßa square roots c·ªßa first 8 primes, ƒë·ªÉ prove kh√¥ng c√≥ backdoors. Step 3: Process Message in 512-bit Blocks M·ªói block ƒëi qua 64 rounds c·ªßa operations: Round Function Components : 1. Ch x,y,z : Choose function \\ \\text Ch x, y, z = x \\land y \\oplus \\neg x \\land z \\ \"If x then y else z\" 2. Maj x,y,z : Majority function \\ \\text Maj x, y, z = x \\land y \\oplus x \\land z \\oplus y \\land z \\ \"Majority vote of three bits\" 3. Œ£‚ÇÄ x , Œ£‚ÇÅ x : Rotation functions \\ \\begin align \\Sigma 0 x &= \\text ROTR ^2 x \\oplus \\text ROTR ^ 13 x \\oplus \\text ROTR ^ 22 x \\\\ \\Sigma 1 x &= \\text ROTR ^6 x \\oplus \\text ROTR ^ 11 x \\oplus \\text ROTR ^ 25 x \\end align \\ 4. œÉ‚ÇÄ x , œÉ‚ÇÅ x : Shift and rotation \\ \\begin align \\sigma 0 x &= \\text ROTR ^7 x \\oplus \\text ROTR ^ 18 x \\oplus \\text SHR ^3 x \\\\ \\sigma 1 x &= \\text ROTR ^ 17 x \\oplus \\text ROTR ^ 19 x \\oplus \\text SHR ^ 10 x \\end align \\ Main Loop 64 rounds : For t = 0 to 63: T‚ÇÅ = h + Œ£‚ÇÅ e + Ch e,f,g + K‚Çú + W‚Çú T‚ÇÇ = Œ£‚ÇÄ a + Maj a,b,c h = g g = f f = e e = d + T‚ÇÅ d = c c = b b = a a = T‚ÇÅ + T‚ÇÇ Where: - a, b, c, d, e, f, g, h: Eight 32-bit working variables - K‚Çú: Round constants first 32 bits of fractional parts of cube roots of first 64 primes - W‚Çú: Message schedule derived from input block Step 4: Output Final hash = concatenation of H‚ÇÄ + H‚ÇÅ + ... + H‚Çá 256 bits total 3.2. Message Schedule W Array W array ƒë∆∞·ª£c t·∫°o t·ª´ 512-bit block: python First 16 words: directly from message block W 0..15 = message block 0..15 Each word is 32 bits Remaining 48 words: derived from previous words for t in range 16, 64 : W t = œÉ‚ÇÅ W t-2 + W t-7 + œÉ‚ÇÄ W t-15 + W t-16 Vi·ªác n√†y ensures r·∫±ng m·ªói bit c·ªßa input ·∫£nh h∆∞·ªüng ƒë·∫øn nhi·ªÅu bits c·ªßa output diffusion . 3.3. Properties Analysis Deterministic : \\ \\forall m: H m \\text always produces same output \\ Uniform Distribution : Cho random input, m·ªói bit trong output c√≥ probability ‚âà 0.5 l√† 0 ho·∫∑c 1. Avalanche Effect strict avalanche criterion : Flip one input bit ‚Üí on average 50% output bits flip. ƒêo l∆∞·ªùng: \\ \\text Avalanche = \\frac \\text Number of flipped bits in output 256 \\times 100\\% \\ For good hash: Avalanche ‚âà 50% ¬± small variance Compression : \\ |H m | = 256 \\text bits, regardless of |m| \\ --- 4. C√¥ng th·ª©c to√°n h·ªçc v√† m·∫≠t m√£ h·ªçc 4.1. Collision Resistance - Mathematical Analysis Birthday Paradox application: Trong m·ªôt set c√≥ \\ N \\ possible values, probability c·ªßa finding collision sau \\ k \\ random samples: \\ P \\text collision \\approx 1 - e^ -k k-1 / 2N \\ For 50% probability: \\ k \\approx \\sqrt \\frac N \\cdot \\ln 2 2 \\approx 1.17\\sqrt N \\ For SHA-256 with \\ N = 2^ 256 \\ : \\ k \\approx 1.17 \\times 2^ 128 \\approx 3.99 \\times 10^ 38 \\ Time to find collision brute force : Gi·∫£ s·ª≠ computational power: \\ C \\ hashes/second \\ \\text Time = \\frac k C \\ Example calculation : - Assume entire Bitcoin network: \\ C \\approx 600 \\times 10^ 18 \\ hashes/sec 600 EH/s - Time to 50% collision probability: \\ T = \\frac 3.99 \\times 10^ 38 600 \\times 10^ 18 \\approx 6.65 \\times 10^ 17 \\text seconds \\ \\ T \\approx 2.1 \\times 10^ 10 \\text years = 21 \\text billion years \\ Universe age: ~13.8 billion years. Even with entire Bitcoin network, would take longer than universe age! 4.2. Pre-image Resistance Probability c·ªßa finding pre-image brute force : For hash output \\ h \\ , try random inputs until finding \\ m \\ where \\ H m = h \\ . Average attempts needed: \\ E \\text attempts = \\frac 2^ 256 2 = 2^ 255 \\ Comparison with physical processes : Landauer's principle: minimum energy to flip one bit at temperature T: \\ E \\text min = kT \\ln 2 \\ At T = 300K room temperature : \\ E \\text min \\approx 2.87 \\times 10^ -21 \\text joules \\ Energy to compute \\ 2^ 256 \\ hashes: \\ E \\text total = 2^ 256 \\times 2.87 \\times 10^ -21 \\approx 3.3 \\times 10^ 56 \\text joules \\ Mass-energy equivalence \\ E = mc^2 \\ : \\ m = \\frac E c^2 \\approx \\frac 3.3 \\times 10^ 56 9 \\times 10^ 16 \\approx 3.7 \\times 10^ 39 \\text kg \\ For comparison: - Mass of Earth: \\ 5.97 \\times 10^ 24 \\ kg - Mass of Sun: \\ 1.99 \\times 10^ 30 \\ kg - Our number: \\ 3.7 \\times 10^ 39 \\ kg ‚âà 1.8 billion suns! Breaking SHA-256 by brute force would require converting mass equivalent to 1.8 billion suns into energy - thermodynamically impossible . 4.3. Second Pre-image Resistance Harder to break than collision resistance: Given \\ m 1 \\ , find \\ m 2 \\neq m 1 \\ where \\ H m 1 = H m 2 \\ . Cannot use birthday attack requires choosing both messages . Must brute-force search: \\ \\text Expected attempts = 2^ 256 \\ Generic attack complexity : - Collision resistance: \\ O 2^ n/2 \\ where n = hash length - Pre-image resistance: \\ O 2^n \\ - Second pre-image resistance: \\ O 2^n \\ For SHA-256 n=256 : - Finding collision: \\ 2^ 128 \\ operations still infeasible - Finding pre-image: \\ 2^ 256 \\ operations absolutely infeasible 4.4. Length Extension Attack v√† c√°ch SHA-256 vulnerable SHA-256 v√† SHA-1, MD5 s·ª≠ d·ª•ng Merkle-Damg√•rd construction, vulnerable to length extension: Cho \\ H m \\ , attacker c√≥ th·ªÉ t√≠nh \\ H m || m' \\ m√† kh√¥ng bi·∫øt \\ m \\ , ch·ªâ bi·∫øt \\ H m \\ v√† length c·ªßa \\ m \\ . Why? Final hash value IS the internal state. Attacker c√≥ th·ªÉ: 1. Initialize hash state v·ªõi \\ H m \\ 2. Continue hashing with \\ m' \\ 3. Get \\ H m || \\text padding m || m' \\ Example attack scenario : Legitimate: secret || message ‚Üí HMAC Attacker sees: H secret || message Attacker computes: H secret || message || padding || malicious data Mitigation : - Use HMAC Hash-based Message Authentication Code : \\ \\text HMAC K, m = H K \\oplus \\text opad || H K \\oplus \\text ipad || m \\ - Use SHA-3 not vulnerable - uses sponge construction --- 5. Implementation Insight 5.1. Pure Python Implementation c·ªßa SHA-256 python import struct def rotr n, b, bits=32 : \"\"\"Rotate right\"\"\" return n >> b | n > b class SHA256: Initial hash values first 32 bits of fractional parts of ‚àöprimes H = 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 Round constants first 32 bits of fractional parts of ‚àõprimes K = 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2 @staticmethod def Ch x, y, z : \"\"\"Choose: if x then y else z\"\"\" return x & y ^ ~x & z @staticmethod def Maj x, y, z : \"\"\"Majority: vote of x, y, z\"\"\" return x & y ^ x & z ^ y & z @staticmethod def Sigma0 x : return rotr x, 2 ^ rotr x, 13 ^ rotr x, 22 @staticmethod def Sigma1 x : return rotr x, 6 ^ rotr x, 11 ^ rotr x, 25 @staticmethod def sigma0 x : return rotr x, 7 ^ rotr x, 18 ^ shr x, 3 @staticmethod def sigma1 x : return rotr x, 17 ^ rotr x, 19 ^ shr x, 10 @classmethod def hash cls, message: bytes -> str: \"\"\"Compute SHA-256 hash of message\"\"\" Preprocessing: Padding ml = len message 8 Message length in bits message += b'\\x80' Append '1' bit Append zeros until length ‚â° 448 mod 512 while len message 8 % 512 != 448: message += b'\\x00' Append original length as 64-bit big-endian integer message += struct.pack '>Q', ml Initialize hash values h0, h1, h2, h3, h4, h5, h6, h7 = cls.H Process message in 512-bit chunks for chunk start in range 0, len message , 64 : chunk = message chunk start:chunk start + 64 Create message schedule W w = list struct.unpack '>16I', chunk + 0 48 for i in range 16, 64 : w i = cls.sigma1 w i-2 + w i-7 + cls.sigma0 w i-15 + w i-16 & 0xFFFFFFFF Initialize working variables a, b, c, d, e, f, g, h = h0, h1, h2, h3, h4, h5, h6, h7 Main loop 64 rounds for i in range 64 : T1 = h + cls.Sigma1 e + cls.Ch e, f, g + cls.K i + w i & 0xFFFFFFFF T2 = cls.Sigma0 a + cls.Maj a, b, c & 0xFFFFFFFF h = g g = f f = e e = d + T1 & 0xFFFFFFFF d = c c = b b = a a = T1 + T2 & 0xFFFFFFFF Add compressed chunk to hash values h0 = h0 + a & 0xFFFFFFFF h1 = h1 + b & 0xFFFFFFFF h2 = h2 + c & 0xFFFFFFFF h3 = h3 + d & 0xFFFFFFFF h4 = h4 + e & 0xFFFFFFFF h5 = h5 + f & 0xFFFFFFFF h6 = h6 + g & 0xFFFFFFFF h7 = h7 + h & 0xFFFFFFFF Produce final hash value return ''.join f' h:08x ' for h in h0, h1, h2, h3, h4, h5, h6, h7 Test if name == \" main \": test vectors = b\"\", \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , b\"abc\", \"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad\" , b\"The quick brown fox jumps over the lazy dog\", \"d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592\" , print \"=== SHA-256 Implementation Test ===\\n\" for message, expected in test vectors: result = SHA256.hash message status = \"‚úì\" if result == expected else \"‚úó\" print f\" status Input: message \" print f\" Output: result \" print f\" Expect: expected \\n\" 5.2. Bitcoin's Double SHA-256 Bitcoin s·ª≠ d·ª•ng double hashing ƒë·ªÉ th√™m security layer: python import hashlib def double sha256 data: bytes -> bytes: \"\"\"Bitcoin's double SHA-256\"\"\" return hashlib.sha256 hashlib.sha256 data .digest .digest def hash256 data: bytes -> str: \"\"\"Bitcoin hash double SHA-256, hex output \"\"\" return double sha256 data .hex Example: Bitcoin block hash block header = bytes.fromhex \"01000000\" + Version \"0000000000000000000000000000000000000000000000000000000000000000\" + Previous hash \"3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a\" + Merkle root \"29ab5f49\" + Timestamp \"ffff001d\" + Bits difficulty \"1dac2b7c\" Nonce block hash = hash256 block header print f\"Bitcoin Block Hash: block hash \" Output: 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f This is Bitcoin's Genesis Block! Why double hashing? 1. Protection against length extension attacks 2. Extra security margin paranoia 3. Makes certain theoretical attacks harder 5.3. Merkle Tree Implementation python from typing import List import hashlib def sha256 data: bytes -> bytes: return hashlib.sha256 data .digest def merkle tree transactions: List bytes -> bytes: \"\"\" Build Merkle tree and return root hash Example tree: Root / \\ AB CD / \\ / \\ A B C D \"\"\" if len transactions == 0: return sha256 b'' Level 0: Hash all transactions current level = sha256 tx for tx in transactions Build tree bottom-up while len current level > 1: next level = Pair up hashes for i in range 0, len current level , 2 : left = current level i If odd number, duplicate last hash if i + 1 List tuple : \"\"\" Generate Merkle proof for transaction at index Returns list of hash, is left tuples \"\"\" if index >= len transactions : raise ValueError \"Index out of range\" proof = current level = sha256 tx for tx in transactions current index = index while len current level > 1: next level = for i in range 0, len current level , 2 : left = current level i right = current level i + 1 if i + 1 bool: \"\"\"Verify Merkle proof\"\"\" current hash = sha256 transaction for sibling hash, is left in proof: if is left: Sibling is on left current hash = sha256 sibling hash + current hash else: Sibling is on right current hash = sha256 current hash + sibling hash return current hash == root Example usage if name == \" main \": print \"=== Merkle Tree Example ===\\n\" Create transactions transactions = b\"Alice -> Bob: 10 BTC\", b\"Bob -> Charlie: 5 BTC\", b\"Charlie -> David: 3 BTC\", b\"David -> Alice: 2 BTC\" Build Merkle tree root = merkle tree transactions print f\"Merkle Root: root.hex \\n\" Generate proof for transaction 1 tx index = 1 proof = merkle proof transactions, tx index print f\"Merkle Proof for transaction tx index :\" print f\"Transaction: transactions tx index \" print f\"Proof path len proof hashes :\" for i, h, is left in enumerate proof : position = \"left\" if is left else \"right\" print f\" i+1 . h.hex :16 ... sibling on position \" Verify proof is valid = verify merkle proof transactions tx index , proof, root print f\"\\nProof verification: '‚úì Valid' if is valid else '‚úó Invalid' \" Demonstrate efficiency print f\"\\n=== Efficiency Comparison ===\" print f\"Total transactions: len transactions \" print f\"Full download: len transactions hashes len transactions 32 bytes \" print f\"Merkle proof: len proof hashes len proof 32 bytes \" print f\"Savings: 1 - len proof /len transactions 100:.1f %\" --- 6. C√°c th√°ch th·ª©c v√† ƒë√°nh ƒë·ªïi th∆∞·ªùng g·∫∑p 6.1. Hash Collisions in Practice M·∫∑c d√π collision resistance l√† m·∫°nh v·ªÅ l√Ω thuy·∫øt, ƒë√£ c√≥ tr∆∞·ªùng h·ª£p hash functions b·ªã break: MD5 Collision 2004 : Message 1: binary data A Message 2: binary data B different from A MD5 Message 1 = MD5 Message 2 = 79054025255fb1a26e4bc422aef54eb4 Attackers c√≥ th·ªÉ t·∫°o: - Hai executables kh√°c nhau v·ªõi c√πng MD5 - Hai PDF documents kh√°c nhau v·ªõi c√πng MD5 SHA-1 Collision 2017 - SHAttered : Google researchers t·∫°o ra hai different PDF files v·ªõi c√πng SHA-1 hash: - Cost: ~$110,000 in computation - 9 quintillion computations Implications for Blockchain : - Bitcoin SHA-256 : Still secure, no practical attacks - If SHA-256 broken: catastrophic failure - Could create fake blocks - Could spend same coins multiple times - Entire blockchain would need migration Migration Strategy n·∫øu SHA-256 compromised : 1. Hard fork to new hash function SHA-3, BLAKE3 2. All nodes upgrade 3. New blocks use new hash 4. Old blocks grandfathered in 6.2. Quantum Computing Threat Grover's Algorithm : Quantum algorithm c√≥ th·ªÉ search unsorted database in \\ O \\sqrt N \\ time. For hash inversion: - Classical: \\ O 2^ 256 \\ operations - Quantum Grover : \\ O 2^ 128 \\ operations Analysis : \\ 2^ 128 \\ v·∫´n l√† extremely large: - \\ 2^ 128 \\approx 3.4 \\times 10^ 38 \\ - Even with quantum computer, still infeasible Conclusion : SHA-256 considered quantum-resistant for pre-image v√† second pre-image resistance. Collision resistance b·ªã reduced t·ª´ \\ 2^ 128 \\ xu·ªëng \\ 2^ 64 \\ - marginally concerning nh∆∞ng ch∆∞a practical threat. Future-proofing : - SHA-512: Even more quantum-resistant - Post-quantum hash functions: Research ongoing 6.3. Hash Rate Centralization Mining Context Trong PoW, finding valid block hash requires enormous hash rate: Bitcoin Mining Evolution : - 2009: CPU mining ~10 MH/s per computer - 2010: GPU mining ~100 MH/s - 2013: ASIC mining ~1000 GH/s - 2024: Modern ASICs ~100 TH/s Centralization Concerns : - Top 4 mining pools control >50% hash rate - Geographic concentration China historically, now US/Kazakhstan - ASIC manufacturers have early access Trade-offs : - SHA-256 pro : Well-studied, fast verification - SHA-256 con : ASIC-friendly, leads to centralization - Alternatives : Memory-hard functions Ethash, RandomX - more ASIC-resistant 6.4. Performance vs Security Different hash functions offer different trade-offs: | Hash Function | Output Size | Speed cycles/byte | Security Level | Notes | |---------------|-------------|---------------------|----------------|-------| | MD5 | 128 bit | 4-5 | ‚ö†Ô∏è Broken | Collision found | | SHA-1 | 160 bit | 6-7 | ‚ö†Ô∏è Deprecated | Collision found SHAttered | | SHA-256 | 256 bit | 7-8 | ‚úÖ Secure | Bitcoin standard | | SHA-512 | 512 bit | 6-7 | ‚úÖ Secure | Faster on 64-bit systems | | SHA-3 Keccak-256 | 256 bit | 9-10 | ‚úÖ Secure | Ethereum, different construction | | BLAKE2b | 512 bit | 3-4 | ‚úÖ Secure | Faster than SHA-3 | | BLAKE3 | 256 bit | 2-3 | ‚úÖ Secure | Fastest, parallelizable | For Blockchain : - Verification speed matters every node verifies - Security is paramount - SHA-256: Good balance, mature, trusted 6.5. Merkle Tree Depth Trade-off Merkle proof size grows with tree depth: For \\ n \\ transactions: - Tree depth: \\ \\log 2 n \\ - Proof size: \\ \\log 2 n \\times 32 \\ bytes 32 bytes per hash Examples : - 1,000 transactions: ~10 hashes 320 bytes - 10,000 transactions: ~14 hashes 448 bytes - 1,000,000 transactions: ~20 hashes 640 bytes Trade-off : - More transactions per block ‚Üí longer proofs - Affects SPV Simplified Payment Verification clients - Bitcoin: ~2,000-3,000 tx/block ‚Üí ~12 hashes per proof --- 7. C√°c kh√°i ni·ªám li√™n quan 7.1. Hash Functions vs Encryption Common confusion - they are different! | Feature | Hash Function | Encryption | |---------|--------------|------------| | Direction | One-way | Two-way encrypt/decrypt | | Key | No key | Requires key | | Output | Fixed size | Variable size | | Purpose | Integrity, fingerprint | Confidentiality | | Reversible | No | Yes with key | Example : Hash: \"password\" ‚Üí SHA256 ‚Üí 5e88...9abc can't reverse Encrypt: \"password\" + key ‚Üí AES ‚Üí gH3k...2xYz can decrypt v·ªõi key 7.2. Cryptographic Hash Functions vs Checksums Checksums CRC, Adler-32 : - Purpose: Detect accidental errors corruption, transmission errors - Not cryptographically secure - Faster - Smaller output Cryptographic Hashes : - Purpose: Detect intentional tampering - Resist deliberate collision attacks - Slower - Larger output Example : CRC-32 \"data\" = 0x12345678 32 bits SHA-256 \"data\" = 3a6eb079... 256 bits Attacker can easily find different message with same CRC. Attacker cannot find different message with same SHA-256. 7.3. HMAC Hash-based Message Authentication Code Combining hash with secret key for authentication: \\ \\text HMAC K, m = H K \\oplus \\text opad || H K \\oplus \\text ipad || m \\ Where: - \\ K \\ : Secret key - \\ m \\ : Message - \\ \\text ipad \\ : Inner padding 0x36 repeated - \\ \\text opad \\ : Outer padding 0x5c repeated - \\ || \\ : Concatenation Properties : - Provides authenticity AND integrity - Requires shared secret key - Resistant to length extension attack Blockchain Use : - API authentication - Wallet security - Not directly in consensus uses digital signatures instead 7.4. Commitment Schemes Hash functions enable commitment schemes - commit to a value without revealing it: Protocol : 1. Alice commits: sends \\ c = H m || r \\ m = message, r = random nonce 2. Later, Alice reveals: sends \\ m \\ and \\ r \\ 3. Bob verifies: checks \\ H m || r = c \\ Properties : - Hiding : Cannot learn \\ m \\ from \\ c \\ pre-image resistance - Binding : Cannot change \\ m \\ after committing collision resistance Blockchain Applications : - Commit-reveal voting - Fair lotteries - Atomic swaps --- 8. ‚≠ê C√°c b√†i b√°o v√† whitepaper n·ªÅn t·∫£ng | Paper | Year | Author s | Contribution | |-------|------|-----------|--------------| | \"New Directions in Cryptography\" | 1976 | Diffie, Hellman | Foundational work in cryptography | | \"A Method for Obtaining Digital Signatures and Public-Key Cryptosystems\" | 1978 | Rivest, Shamir, Adleman | RSA algorithm | | \"One-Way Hash Functions\" | 1989 | Ralph Merkle | Formalized hash function properties | | \"The MD5 Message-Digest Algorithm\" | 1992 | Ronald Rivest | MD5 specification now broken | | \"Secure Hash Standard SHS \" | 2015 | NIST FIPS 180-4 | Official SHA-2 specification | | \"The Keccak SHA-3 Submission\" | 2011 | Bertoni et al. | SHA-3 Keccak algorithm | | \"BLAKE: A Hash Function\" | 2008 | Aumasson et al. | BLAKE hash family | | \"Collisions for Hash Functions MD4, MD5, HAVAL-128 and RIPEMD\" | 2004 | Xiaoyun Wang et al. | First practical MD5 collision | | \"The first collision for full SHA-1\" | 2017 | Stevens et al. | SHAttered attack | | \"Bitcoin: A Peer-to-Peer Electronic Cash System\" | 2008 | Satoshi Nakamoto | Hash functions in blockchain | Essential Reading : 1. NIST FIPS 180-4: Authoritative SHA-2 specification 2. Keccak specification: Understand SHA-3 construction 3. SHAttered paper: See how hash functions are attacked 4. Bitcoin whitepaper Section 4-5: Merkle trees in practice --- 9. üé® Minh h·ªça v√† tham kh·∫£o h√¨nh ·∫£nh | Description | Source | Notes | |-------------|--------|-------| | SHA-256 algorithm diagram | NIST FIPS 180-4 https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf | Official specification with diagrams | | Avalanche effect visualization | Interactive SHA-256 https://sha256algorithm.com/ | See how one bit changes output | | Merkle tree structure | Bitcoin Developer Guide https://developer.bitcoin.org/devguide/block chain.html | Real Bitcoin implementation | | Hash function comparison | Crypto++ Benchmarks https://www.cryptopp.com/benchmarks.html | Performance comparison | | Collision attack visualization | SHAttered.io https://shattered.io/ | SHA-1 collision demonstration | | Birthday paradox | Better Explained - Birthday Paradox https://betterexplained.com/articles/understanding-the-birthday-paradox/ | Intuitive explanation | Interactive Tools : - Anders Brownworth - Hash Demo https://andersbrownworth.com/blockchain/hash - See SHA-256 in action - SHA-256 Visualizer https://sha256algorithm.com/ - Step-by-step SHA-256 - Merkle Tree Visualizer https://blockchain-academy.hs-mittweida.de/merkle-tree/ - Interactive Merkle tree builder --- 10. T√≥m t·∫Øt v√† ƒëi·ªÉm ch√≠nh Core Concepts : 1. Hash functions l√† one-way transformations: easy to compute, impossible to reverse 2. Cryptographic hash functions th·ªèa m√£n: pre-image resistance, collision resistance, avalanche effect 3. SHA-256 l√† backbone c·ªßa Bitcoin v√† nhi·ªÅu blockchains Technical Foundation : - SHA-256: Merkle-Damg√•rd construction, 64 rounds, 256-bit output - Collision resistance: Birthday paradox ‚Üí need \\ 2^ 128 \\ attempts - Pre-image resistance: Need \\ 2^ 256 \\ attempts ‚Üí thermodynamically impossible - Merkle trees: Efficient verification v·ªõi \\ O \\log n \\ proof size Blockchain Applications : - Block linking: Each block contains hash of previous block - Transaction verification: Merkle trees enable SPV - Proof-of-Work: Mining finds nonce such that hash < target - Commitment schemes: Commit-reveal protocols Security Considerations : - SHA-256 remains secure despite attacks on MD5, SHA-1 - Quantum computing reduces security but doesn't break SHA-256 - Double hashing Bitcoin adds extra security margin - Length extension attacks mitigated by proper construction Implementation Insights : - Pure software implementation possible ~7-8 cycles/byte - Hardware acceleration available SHA extensions in modern CPUs - Merkle proofs enable light clients - Performance vs security trade-offs in choice of hash function Key Takeaway : Cryptographic hash functions are the \"digital glue\" that makes blockchain possible - providing integrity, immutability, and efficient verification in a trustless environment. --- ‚úÖ End of Lecture 00.02 Next : Lecture 00.03 - Digital Signatures v√† Public-Key Cryptography --- References 1. National Institute of Standards and Technology NIST . 2015 . FIPS 180-4: Secure Hash Standard SHS . 2. Bertoni, G., Daemen, J., Peeters, M., & Van Assche, G. 2011 . The Keccak SHA-3 submission . 3. Stevens, M., Bursztein, E., Karpman, P., Albertini, A., & Markov, Y. 2017 . The first collision for full SHA-1 . CRYPTO 2017. 4. Merkle, R. C. 1989 . One way hash functions and DES . CRYPTO'89. 5. Aumasson, J. P., Henzen, L., Meier, W., & Phan, R. C. W. 2008 . SHA-3 proposal BLAKE . Submission to NIST. 6. Nakamoto, S. 2008 . Bitcoin: A peer-to-peer electronic cash system .",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter00/blockchain-chapter00/00_02_Cryptographic_Hash_Functions/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter00/blockchain-chapter00/00_03_Digital_Signatures",
    "title": "Lecture 00.03: Digital Signatures v√† Public-Key Cryptography",
    "chapter": "00",
    "order": 4,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Digital Signatures v√† Public-Key Cryptography 1. T·ªïng quan v·ªÅ kh√°i ni·ªám Trong b√†i gi·∫£ng tr∆∞·ªõc, ch√∫ng ta ƒë√£ h·ªçc v·ªÅ hash functions - c√¥ng c·ª• ƒë·ªÉ verify integrity c·ªßa data. Nh∆∞ng hash functions alone kh√¥ng th·ªÉ ch·ª©ng minh authenticity - l√†m th·∫ø n√†o ƒë·ªÉ bi·∫øt ai ƒë√£ t·∫°o ra message ƒë√≥? ƒê√¢y l√† l√∫c digital signatures xu·∫•t hi·ªán. Digital signatures trong blockchain ƒë√≥ng vai tr√≤ t∆∞∆°ng t·ª± nh∆∞ ch·ªØ k√Ω tay trong th·∫ø gi·ªõi v·∫≠t l√Ω, nh∆∞ng v·ªõi nhi·ªÅu t√≠nh nƒÉng v∆∞·ª£t tr·ªôi: Ch·ªØ k√Ω tay Analog : - D·ªÖ gi·∫£ m·∫°o v·ªõi k·ªπ nƒÉng - C√≥ th·ªÉ copy t·ª´ t√†i li·ªáu n√†y sang t√†i li·ªáu kh√°c - Kh√¥ng th·ªÉ verify automatically - C√πng m·ªôt ch·ªØ k√Ω cho m·ªçi document Digital Signature : - C·ª±c k·ª≥ kh√≥ gi·∫£ m·∫°o computationally infeasible - Unique cho m·ªói message kh√¥ng th·ªÉ copy sang message kh√°c - C√≥ th·ªÉ verify t·ª± ƒë·ªông b·ªüi b·∫•t k·ª≥ ai - Based on mathematical guarantees Digital signatures trong blockchain gi·∫£i quy·∫øt ba v·∫•n ƒë·ªÅ c∆° b·∫£n: 1. Authentication X√°c th·ª±c : Ch·ª©ng minh r·∫±ng message ƒë∆∞·ª£c t·∫°o b·ªüi ng∆∞·ªùi s·ªü h·ªØu private key t∆∞∆°ng ·ª©ng 2. Non-repudiation Kh√¥ng th·ªÉ ch·ªëi b·ªè : Ng∆∞·ªùi k√Ω kh√¥ng th·ªÉ deny r·∫±ng h·ªç ƒë√£ k√Ω message 3. Integrity To√†n v·∫πn : Message kh√¥ng b·ªã thay ƒë·ªïi sau khi ƒë∆∞·ª£c k√Ω Trong Bitcoin v√† h·∫ßu h·∫øt blockchains, digital signatures ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ: - Authorize transactions : Ch·ª©ng minh b·∫°n c√≥ quy·ªÅn spend coins - Prove ownership : Address derives t·ª´ public key - Prevent double-spending : M·ªói transaction c√≥ unique signature - Enable smart contracts : Signatures trigger contract execution Blockchain s·ª≠ d·ª•ng public-key cryptography hay asymmetric cryptography - m·ªôt trong nh·ªØng ph√°t minh vƒ© ƒë·∫°i nh·∫•t c·ªßa cryptography hi·ªán ƒë·∫°i. ƒê∆∞·ª£c gi·ªõi thi·ªáu b·ªüi Whitfield Diffie v√† Martin Hellman nƒÉm 1976, c√¥ng ngh·ªá n√†y revolutionized secure communication. Symmetric Cryptography c≈© : - C√πng m·ªôt key ƒë·ªÉ encrypt v√† decrypt - V·∫•n ƒë·ªÅ: L√†m sao share key securely? Alice ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ shared key ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Encrypt ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Internet ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Decrypt ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ shared key ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Bob Asymmetric Cryptography m·ªõi : - Two keys: Public key ai c≈©ng bi·∫øt v√† Private key ch·ªâ m√¨nh bi·∫øt - Encrypt v·ªõi public key, decrypt v·ªõi private key - Sign v·ªõi private key, verify v·ªõi public key Alice Bob ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Private Key A ‚îÇ ‚îÇ Private Key B ‚îÇ ‚îÇ Public Key A ‚îÇ ‚îÇ Public Key B ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ‚îÇ Sign with Private Key A ‚îÇ ‚îî‚îÄ‚îÄ‚ñ∫ Message + Signature ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Internet ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ ‚îÇ ‚îÇ Verify with Public Key A ‚óÑ‚îò ‚úì Authentic! Bitcoin primarily s·ª≠ d·ª•ng ECDSA Elliptic Curve Digital Signature Algorithm tr√™n curve secp256k1 . Ethereum c≈©ng s·ª≠ d·ª•ng ECDSA nh∆∞ng v·ªõi m·ªôt s·ªë modifications. C√°c blockchain m·ªõi h∆°n exploring alternatives nh∆∞ Schnorr signatures Bitcoin Taproot v√† EdDSA Ed25519 trong Cardano, Polkadot . --- 2. Hi·ªÉu bi·∫øt tr·ª±c quan 2.1. The Key Pair Analogy H√£y t∆∞·ªüng t∆∞·ª£ng public/private key pair nh∆∞ m·ªôt mailbox v·ªõi unique mechanism : Public Key = ƒê·ªãa ch·ªâ nh√† v√† khe th·∫£ th∆∞ : - Ai c≈©ng c√≥ th·ªÉ bi·∫øt ƒë·ªãa ch·ªâ c·ªßa b·∫°n - Ai c≈©ng c√≥ th·ªÉ g·ª≠i th∆∞ cho b·∫°n qua khe th·∫£ th∆∞ - Nh∆∞ng h·ªç kh√¥ng th·ªÉ l·∫•y th∆∞ ra t·ª´ mailbox Private Key = Ch√¨a kh√≥a duy nh·∫•t m·ªü mailbox : - Ch·ªâ b·∫°n c√≥ ch√¨a kh√≥a n√†y - Ch·ªâ b·∫°n c√≥ th·ªÉ m·ªü mailbox v√† ƒë·ªçc th∆∞ - M·∫•t ch√¨a kh√≥a = m·∫•t access to all mail forever Digital Signature = Wax seal v·ªõi coat of arms duy nh·∫•t c·ªßa b·∫°n : - Trong th·ªùi trung c·ªï, letters quan tr·ªçng ƒë∆∞·ª£c seal v·ªõi wax v√† stamped v·ªõi coat of arms - Ai c≈©ng c√≥ th·ªÉ verify seal public verification - Nh∆∞ng ch·ªâ b·∫°n c√≥ th·ªÉ t·∫°o ra authentic seal private signing - Tampering v·ªõi letter s·∫Ω break the seal 2.2. How Digital Signatures Work Simplified Signing Process : Message: \"Alice sends 10 BTC to Bob\" ‚Üì Hash Function ‚Üì Message Digest ‚Üì Sign with Alice's Private Key ‚Üì Digital Signature Verification Process : Message + Signature ‚Üì Hash the Message ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Digest 1 Signature ‚Üì Decrypt with Alice's Public Key ‚îÄ‚îÄ‚ñ∫ Digest 2 Compare: Digest 1 == Digest 2? ‚úì Yes ‚Üí Signature valid, message authentic ‚úó No ‚Üí Signature invalid or message tampered Key Insight : B·∫°n sign the hash, kh√¥ng ph·∫£i entire message. T·∫°i sao? 1. Efficiency : Signature size kh√¥ng ph·ª• thu·ªôc v√†o message size 2. Security : Hash provides fixed-size input cho signature algorithm 2.3. Bitcoin Transaction Analogy H√£y nghƒ© v·ªÅ Bitcoin transaction nh∆∞ m·ªôt s√©c check : Paper Check : Pay to: Bob Amount: $100 From: Alice Signature: Alice's handwritten signature Bitcoin Transaction : Pay to: Bob's address derived from his public key Amount: 10 BTC From: UTXO controlled by Alice's address Signature: Digital signature created v·ªõi Alice's private key Differences : - Paper check: Bank verifies signature b·∫±ng so s√°nh v·ªõi signature on file - Bitcoin: Any node c√≥ th·ªÉ verify signature b·∫±ng to√°n h·ªçc public key - Paper check: C√≥ th·ªÉ cash same check nhi·ªÅu l·∫ßn if lucky - Bitcoin: Double-spend impossible transaction includes reference to specific UTXO --- 3. N·ªÅn t·∫£ng k·ªπ thu·∫≠t 3.1. Public-Key Cryptography Fundamentals Key Generation : T·∫°o m·ªôt c·∫∑p keys public, private sao cho: 1. Kh√¥ng th·ªÉ derive private key t·ª´ public key one-way function 2. Hai keys c√≥ mathematical relationship Mathematical Foundation : D·ª±a tr√™n trapdoor functions - functions d·ªÖ compute m·ªôt chi·ªÅu, nh∆∞ng c·ª±c kh√≥ reverse tr·ª´ khi bi·∫øt \"trapdoor\" secret info . Example: RSA Trapdoor : - Easy: Nh√¢n hai s·ªë nguy√™n t·ªë l·ªõn: \\ N = p \\times q \\ - Hard: Factorize \\ N \\ th√†nh \\ p \\ v√† \\ q \\ if N is large - Trapdoor: Knowing \\ p \\ and \\ q \\ Example: Elliptic Curve Trapdoor : - Easy: Scalar multiplication: \\ Q = k \\times G \\ Q = point, k = scalar, G = generator - Hard: Discrete logarithm: Given \\ Q \\ and \\ G \\ , find \\ k \\ - Trapdoor: Knowing \\ k \\ private key 3.2. Elliptic Curve Cryptography ECC Bitcoin v√† Ethereum s·ª≠ d·ª•ng Elliptic Curve Digital Signature Algorithm ECDSA . Why Elliptic Curves? - Shorter keys cho c√πng security level vs RSA - Faster computation - Less bandwidth Security Comparison : | Symmetric | RSA | ECC | Security Level | |-----------|-----|-----|----------------| | 80 bits | 1024 bits | 160 bits | Weak broken | | 128 bits | 3072 bits | 256 bits | Strong | | 256 bits | 15360 bits | 512 bits | Very Strong | Elliptic Curve Definition : M·ªôt elliptic curve over finite field \\ \\mathbb F p \\ c√≥ d·∫°ng: \\ y^2 \\equiv x^3 + ax + b \\pmod p \\ V·ªõi ƒëi·ªÅu ki·ªán: \\ 4a^3 + 27b^2 \\not\\equiv 0 \\pmod p \\ non-singular Bitcoin's secp256k1 Parameters : Equation: y¬≤ = x¬≥ + 7 a=0, b=7 Prime: p = 2¬≤‚Åµ‚Å∂ - 2¬≥¬≤ - 2‚Åπ - 2‚Å∏ - 2‚Å∑ - 2‚Å∂ - 2‚Å¥ - 1 = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFC2F hex Generator Point G: Gx = 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798 Gy = 483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8 Order number of points : n = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141 Point Addition Geometric : Tr√™n elliptic curve, ch√∫ng ta c√≥ th·ªÉ \"add\" points: - Given points P and Q - Draw line through P and Q - Line intersects curve t·∫°i third point R' - Reflect R' across x-axis ‚Üí R = P + Q y ‚îÇ ‚îÇ Q ‚îÇ /‚îÇ\\ ‚îÇ / ‚îÇ \\ ‚îÇ / ‚îÇ \\ ‚îÇ/ ‚îÇ \\ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ x ‚îÇ\\ P / ‚îÇ \\ /R' ‚îÇ \\ / ‚îÇ \\ / ‚îÇ R reflected Scalar Multiplication : \\ Q = k \\times G = \\underbrace G + G + \\cdots + G k \\text times \\ Efficient algorithm: Double-and-add similar to binary exponentiation Example toy numbers : Private key: k = 7 Public key: Q = 7√óG = G + G + G + G + G + G + G Using double-and-add: 7 = 111‚ÇÇ binary Q = 2¬≤√óG + 2¬π√óG + 2‚Å∞√óG = 4G + 2G + G 3.3. ECDSA Signature Scheme Key Generation : 1. Choose random private key: \\ d A \\in 1, n-1 \\ 2. Compute public key: \\ Q A = d A \\times G \\ Signing message \\ m \\ : 1. Compute message hash: \\ e = \\text HASH m \\ 2. Choose random nonce: \\ k \\in 1, n-1 \\ MUST be unique per signature! 3. Compute point: \\ x 1, y 1 = k \\times G \\ 4. Compute \\ r = x 1 \\mod n \\ . If \\ r = 0 \\ , goto step 2 5. Compute \\ s = k^ -1 e + rd A \\mod n \\ . If \\ s = 0 \\ , goto step 2 6. Signature: \\ r, s \\ Verification message \\ m \\ , signature \\ r,s \\ , public key \\ Q A \\ : 1. Verify \\ r, s \\in 1, n-1 \\ 2. Compute message hash: \\ e = \\text HASH m \\ 3. Compute \\ w = s^ -1 \\mod n \\ 4. Compute \\ u 1 = ew \\mod n \\ and \\ u 2 = rw \\mod n \\ 5. Compute point: \\ x 1, y 1 = u 1 \\times G + u 2 \\times Q A \\ 6. Valid if \\ r \\equiv x 1 \\pmod n \\ Why This Works mathematical proof sketch : From signing: \\ s = k^ -1 e + rd A \\implies k = s^ -1 e + rd A \\ From verification: \\ \\begin align u 1 \\times G + u 2 \\times Q A &= ew \\times G + rw \\times Q A \\\\ &= es^ -1 \\times G + rs^ -1 \\times d A \\times G \\\\ &= s^ -1 e + rd A \\times G \\\\ &= k \\times G \\end align \\ Since \\ k \\times G = x 1, y 1 \\ from signing , v√† verification computes c√πng point, n√™n \\ r = x 1 \\ ‚úì 3.4. Bitcoin Address Generation Bitcoin address kh√¥ng ph·∫£i l√† public key directly, m√† derived t·ª´ public key: Process : Private Key 256 bits random ‚Üì ECDSA secp256k1 ‚Üì Public Key uncompressed: 65 bytes ‚Üì SHA-256 ‚Üì RIPEMD-160 ‚Üì Public Key Hash 20 bytes ‚Üì Add version byte 0x00 for mainnet ‚Üì Double SHA-256 for checksum first 4 bytes ‚Üì Base58 encoding ‚Üì Bitcoin Address starts with '1' for P2PKH Example : Private Key: 18e14a7b6a307f426a94f8114701e7c8e774e7f9a47e2c2035db29a206321725 Public Key uncompressed : 04 50863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b2352 2cd470243453a299fa9e77237716103abc11a1df38855ed6f2ee187e9c582ba6 Public Key Hash RIPEMD-160 of SHA-256 : 010966776006953d5567439e5e39f86a0d273bee Bitcoin Address: 16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM Why hashing public key? 1. Shorter addresses : 160 bits vs 256 bits 2. Quantum resistance : Even if ECDSA broken, attacker needs to break hash too 3. Flexibility : Can use different signature schemes v·ªõi same address format --- 4. C√¥ng th·ª©c to√°n h·ªçc v√† m·∫≠t m√£ h·ªçc 4.1. ECDSA Security Analysis Discrete Logarithm Problem DLP : Given \\ Q = k \\times G \\ , find \\ k \\ . Best Known Attacks : - Pollard's rho : \\ O \\sqrt n \\ operations - For 256-bit curve: \\ O 2^ 128 \\ operations Security Level : Bitcoin's secp256k1 provides ~128 bits security half of key size due to birthday paradox . \\ \\text Security bits = \\frac \\text Key size 2 = \\frac 256 2 = 128 \\ Comparison : - AES-128: 128-bit security - RSA-2048: ~112-bit security - Secp256k1: ~128-bit security 4.2. Nonce Reuse Attack Critical Security Rule : NEVER reuse nonce \\ k \\ ! Attack Scenario : Suppose attacker has two signatures v·ªõi same \\ k \\ : - Signature 1: \\ r, s 1 \\ for message \\ m 1 \\ - Signature 2: \\ r, s 2 \\ for message \\ m 2 \\ same \\ r \\ means same \\ k \\ ! From signature equations: \\ \\begin align s 1 &= k^ -1 e 1 + rd A \\mod n \\\\ s 2 &= k^ -1 e 2 + rd A \\mod n \\end align \\ Subtract: \\ s 1 - s 2 = k^ -1 e 1 - e 2 \\mod n \\ Solve for \\ k \\ : \\ k = \\frac e 1 - e 2 s 1 - s 2 \\mod n \\ Once attacker knows \\ k \\ , h·ªç c√≥ th·ªÉ recover private key: \\ d A = \\frac sk - e r \\mod n \\ Real-World Example : Sony PlayStation 3 hack 2010 - Sony reused same \\ k \\ for all PS3 firmware signatures - Hackers recovered Sony's private key - Could sign arbitrary code ‚Üí complete security breach Bitcoin Protection : - Deterministic nonces RFC 6979 : \\ k = \\text HMAC-SHA256 d A, e \\ - Ensures \\ k \\ is unique per message, but deterministic no randomness failure 4.3. Signature Malleability ECDSA signatures c√≥ property: Cho valid signature \\ r, s \\ , signature \\ r, -s \\mod n \\ c≈©ng valid! Why? Verification checks: \\ r \\stackrel ? = x 1 \\text where x 1, y 1 = u 1 G + u 2 Q A \\ Since elliptic curves symmetric v·ªÅ x-axis: - Point \\ x, y \\ and \\ x, -y \\ c·∫£ hai ƒë·ªÅu on curve - Both give same \\ x \\ -coordinate Problem : - Same transaction c√≥ th·ªÉ have different transaction IDs TXID = hash of transaction - Attacker c√≥ th·ªÉ modify signature ‚Üí change TXID - Not theft, but can confuse wallets Bitcoin's Solution BIP 62, BIP 66 : - Require \"low S\" values: \\ s \\leq n/2 \\ - Reject high S signatures - Ensures canonical signature Better Solution: Schnorr Signatures Bitcoin Taproot : - Not malleable - Smaller signatures - Batch verification - More privacy 4.4. Quantum Computing Threat to ECDSA Shor's Algorithm : Quantum algorithm c√≥ th·ªÉ solve discrete logarithm in polynomial time. \\ \\text Classical: O \\sqrt n \\quad \\text vs \\quad \\text Quantum: O \\log n ^3 \\ Implications : - Sufficiently large quantum computer c√≥ th·ªÉ break ECDSA - Can derive private key t·ª´ public key Timeline : - Current quantum computers: ~100 qubits - Needed to break 256-bit ECDSA: ~1500-3000 logical qubits millions of physical qubits - Estimate: 10-30 years until practical threat Bitcoin's Partial Protection : - Public keys kh√¥ng reveal until first spend - If never spent from address: public key kh√¥ng known - Attacker ch·ªâ c√≥ public key hash RIPEMD-160 - Must break hash function first, then ECDSA Post-Quantum Alternatives : - Hash-based signatures : SPHINCS+, XMSS - Lattice-based : Dilithium, Falcon - Code-based : Classic McEliece 4.5. Threshold Signatures v√† Multi-Signatures Multi-Signature MultiSig : Require \\ m \\ -of-\\ n \\ signatures: - Example: 2-of-3 multisig 2 out of 3 people must sign Bitcoin Implementation : OP 2 // Require 2 signatures // 3 public keys OP 3 // From 3 total OP CHECKMULTISIG // Verify Drawbacks : - Large transaction size multiple signatures + public keys - High fees - Privacy leak reveals m-of-n structure Threshold Signatures TSS : Cryptographic protocol t·∫°o single signature from \\ m \\ -of-\\ n \\ parties: - Output looks like normal single signature - Smaller size - Better privacy - More complex protocol Example: Schnorr Threshold Signature : Parties jointly compute: \\ s = k + H R, P, m \\cdot x \\ Where: - \\ k \\ : Aggregate nonce from all parties - \\ P \\ : Aggregate public key - \\ x \\ : Aggregate private key no single party knows this! Verifier sees normal signature, kh√¥ng bi·∫øt it's threshold! --- 5. Implementation Insight 5.1. ECDSA Implementation Python python import hashlib import secrets from typing import Tuple Secp256k1 parameters P = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798 Gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8 G = Gx, Gy def modinv a: int, m: int -> int: \"\"\"Modular multiplicative inverse using Extended Euclidean Algorithm\"\"\" if a Tuple int, int, int : \"\"\"Extended Euclidean Algorithm\"\"\" if a == 0: return b, 0, 1 gcd, x1, y1 = extended gcd b % a, a x = y1 - b // a x1 y = x1 return gcd, x, y def point add p1: Tuple int, int , p2: Tuple int, int -> Tuple int, int : \"\"\"Add two points on elliptic curve\"\"\" if p1 is None: Identity element return p2 if p2 is None: return p1 x1, y1 = p1 x2, y2 = p2 if x1 == x2: if y1 == y2: Point doubling s = 3 x1 x1 modinv 2 y1, P % P else: Points are inverse of each other return None else: Point addition s = y2 - y1 modinv x2 - x1, P % P x3 = s s - x1 - x2 % P y3 = s x1 - x3 - y1 % P return x3, y3 def point multiply k: int, point: Tuple int, int -> Tuple int, int : \"\"\"Scalar multiplication using double-and-add algorithm\"\"\" if k == 0: return None if k == 1: return point result = None addend = point while k: if k & 1: result = point add result, addend addend = point add addend, addend k >>= 1 return result class ECDSA: @staticmethod def generate keypair -> Tuple int, Tuple int, int : \"\"\"Generate private/public key pair\"\"\" Private key: random number in 1, n-1 private key = secrets.randbelow N - 1 + 1 Public key: private key G public key = point multiply private key, G return private key, public key @staticmethod def sign message: bytes, private key: int -> Tuple int, int : \"\"\"Sign message with private key\"\"\" Hash message e = int.from bytes hashlib.sha256 message .digest , 'big' while True: Generate deterministic nonce simplified RFC 6979 k = int.from bytes hashlib.sha256 private key.to bytes 32, 'big' + message .digest , 'big' % N - 1 + 1 Compute r = k G .x mod n point = point multiply k, G if point is None: continue r = point 0 % N if r == 0: continue Compute s = k^ -1 e + r private key mod n s = modinv k, N e + r private key % N if s == 0: continue Ensure low S BIP 62 if s > N // 2: s = N - s return r, s @staticmethod def verify message: bytes, signature: Tuple int, int , public key: Tuple int, int -> bool: \"\"\"Verify signature\"\"\" r, s = signature Check signature bounds if not 1 bytes: \"\"\"Serialize transaction for signing SIGHASH ALL \"\"\" result = b'' Version result += self.version.to bytes 4, 'little' Number of inputs result += len self.inputs .to bytes 1, 'little' Inputs for i, inp in enumerate self.inputs : Previous output result += inp 'prev tx' ::-1 Reverse for little-endian result += inp 'prev index' .to bytes 4, 'little' Script if i == input index: Include script pubkey for the input being signed script = inp 'script pubkey' result += len script .to bytes 1, 'little' result += script else: Empty script for other inputs result += b'\\x00' Sequence result += inp 'sequence' .to bytes 4, 'little' Number of outputs result += len self.outputs .to bytes 1, 'little' Outputs for out in self.outputs: result += out 'amount' .to bytes 8, 'little' script = out 'script pubkey' result += len script .to bytes 1, 'little' result += script Locktime result += self.locktime.to bytes 4, 'little' Hash type SIGHASH ALL result += 1 .to bytes 4, 'little' return result def sign input self, input index: int, private key: int : \"\"\"Sign specific input\"\"\" Serialize for signing preimage = self.serialize for signature input index Double SHA-256 sighash = hashlib.sha256 hashlib.sha256 preimage .digest .digest Sign signature = ECDSA.sign sighash, private key Create DER-encoded signature + SIGHASH type signature der = self.der encode signature signature + b'\\x01' SIGHASH ALL Create scriptSig signature + public key public key = point multiply private key, G pubkey bytes = self.serialize public key public key script sig = len signature der .to bytes 1, 'little' + signature der + len pubkey bytes .to bytes 1, 'little' + pubkey bytes self.inputs input index 'script sig' = script sig @staticmethod def der encode signature signature: Tuple int, int -> bytes: \"\"\"DER encode ECDSA signature\"\"\" r, s = signature Encode r r bytes = r.to bytes r.bit length + 7 // 8, 'big' if r bytes 0 & 0x80: Add 0x00 if high bit set r bytes = b'\\x00' + r bytes Encode s s bytes = s.to bytes s.bit length + 7 // 8, 'big' if s bytes 0 & 0x80: s bytes = b'\\x00' + s bytes DER structure: 0x30 total-length 0x02 r-length r 0x02 s-length s result = b'\\x02' + len r bytes .to bytes 1, 'little' + r bytes + b'\\x02' + len s bytes .to bytes 1, 'little' + s bytes result = b'\\x30' + len result .to bytes 1, 'little' + result return result @staticmethod def serialize public key public key: Tuple int, int , compressed=True -> bytes: \"\"\"Serialize public key\"\"\" x, y = public key if compressed: Compressed: 0x02 or 0x03 depending on y parity + x prefix = b'\\x02' if y % 2 == 0 else b'\\x03' return prefix + x.to bytes 32, 'big' else: Uncompressed: 0x04 + x + y return b'\\x04' + x.to bytes 32, 'big' + y.to bytes 32, 'big' Example if name == \" main \": print \"=== Bitcoin Transaction Signing Example ===\\n\" Create transaction tx = BitcoinTransaction Add input spending previous output prev tx id = \"a1b2c3d4\" 16 32-byte transaction ID tx.add input prev tx id, 0, b'\\x76\\xa9\\x14' + b'\\x00' 20 + b'\\x88\\xac' P2PKH Add outputs tx.add output 1000000, b'\\x76\\xa9\\x14' + b'\\x11' 20 + b'\\x88\\xac' To Bob tx.add output 500000, b'\\x76\\xa9\\x14' + b'\\x22' 20 + b'\\x88\\xac' Change Sign private key, = ECDSA.generate keypair tx.sign input 0, private key print \"Transaction signed successfully!\" print f\"Input 0 scriptSig length: len tx.inputs 0 'script sig' bytes\" --- 6. C√°c th√°ch th·ª©c v√† ƒë√°nh ƒë·ªïi th∆∞·ªùng g·∫∑p 6.1. Key Management Challenges Problem : Losing private key = losing all funds forever Statistics : - Estimated 3-4 million BTC lost forever 20% of total supply - Mostly from lost private keys Solutions : - Hardware wallets : Ledger, Trezor - dedicated secure devices - Multi-signature wallets : Require multiple keys family members, devices - Social recovery : Trusted contacts can help recover Argent wallet - Shamir's Secret Sharing : Split key into n shares, need k to recover Trade-offs : Security ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Convenience Hardware wallet Software wallet Exchange custodial Most secure Medium Least secure, most convenient 6.2. Signature Schemes Comparison | Scheme | Signature Size | Verification | Batch Verify | Linearity | Status | |--------|---------------|--------------|--------------|-----------|--------| | ECDSA | 64 bytes | Medium | No | No | Bitcoin current | | Schnorr | 64 bytes | Fast | Yes | Yes | Bitcoin Taproot | | EdDSA | 64 bytes | Fast | Yes | No | Ed25519 other chains | | BLS | 48 bytes G1 | Slow | Yes | Yes | Ethereum 2.0 | | Aggregate | ~48-64 bytes for all | Fast | Built-in | Yes | Future | ECDSA Limitations : - Malleable signatures - No batch verification - Large multisig transactions Schnorr Advantages Bitcoin Taproot upgrade : - Non-malleable - Batch verification verify multiple signatures at once - Key aggregation n keys ‚Üí 1 aggregate key - Better privacy multisig looks like single-sig 6.3. Side-Channel Attacks Timing Attacks : - Measure time taken for signature generation - Can leak information about private key - Mitigation : Constant-time implementations Power Analysis : - Measure power consumption during signing - Can extract private key from hardware wallets - Mitigation : Randomized algorithms, physical shielding Fault Attacks : - Induce hardware faults during signing voltage glitching - Can reveal private key - Real example : PS3 hack used fault to extract signing key 6.4. Nonce Generation Failures Biased Nonces : Android Bitcoin wallets 2013 used weak random number generation: - Predictable nonces - Private keys extracted - Funds stolen Solution : Deterministic nonces RFC 6979 k = HMAC-SHA256 private key, message hash Pro: No randomness needed, reproducible Con: If hash function broken, could be problematic 6.5. Transaction Malleability Historical Issue Mt. Gox Incident partial cause : - Attackers modified transaction signatures - Changed transaction IDs - Exchange software confused, thought transactions failed - Sent funds again ‚Üí double payment Fix : SegWit Segregated Witness - Separates signature data from transaction data - TXID computed without signatures - Malleability no longer affects TXID --- 7. C√°c kh√°i ni·ªám li√™n quan 7.1. Zero-Knowledge Proofs Extension of digital signatures concept: Digital Signature : Prove \"I know private key\" + message Zero-Knowledge Proof : Prove \"I know secret X\" without revealing X Example: zk-SNARKs Zcash : - Prove transaction valid without revealing amounts/addresses - Uses elliptic curve pairings - Much more complex than ECDSA 7.2. Ring Signatures Monero Concept : Signature could be from any member of a \"ring\" of public keys Ring: Alice's key, Bob's key, Charlie's key Signature proves: \"One of these three people signed\" But doesn't reveal which one! Privacy benefit : Sender anonymity Trade-off : Larger signatures multiple keys 7.3. Blind Signatures Signer signs message without seeing its content: Process : 1. Alice blinds message: \\ m' = \\text blind m, r \\ 2. Signer signs: \\ \\sigma' = \\text sign m' \\ 3. Alice unblinds: \\ \\sigma = \\text unblind \\sigma', r \\ 4. \\ \\sigma \\ is valid signature on \\ m \\ ! Application : E-cash anonymous digital money 7.4. Threshold Signatures vs Multi-Signatures Multi-Signature : - Each party signs independently - Combine n signatures - Size: \\ O n \\ Threshold Signature : - Parties run interactive protocol - Generate single signature - Size: \\ O 1 \\ Example : 3-of-5 MultiSig: 3 full signatures + 5 public keys ‚âà 450 bytes 3-of-5 Threshold: 1 signature + 1 aggregate public key ‚âà 96 bytes --- 8. ‚≠ê C√°c b√†i b√°o v√† whitepaper n·ªÅn t·∫£ng | Paper | Year | Author s | Contribution | |-------|------|-----------|--------------| | \"New Directions in Cryptography\" | 1976 | Diffie, Hellman | Invented public-key cryptography concept | | \"A Method for Obtaining Digital Signatures\" | 1978 | Rivest, Shamir, Adelman | RSA algorithm - first practical PKC | | \"A Digital Signature Based on a Conventional Encryption Function\" | 1987 | Ralph Merkle | Merkle signature scheme | | \"Elliptic Curve Cryptosystems\" | 1985 | Neal Koblitz | ECC foundation | | \"Elliptic Curve Discrete Logarithm Problem\" | 1985 | Victor Miller | ECC foundation | | \"Digital Signature Standard DSS \" | 1994 | NIST FIPS 186 | ECDSA standardization | | \"SEC 2: Recommended Elliptic Curve Domain Parameters\" | 2010 | SECG | secp256k1 specification Bitcoin | | \"Deterministic Usage of DSA and ECDSA\" | 2013 | RFC 6979 | Deterministic nonce generation | | \"Schnorr Signatures for Bitcoin\" | 2018 | Pieter Wuille BIP 340 | Schnorr in Bitcoin | | \"Compact Multi-Signatures for Smaller Blockchains\" | 2018 | Boneh et al. | BLS signatures | Essential Reading : 1. Diffie-Hellman paper: Revolutionary PKC concept 2. NIST FIPS 186-4: Authoritative ECDSA spec 3. RFC 6979: How to safely generate nonces 4. BIP 340: Bitcoin's Schnorr implementation --- 9. üé® Minh h·ªça v√† tham kh·∫£o h√¨nh ·∫£nh | Description | Source | Notes | |-------------|--------|-------| | Elliptic curve visualization | Andrea Corbellini's ECC Series https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/ | Best visual introduction to ECC | | ECDSA algorithm flow | Bitcoin Developer Guide https://developer.bitcoin.org/devguide/transactions.html | Practical implementation | | Key generation process | Mastering Bitcoin Ch4 https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch04.asciidoc | From private key to address | | Digital signature process | Practical Cryptography http://www.crypto-it.net/eng/theory/digital-signature.html | Step-by-step visualization | | secp256k1 curve plot | Desmos secp256k1 https://www.desmos.com/calculator/ialhd71we3 | Interactive curve exploration | Interactive Tools : - Anders Brownworth - Public/Private Keys https://andersbrownworth.com/blockchain/public-private-keys - Visual demo - Bitcoin Address Generator https://www.bitaddress.org - See key generation live USE OFFLINE! - ECC Point Calculator https://www.desmos.com/calculator/ialhd71we3 - Play with elliptic curves --- 10. T√≥m t·∫Øt v√† ƒëi·ªÉm ch√≠nh Core Concepts : 1. Digital signatures provide authentication, non-repudiation, v√† integrity 2. Based on public-key cryptography v·ªõi key pairs public, private 3. ECDSA on secp256k1 is Bitcoin's signature scheme 4. Security relies on hardness of elliptic curve discrete logarithm problem Technical Foundation : - Key generation: Private key random , Public key = private √ó G - Signing: \\ r, s \\ where \\ s = k^ -1 e + rd A \\mod n \\ - Verification: Check \\ r \\stackrel ? = u 1 G + u 2 Q A .x \\mod n \\ - ~128-bit security level 256-bit keys Blockchain Applications : - Transaction authorization: Prove you own coins - Address generation: Hash of public key - Smart contract interaction: Signatures trigger execution - Multi-signature wallets: Multiple keys control funds Security Considerations : - NEVER reuse nonces k - leads to private key exposure - Quantum computing threat Shor's algorithm - timeline: 10-30 years - Key management critical - loss = permanent fund loss - Side-channel attacks on hardware implementations Modern Improvements : - Schnorr signatures Bitcoin Taproot : Better privacy, batch verification - Deterministic nonces RFC 6979 : No randomness failures - Threshold signatures: n-of-m without revealing structure - BLS signatures Ethereum 2.0 : Signature aggregation Key Takeaway : Digital signatures are the cryptographic primitive that enables decentralized ownership and control in blockchain - transforming \"possession of private key\" into \"control of digital assets\" through mathematical proofs. --- ‚úÖ End of Lecture 00.03 Next : Chapter 01 - Bitcoin: Architecture v√† Proof-of-Work --- References 1. Diffie, W., & Hellman, M. 1976 . New directions in cryptography . IEEE transactions on Information Theory, 22 6 , 644-654. 2. Koblitz, N. 1987 . Elliptic curve cryptosystems . Mathematics of computation, 48 177 , 203-209. 3. Johnson, D., Menezes, A., & Vanstone, S. 2001 . The elliptic curve digital signature algorithm ECDSA . International journal of information security, 1 1 , 36-63. 4. Pornin, T. 2013 . RFC 6979: Deterministic usage of the digital signature algorithm DSA and elliptic curve digital signature algorithm ECDSA . 5. Wuille, P., Nick, J., & Ruffing, T. 2020 . BIP 340: Schnorr signatures for secp256k1 . 6. Nakamoto, S. 2008 . Bitcoin: A peer-to-peer electronic cash system .",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter00/blockchain-chapter00/00_03_Digital_Signatures/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter01/blockchain-chapter01/01_00_Bitcoin_Architecture",
    "title": "Lecture 01.00: Bitcoin Architecture - H·ªá th·ªëng ti·ªÅn ƒëi·ªán t·ª≠ phi t·∫≠p trung ƒë·∫ßu ti√™n",
    "chapter": "01",
    "order": 1,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Bitcoin Architecture - H·ªá th·ªëng ti·ªÅn ƒëi·ªán t·ª≠ phi t·∫≠p trung ƒë·∫ßu ti√™n 1. T·ªïng quan v·ªÅ kh√°i ni·ªám V√†o ng√†y 31 th√°ng 10 nƒÉm 2008, gi·ªØa cu·ªôc kh·ªßng ho·∫£ng t√†i ch√≠nh to√†n c·∫ßu, m·ªôt ng∆∞·ªùi ho·∫∑c nh√≥m ng∆∞·ªùi ·∫©n danh v·ªõi b√∫t danh Satoshi Nakamoto ƒë√£ publish m·ªôt whitepaper c√≥ ti√™u ƒë·ªÅ \"Bitcoin: A Peer-to-Peer Electronic Cash System\" l√™n mailing list v·ªÅ m·∫≠t m√£ h·ªçc. Ch√≠n trang gi·∫•y n√†y ƒë√£ thay ƒë·ªïi l·ªãch s·ª≠ c√¥ng ngh·ªá v√† t√†i ch√≠nh m√£i m√£i. Bitcoin kh√¥ng ch·ªâ l√† m·ªôt lo·∫°i ti·ªÅn ƒëi·ªán t·ª≠ - n√≥ l√† first successful implementation c·ªßa m·ªôt h·ªá th·ªëng thanh to√°n ƒëi·ªán t·ª≠ phi t·∫≠p trung, gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ double-spending m√† kh√¥ng c·∫ßn b√™n th·ª© ba tin c·∫≠y. Tr∆∞·ªõc Bitcoin, m·ªçi n·ªó l·ª±c t·∫°o ra digital cash ƒë·ªÅu th·∫•t b·∫°i v√¨ m·ªôt trong hai l√Ω do: 1. Ph·ª• thu·ªôc v√†o central authority e-gold, DigiCash - c√≥ th·ªÉ b·ªã ƒë√≥ng c·ª≠a 2. Kh√¥ng gi·∫£i quy·∫øt ƒë∆∞·ª£c double-spending trong m√¥i tr∆∞·ªùng ph√¢n t√°n Bitcoin elegant solution k·∫øt h·ª£p nhi·ªÅu c√¥ng ngh·ªá ƒë√£ t·ªìn t·∫°i cryptographic hashing, digital signatures, peer-to-peer networks, consensus mechanisms theo m·ªôt c√°ch ho√†n to√†n m·ªõi: Core Innovation - Nakamoto Consensus : Thay v√¨ d·ª±a v√†o m·ªôt central server ƒë·ªÉ prevent double-spending, Bitcoin s·ª≠ d·ª•ng: - Blockchain : M·ªôt public ledger ch·ª©a to√†n b·ªô transaction history - Proof-of-Work : M·ªôt lottery-based consensus mechanism ƒë·∫£m b·∫£o nodes ƒë·ªìng √Ω v·ªÅ transaction order - Economic Incentives : Miners ƒë∆∞·ª£c reward b·∫±ng newly created bitcoin v√† transaction fees - Cryptographic Security : Digital signatures ƒë·∫£m b·∫£o ch·ªâ owner c·ªßa coins m·ªõi c√≥ th·ªÉ spend Bitcoin's Design Goals theo whitepaper : 1. Peer-to-peer : Direct transactions kh√¥ng c·∫ßn intermediary 2. Decentralized : Kh√¥ng c√≥ central point of control ho·∫∑c failure 3. Trustless : Kh√¥ng c·∫ßn trust b·∫•t k·ª≥ party n√†o 4. Censorship-resistant : Kh√¥ng ai c√≥ th·ªÉ block transactions 5. Limited supply : T·ªëi ƒëa 21 million bitcoins 6. Pseudonymous : Transactions kh√¥ng tr·ª±c ti·∫øp linked v·ªõi real-world identities Historical Context : Bitcoin kh√¥ng xu·∫•t hi·ªán trong ch√¢n kh√¥ng. N√≥ x√¢y d·ª±ng tr√™n decades of research: Cypherpunk Movement 1990s : - Nh√≥m cryptographers v√† activists ·ªßng h·ªô privacy-enhancing technologies - Mailing list discussions v·ªÅ digital cash - Notable members: Adam Back, Nick Szabo, Hal Finney Previous Digital Cash Attempts : - DigiCash 1990 : David Chaum's company, centralized, failed 1998 - b-money 1998 : Wei Dai's proposal, theoretical only - Bit Gold 2005 : Nick Szabo's proposal, never implemented - Hashcash 1997 : Adam Back's proof-of-work system Bitcoin precursor Bitcoin Timeline : - Oct 31, 2008 : Whitepaper published - Jan 3, 2009 : Genesis block mined block 0 - Embedded message: \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks\" - Comment on financial crisis v√† central banking - Jan 12, 2009 : First transaction Satoshi ‚Üí Hal Finney, 10 BTC - May 22, 2010 : First real-world transaction 10,000 BTC for 2 pizzas, ~$41 - Dec 2010 : Satoshi disappears from public - 2011-present : Bitcoin ecosystem grows exponentially Impact : - Market cap: >$500 billion 2024 - Spawned thousands of altcoins - Catalyzed blockchain research - Influenced monetary policy discussions - Created entirely new industry --- 2. Hi·ªÉu bi·∫øt tr·ª±c quan 2.1. Bitcoin nh∆∞ m·ªôt \"Digital Gold\" Bitcoin th∆∞·ªùng ƒë∆∞·ª£c g·ªçi l√† \"digital gold\" - h√£y so s√°nh: Gold V√†ng : - Scarce: Kh√≥ t√¨m v√† khai th√°c - Durable: Kh√¥ng b·ªã ph√° h·ªßy theo th·ªùi gian - Divisible: C√≥ th·ªÉ chia nh·ªè - Fungible: M·ªói gram v√†ng = m·ªói gram v√†ng kh√°c - Valuable: ƒê∆∞·ª£c c√¥ng nh·∫≠n globally - Physical: C·∫ßn storage v√† transport Bitcoin : - Scarce: Ch·ªâ 21 million coins, hard-coded - Durable: T·ªìn t·∫°i mi·ªÖn blockchain c√≤n t·ªìn t·∫°i - Divisible: Chia ƒë∆∞·ª£c ƒë·∫øn 8 decimal places 0.00000001 BTC = 1 satoshi - Fungible: M·ªói BTC = m·ªói BTC kh√°c v·ªÅ m·∫∑t k·ªπ thu·∫≠t - Valuable: ƒê∆∞·ª£c c√¥ng nh·∫≠n b·ªüi millions of users - Digital: Ch·ªâ c·∫ßn internet connection 2.2. How Bitcoin Works - Simple Analogy T∆∞·ªüng t∆∞·ª£ng Bitcoin nh∆∞ m·ªôt public town square v·ªõi m·ªôt cu·ªën s·ªï kh·ªïng l·ªì : The Ledger Blockchain : - M·ªôt cu·ªën s·ªï c√¥ng khai n·∫±m ·ªü gi·ªØa qu·∫£ng tr∆∞·ªùng - Ai c≈©ng c√≥ th·ªÉ ƒë·ªçc to√†n b·ªô l·ªãch s·ª≠ - M·ªói trang block ch·ª©a ~2000 transactions - M·ªói trang ƒë∆∞·ª£c \"seal\" v·ªõi special code hash The Miners Network Nodes : - H√†ng ngh√¨n ng∆∞·ªùi ƒë·ª©ng xung quanh qu·∫£ng tr∆∞·ªùng - H·ªç compete ƒë·ªÉ ƒë∆∞·ª£c vi·∫øt trang ti·∫øp theo v√†o s·ªï - Ph·∫£i gi·∫£i m·ªôt puzzle to√°n h·ªçc c·ª±c kh√≥ Proof-of-Work - Ng∆∞·ªùi ƒë·∫ßu ti√™n gi·∫£i ƒë∆∞·ª£c puzzle: - ƒê∆∞·ª£c vi·∫øt trang m·ªõi - Nh·∫≠n reward 6.25 BTC hi·ªán t·∫°i + fees - Everyone else verifies v√† accepts Transactions Chuy·ªÉn ti·ªÅn : Alice mu·ªën g·ª≠i 1 BTC cho Bob: 1. Alice broadcast: \"I, Alice, send 1 BTC to Bob\" - K√Ω b·∫±ng digital signature ch·ªâ Alice c√≥ th·ªÉ t·∫°o 2. Miners nh·∫∑t transaction l√™n - Verify signature: \"This really from Alice?\" - Check balance: \"Does Alice have 1 BTC?\" 3. Miners ƒë∆∞a transaction v√†o block m·ªõi - Compete to solve puzzle - Winner broadcasts block 4. Other nodes verify v√† accept - Transaction now confirmed! - Bob c√≥ th·ªÉ spend 1 BTC Security Through Work : - ƒê·ªÉ thay ƒë·ªïi history cheat , attacker ph·∫£i: 1. Rewrite block ch·ª©a transaction ƒë√≥ 2. Rewrite ALL blocks after ƒë√≥ v√¨ ch√∫ng linked 3. L√†m faster than to√†n b·ªô honest network combined - V·ªõi h√†ng ngh√¨n miners, virtually impossible! 2.3. UTXO Model - \"Digital Cash Chips\" Bitcoin kh√¥ng d√πng \"account balances\" nh∆∞ bank. Thay v√†o ƒë√≥, d√πng UTXO Unspent Transaction Output model - gi·ªëng nh∆∞ cash chips: Bank Account Model NOT Bitcoin : Alice's account: $100 Transfer $30 to Bob Alice's account: $70 Bob's account: $30 UTXO Model Bitcoin : Alice c√≥: 50 BTC chip 30 BTC chip 20 BTC chip Total: 100 BTC Alice mu·ªën g·ª≠i 60 BTC cho Bob: 1. Grab 50 BTC v√† 30 BTC chips total 80 BTC 2. Create new transaction: Inputs: 50 BTC + 30 BTC = 80 BTC Outputs: 60 BTC ‚Üí Bob 19.99 BTC ‚Üí Alice change 0.01 BTC ‚Üí Miner fee 3. Destroy old chips 50 and 30 4. Create new chips 60 and 19.99 Result: Alice c√≥: 20 BTC 19.99 BTC = 39.99 BTC Bob c√≥: 60 BTC = 60 BTC Advantages : - Better privacy kh√¥ng c√≥ single \"account\" - Parallel processing different UTXOs processed independently - Simpler to verify each UTXO spent exactly once --- 3. N·ªÅn t·∫£ng k·ªπ thu·∫≠t 3.1. Bitcoin Network Architecture Bitcoin l√† m·ªôt peer-to-peer network v·ªõi multiple types of nodes: Node Types : 1. Full Nodes ~10,000-15,000 active : - Store complete blockchain ~500 GB - Validate all transactions v√† blocks - Relay transactions v√† blocks - Enforce consensus rules - Can independently verify entire history 2. Mining Nodes subset of full nodes : - Full node capabilities + - Solve Proof-of-Work puzzle - Create new blocks - Receive block rewards 3. Light Nodes SPV - Simplified Payment Verification : - Store only block headers ~100 MB - Cannot fully validate transactions - Trust full nodes for validation - Good for mobile wallets 4. Archive Nodes : - Full nodes + complete UTXO set history - Required for blockchain explorers - ~1 TB+ storage Network Communication : Internet ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ Node A Node B ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ Node C ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ Node D Node E Gossip Protocol : - M·ªói node connect v·ªõi 8-125 peers - New transactions broadcast ƒë·∫øn all peers - Peers forward ƒë·∫øn their peers - Exponential propagation ~7 seconds to reach 95% network 3.2. Bitcoin Transaction Structure Transaction Components : Transaction ‚îú‚îÄ‚îÄ Version 4 bytes ‚îú‚îÄ‚îÄ Input Count variable ‚îú‚îÄ‚îÄ Inputs variable ‚îÇ ‚îú‚îÄ‚îÄ Previous TXID 32 bytes - Reference to previous transaction ‚îÇ ‚îú‚îÄ‚îÄ Output Index 4 bytes - Which output of previous tx ‚îÇ ‚îú‚îÄ‚îÄ ScriptSig variable - Signature v√† public key ‚îÇ ‚îî‚îÄ‚îÄ Sequence 4 bytes ‚îú‚îÄ‚îÄ Output Count variable ‚îú‚îÄ‚îÄ Outputs variable ‚îÇ ‚îú‚îÄ‚îÄ Amount 8 bytes - In satoshis ‚îÇ ‚îî‚îÄ‚îÄ ScriptPubKey variable - Locking script ‚îî‚îÄ‚îÄ Locktime 4 bytes Example Transaction : json \"txid\": \"a1b2c3d4e5f6...\", \"version\": 1, \"locktime\": 0, \"vin\": \"txid\": \"previous tx id\", \"vout\": 0, \"scriptSig\": \"asm\": \"3045... 0279...\", \"hex\": \"483045...\" , \"sequence\": 4294967295 , \"vout\": \"value\": 0.5, \"n\": 0, \"scriptPubKey\": \"asm\": \"OP DUP OP HASH160 ab68025513...\", \"hex\": \"76a914ab68...\", \"type\": \"pubkeyhash\", \"address\": \"1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA\" 3.3. Bitcoin Script Language Bitcoin s·ª≠ d·ª•ng Script - m·ªôt stack-based, non-Turing-complete programming language ƒë·ªÉ define spending conditions. Why Non-Turing-Complete? - Prevents infinite loops - Guarantees termination - Makes resource estimation possible Common Script Types : 1. Pay-to-Public-Key-Hash P2PKH - Standard transaction: ScriptPubKey Locking Script : OP DUP OP HASH160 OP EQUALVERIFY OP CHECKSIG ScriptSig Unlocking Script : Combined execution: OP DUP OP HASH160 OP EQUALVERIFY OP CHECKSIG Execution Steps : Stack: Operation: pushed Sig pushed Sig, PubKey OP DUP duplicate top Sig, PubKey, PubKey OP HASH160 hash top Sig, PubKey, Hash pushed Sig, PubKey, Hash, PKH OP EQUALVERIFY check equal Sig, PubKey OP CHECKSIG verify signature 1 Success! 2. Pay-to-Script-Hash P2SH - Multi-signature: ScriptPubKey: OP HASH160 OP EQUAL ScriptSig: ... 3. Pay-to-Witness-Public-Key-Hash P2WPKH - SegWit: ScriptPubKey: OP 0 Witness: 3.4. Block Structure Block Components : Block ‚îú‚îÄ‚îÄ Block Header 80 bytes ‚îÇ ‚îú‚îÄ‚îÄ Version 4 bytes ‚îÇ ‚îú‚îÄ‚îÄ Previous Block Hash 32 bytes ‚îÇ ‚îú‚îÄ‚îÄ Merkle Root 32 bytes ‚îÇ ‚îú‚îÄ‚îÄ Timestamp 4 bytes ‚îÇ ‚îú‚îÄ‚îÄ Difficulty Target 4 bytes ‚îÇ ‚îî‚îÄ‚îÄ Nonce 4 bytes ‚îî‚îÄ‚îÄ Transaction Data variable, ~1-2 MB ‚îú‚îÄ‚îÄ Transaction Count variable ‚îî‚îÄ‚îÄ Transactions variable Block Header Breakdown : Version: 00000020 hex = 32 decimal Previous Hash: 000000000000000000041fe... Merkle Root: 7f16c5962e8bd963659c793... Timestamp: 5e7e5e5e hex = 2020-03-27 12:34:06 UTC Bits Difficulty : 171007ea Nonce: 282c7f00 hex = 673668864 decimal Genesis Block Block 0 : \"hash\": \"000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\", \"timestamp\": \"2009-01-03 18:15:05\", \"nonce\": 2083236893, \"difficulty\": 1, \"coinbase\": \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks\" 3.5. UTXO Set Global State : Bitcoin's state = set c·ªßa t·∫•t c·∫£ unspent transaction outputs UTXOs UTXO Entry : UTXO = txid: transaction ID, vout: output index, amount: value in satoshis, scriptPubKey: spending condition, height: block height created UTXO Set Statistics 2024 : - Total UTXOs: ~80-100 million - Total size: ~5-6 GB - Total value: ~19.5 million BTC Performance : - Full nodes maintain UTXO set in memory fast lookups - Validating transaction = checking inputs exist in UTXO set - Adding block: - Remove spent UTXOs inputs - Add new UTXOs outputs --- 4. C√¥ng th·ª©c to√°n h·ªçc v√† m·∫≠t m√£ h·ªçc 4.1. Bitcoin Address Generation Full Process : \\ \\begin align \\text Private Key &\\xrightarrow \\text random k \\in 1, n-1 \\\\ \\text Public Key &= k \\times G = x, y \\\\ \\text Compressed PubKey &= \\begin cases \\text 0x02 || x & \\text if y \\text even \\\\ \\text 0x03 || x & \\text if y \\text odd \\end cases \\\\ \\text PubKey Hash &= \\text RIPEMD160 \\text SHA256 \\text PubKey \\\\ \\text Versioned Hash &= \\text 0x00 || \\text PubKey Hash \\\\ \\text Checksum &= \\text SHA256 \\text SHA256 \\text Versioned Hash :4 \\\\ \\text Address Bytes &= \\text Versioned Hash || \\text Checksum \\\\ \\text Bitcoin Address &= \\text Base58 \\text Address Bytes \\end align \\ Example : Private Key hex : 18e14a7b6a307f426a94f8114701e7c8e774e7f9a47e2c2035db29a206321725 Public Key uncompressed : 04 50863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b2352 2cd470243453a299fa9e77237716103abc11a1df38855ed6f2ee187e9c582ba6 Public Key Hash RIPEMD160 of SHA256 : 010966776006953d5567439e5e39f86a0d273bee Address Base58Check : 16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM 4.2. Difficulty Adjustment Bitcoin adjusts mining difficulty m·ªói 2016 blocks ~2 weeks ƒë·ªÉ maintain 10-minute block time. Formula : \\ \\text New Difficulty = \\text Old Difficulty \\times \\frac \\text 2 weeks \\text Actual Time \\ More precisely: \\ \\text New Target = \\text Old Target \\times \\frac \\text Actual Time 2016 blocks \\text Expected Time 20160 minutes \\ Constraints : - Maximum adjustment: 4x per period up or down - Minimum difficulty: 1 genesis block - Maximum target: 0x00000000FFFF0000000000000000000000000000000000000000000000000000 Example Calculation : Old Difficulty: 20,000,000,000,000 2016 blocks took: 14 days = 20,160 minutes exactly on target! New Difficulty = 20,000,000,000,000 √ó 20,160 / 20,160 = 20,000,000,000,000 no change If blocks came faster 12 days : New Difficulty = 20,000,000,000,000 √ó 20,160 / 17,280 = 23,333,333,333,333 harder 4.3. Block Reward v√† Supply Block Subsidy coinbase reward : \\ \\text Subsidy h = \\frac 50 \\text BTC 2^ \\lfloor h / 210000 \\rfloor \\ Where \\ h \\ = block height Halving Schedule : Blocks 0 - 209,999: 50 BTC per block Blocks 210,000 - 419,999: 25 BTC per block Blocks 420,000 - 629,999: 12.5 BTC per block Blocks 630,000 - 839,999: 6.25 BTC per block current, 2024 Blocks 840,000 - 1,049,999: 3.125 BTC per block next halving ~2024 ... After 64 halvings: 0 BTC around year 2140 Total Supply : \\ \\text Total BTC = \\sum i=0 ^ 63 210000 \\times \\frac 50 2^i = 21,000,000 \\text BTC \\ Derivation : \\ \\begin align S &= 210000 \\times 50 \\times \\left 1 + \\frac 1 2 + \\frac 1 4 + \\frac 1 8 + \\cdots \\right \\\\ &= 210000 \\times 50 \\times \\frac 1 1 - 1/2 \\\\ &= 210000 \\times 50 \\times 2 \\\\ &= 21,000,000 \\end align \\ Actual Supply slightly less : - Due to lost coins - Mining bugs some miners didn't claim full reward - Estimated circulating: ~19.5 million BTC 2024 4.4. Transaction Fees Fee Calculation : \\ \\text Fee = \\sum \\text Inputs - \\sum \\text Outputs \\ Fee Rate : \\ \\text Fee Rate = \\frac \\text Fee \\text Transaction Size bytes \\quad \\text sat/vByte \\ SegWit Virtual Size : \\ \\text vSize = \\frac \\text Base Size \\times 3 + \\text Total Size 4 \\ Economic Model : - Users bid fees ƒë·ªÉ get prioritized - Miners select highest fee/byte transactions - Fee market emerges naturally - High congestion ‚Üí high fees Historical Fees : - 2010-2016: ~0.0001 BTC ~$0.01 - 2017 peak: ~$50 per transaction - 2021 peak: ~$60 per transaction - 2024 average: ~$1-5 per transaction --- 5. Implementation Insight 5.1. Simple Bitcoin Transaction Python python import hashlib import ecdsa from typing import List, Tuple class BitcoinTransaction: def init self : self.version = 1 self.inputs: List dict = self.outputs: List dict = self.locktime = 0 def add input self, prev txid: str, prev index: int, scriptPubKey: bytes, amount: int : \"\"\"Add input UTXO to spend \"\"\" self.inputs.append 'prev txid': bytes.fromhex prev txid , 'prev index': prev index, 'scriptPubKey': scriptPubKey, 'amount': amount, 'scriptSig': b'' def add output self, address: str, amount: int : \"\"\"Add output new UTXO \"\"\" Create P2PKH scriptPubKey pubkey hash = self.address to pubkey hash address scriptPubKey = b'\\x76' + OP DUP b'\\xa9' + OP HASH160 b'\\x14' + Push 20 bytes pubkey hash + b'\\x88' + OP EQUALVERIFY b'\\xac' OP CHECKSIG self.outputs.append 'amount': amount, 'scriptPubKey': scriptPubKey @staticmethod def address to pubkey hash address: str -> bytes: \"\"\"Decode Bitcoin address to get pubkey hash\"\"\" Base58 decode simplified In production, use proper Base58Check import base58 decoded = base58.b58decode check address return decoded 1: Skip version byte def serialize for signing self, input index: int -> bytes: \"\"\"Serialize transaction for signing\"\"\" result = b'' Version result += self.version.to bytes 4, 'little' Input count result += self.var int len self.inputs Inputs for i, inp in enumerate self.inputs : result += inp 'prev txid' ::-1 Little-endian result += inp 'prev index' .to bytes 4, 'little' Include scriptPubKey for input being signed if i == input index: script = inp 'scriptPubKey' result += self.var int len script result += script else: result += b'\\x00' Empty script result += 0xFFFFFFFF .to bytes 4, 'little' Sequence Output count result += self.var int len self.outputs Outputs for out in self.outputs: result += out 'amount' .to bytes 8, 'little' result += self.var int len out 'scriptPubKey' result += out 'scriptPubKey' Locktime result += self.locktime.to bytes 4, 'little' Hash type SIGHASH ALL result += 1 .to bytes 4, 'little' return result @staticmethod def var int n: int -> bytes: \"\"\"Variable-length integer encoding\"\"\" if n bytes: \"\"\"Serialize complete signed transaction\"\"\" result = b'' Version result += self.version.to bytes 4, 'little' Input count result += self.var int len self.inputs Inputs for inp in self.inputs: result += inp 'prev txid' ::-1 result += inp 'prev index' .to bytes 4, 'little' result += self.var int len inp 'scriptSig' result += inp 'scriptSig' result += 0xFFFFFFFF .to bytes 4, 'little' Output count result += self.var int len self.outputs Outputs for out in self.outputs: result += out 'amount' .to bytes 8, 'little' result += self.var int len out 'scriptPubKey' result += out 'scriptPubKey' Locktime result += self.locktime.to bytes 4, 'little' return result def get txid self -> str: \"\"\"Calculate transaction ID\"\"\" serialized = self.serialize hash result = hashlib.sha256 hashlib.sha256 serialized .digest .digest return hash result ::-1 .hex Little-endian Example usage if name == \" main \": print \"=== Bitcoin Transaction Example ===\\n\" Create transaction tx = BitcoinTransaction Add input spending previous output prev txid = \"a1b2c3d4\" 16 Example TXID scriptPubKey = bytes.fromhex \"76a914\" + \"00\" 20 + \"88ac\" P2PKH tx.add input prev txid, 0, scriptPubKey, 100000000 1 BTC in satoshis Add outputs tx.add output \"1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa\", 50000000 0.5 BTC to Bob tx.add output \"1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2\", 49900000 0.499 BTC change Fee: 0.001 BTC 100,000 satoshis Sign use your own private key in production! private key = \"18e14a7b6a307f426a94f8114701e7c8e774e7f9a47e2c2035db29a206321725\" tx.sign input 0, private key Serialize raw tx = tx.serialize txid = tx.get txid print f\"Transaction ID: txid \" print f\"Raw transaction: raw tx.hex :100 ...\" print f\"Size: len raw tx bytes\" print f\"Fee rate: 100000 / len raw tx :.2f sat/byte\" 5.2. UTXO Set Management python from typing import Dict, Set, Tuple class UTXOSet: def init self : UTXO set: txid, vout -> amount, scriptPubKey, height self.utxos: Dict Tuple str, int , Tuple int, bytes, int = self.total supply = 0 def add utxo self, txid: str, vout: int, amount: int, scriptPubKey: bytes, height: int : \"\"\"Add new UTXO\"\"\" key = txid, vout if key in self.utxos: raise ValueError f\"UTXO txid : vout already exists!\" self.utxos key = amount, scriptPubKey, height self.total supply += amount print f\"+ Added UTXO: txid :8 ...: vout = amount/1e8:.8f BTC\" def spend utxo self, txid: str, vout: int -> Tuple int, bytes : \"\"\"Spend remove UTXO\"\"\" key = txid, vout if key not in self.utxos: raise ValueError f\"UTXO txid : vout not found!\" amount, scriptPubKey, height = self.utxos key del self.utxos key self.total supply -= amount print f\"- Spent UTXO: txid :8 ...: vout = amount/1e8:.8f BTC\" return amount, scriptPubKey def get balance self, address: str -> int: \"\"\"Get total balance for address\"\"\" Simplified: check scriptPubKey contains address hash total = 0 for txid, vout , amount, scriptPubKey, height in self.utxos.items : In production: properly decode scriptPubKey total += amount return total def apply transaction self, tx: dict, block height: int : \"\"\"Apply transaction to UTXO set\"\"\" txid = tx 'txid' Spend inputs total input = 0 for inp in tx 'inputs' : amount, scriptPubKey = self.spend utxo inp 'prev txid' , inp 'prev index' total input += amount Create outputs total output = 0 for i, out in enumerate tx 'outputs' : self.add utxo txid, i, out 'amount' , out 'scriptPubKey' , block height total output += out 'amount' Verify fee fee = total input - total output print f\"Transaction fee: fee/1e8:.8f BTC\" if fee dict: \"\"\"Get UTXO set statistics\"\"\" return 'utxo count': len self.utxos , 'total supply': self.total supply / 1e8, BTC 'avg utxo size': self.total supply / len self.utxos if self.utxos else 0 Example if name == \" main \": print \"=== UTXO Set Management Example ===\\n\" utxo set = UTXOSet Genesis coinbase block reward utxo set.add utxo \"genesis tx id\", 0, 5000000000, 50 BTC b'scriptPubKey alice', 0 print f\"\\nStats: utxo set.get stats \\n\" Alice sends 30 BTC to Bob tx1 = 'txid': 'tx1 id', 'inputs': 'prev txid': 'genesis tx id', 'prev index': 0 , 'outputs': 'amount': 3000000000, 'scriptPubKey': b'scriptPubKey bob' , 30 BTC to Bob 'amount': 1999000000, 'scriptPubKey': b'scriptPubKey alice' 19.99 BTC change print \"\\nProcessing transaction 1...\" fee1 = utxo set.apply transaction tx1, 1 print f\"\\nStats: utxo set.get stats \" --- Ti·∫øp t·ª•c v·ªõi ph·∫ßn 6-10 trong response ti·∫øp theo do gi·ªõi h·∫°n ƒë·ªô d√†i 6. C√°c th√°ch th·ª©c v√† ƒë√°nh ƒë·ªïi th∆∞·ªùng g·∫∑p 6.1. Scalability - The Biggest Challenge Problem : Bitcoin c√≥ th·ªÉ process ~7 transactions/second TPS Comparison : - Visa: ~24,000 TPS - Mastercard: ~5,000 TPS - PayPal: ~193 TPS - Bitcoin: ~7 TPS - Ethereum: ~15 TPS Why So Slow? 1. Block size limit : 1 MB legacy , ~4 MB SegWit 2. Block time : 10 minutes average 3. Broadcast overhead : All nodes must receive v√† validate Calculation : \\ \\text TPS = \\frac \\text Block Size \\text Avg TX Size \\times \\text Block Time = \\frac 1 \\text MB 250 \\text bytes \\times 600 \\text sec \\approx 7 \\text TPS \\ Scaling Debates : - Big blocks : Increase block size Bitcoin Cash approach - Pro: More transactions per block - Con: Centralization fewer can run full nodes - Layer 2 : Off-chain solutions Lightning Network - Pro: Thousands of TPS, instant, low fees - Con: Complexity, need to lock funds - SegWit : Separate signature data - Pro: Effective block size increase, fix malleability - Con: Not all wallets support 6.2. Energy Consumption Current Statistics 2024 : - Bitcoin network: ~150 TWh/year - Comparable to: Argentina's total energy consumption - Per transaction: ~700 kWh - Carbon footprint: ~65 Mt CO2/year Arguments Pro : - Secures $500B+ network - Incentivizes renewable energy miners seek cheap power - Much energy from stranded/wasted sources - Banking system uses more energy overall Arguments Con : - Environmental impact - E-waste from obsolete ASICs - Could use more efficient consensus PoS Future : - Shift to renewable energy already ~50%+ - More efficient mining hardware - Layer 2 solutions reduce on-chain transactions 6.3. Privacy Limitations Pseudonymity ‚â† Anonymity : - All transactions public - Address clustering: Link multiple addresses to same entity - Chain analysis firms Chainalysis, Elliptic - Exchange KYC links addresses to real identities Example Attack : Alice withdraws from exchange KYC'd address known ‚Üí Address A identity linked ‚Üí Sends to Address B ‚Üí Sends to Address C ‚Üí ... Chain analysis can trace entire flow! Privacy Improvements : - CoinJoin : Multiple users combine transactions - Lightning Network : Off-chain, more private - Taproot : Makes different transaction types look similar 6.4. 51% Attack Resistance Attack Cost 2024 : - Total network hash rate: ~600 EH/s - Cost to acquire 51%: ~$10-20 billion in hardware - Operating cost: ~$1 million/hour in electricity Why Attack Is Irrational : 1. Huge upfront cost 2. Attack would crash BTC price ‚Üí attacker loses money 3. Can only double-spend own transactions can't steal others' BTC 4. Community would hard fork away ‚Üí hardware becomes worthless Historical Near-Misses : - 2014: GHash.io mining pool briefly exceeded 50% - Community pressure ‚Üí pool voluntarily reduced share - Now: Top 4 pools ~55%, but pools ‚â† pool members 6.5. Lost Coins Estimated Lost : 3-4 million BTC ~20% of supply Reasons : - Lost private keys - Forgotten passwords - Dead owners without backup - Sending to wrong address no undo! - Intentional burning proof-of-burn Famous Cases : - James Howells : 7,500 BTC on hard drive in landfill ~$300M at peak - Stefan Thomas : 7,002 BTC, forgot password, 2 guesses remaining - Satoshi's coins : ~1 million BTC, never moved Economic Impact : - Reduces effective supply - Increases scarcity - Deflation over time --- 7. C√°c kh√°i ni·ªám li√™n quan 7.1. Bitcoin Forks Soft Fork : Backward-compatible protocol change - Old nodes accept blocks t·ª´ new nodes - Examples: SegWit, Taproot Hard Fork : Non-backward-compatible change - Requires all nodes upgrade - Can split blockchain - Examples: Bitcoin Cash, Bitcoin SV Major Forks : Bitcoin BTC ‚îú‚îÄ‚îÄ Bitcoin Cash BCH - 2017, 8MB blocks ‚îÇ ‚îî‚îÄ‚îÄ Bitcoin SV BSV - 2018, 128MB blocks ‚îú‚îÄ‚îÄ Bitcoin Gold BTG - 2017, ASIC-resistant ‚îî‚îÄ‚îÄ Bitcoin Diamond BCD - 2017, 8MB blocks 7.2. Lightning Network Layer 2 Concept : Off-chain payment channels How It Works : 1. Alice v√† Bob open channel: - Both deposit funds in 2-of-2 multisig on-chain 2. Transact off-chain: - Update channel state signed by both - Thousands of transactions - Instant, near-zero fees 3. Close channel: - Final state broadcast on-chain - Both receive their final balances Routing : - Multi-hop payments through network - Alice ‚Üí Bob ‚Üí Charlie ‚Üí David - Onion routing for privacy Trade-offs : - Pro: Fast, cheap, scalable - Con: Need to lock funds, complexity, must be online 7.3. Taproot Upgrade 2021 Improvements : 1. Schnorr Signatures : Replace ECDSA - Smaller signatures - Batch verification - Key aggregation 2. MAST Merklized Abstract Syntax Trees : - Complex smart contracts - Only reveal executed path - Better privacy 3. Better Privacy : - Multi-sig looks like single-sig - Complex scripts look like simple payments 7.4. Colored Coins & Tokens Concept : Represent other assets on Bitcoin blockchain Methods : - OP RETURN : Embed data in transactions 80 bytes - RGB Protocol : Client-side validation - Taro : Taproot-based assets Use Cases : - Stablecoins - NFTs - Securities - Loyalty points 7.5. BIPs Bitcoin Improvement Proposals Important BIPs : - BIP 32 : HD Wallets Hierarchical Deterministic - BIP 39 : Mnemonic seed phrases 12/24 words - BIP 44 : Multi-account HD wallet structure - BIP 141 : SegWit - BIP 340-342 : Taproot --- 8. ‚≠ê C√°c b√†i b√°o v√† whitepaper n·ªÅn t·∫£ng | Paper | Year | Author s | Contribution | |-------|------|-----------|--------------| | \"Bitcoin: A Peer-to-Peer Electronic Cash System\" | 2008 | Satoshi Nakamoto | Original whitepaper - foundation of Bitcoin | | \"Hashcash - A Denial of Service Counter-Measure\" | 2002 | Adam Back | Proof-of-work precursor | | \"B-Money\" | 1998 | Wei Dai | Conceptual cryptocurrency design | | \"Bit Gold\" | 2005 | Nick Szabo | Precursor to Bitcoin | | \"Enabling Blockchain Innovations with Pegged Sidechains\" | 2014 | Back et al. | Sidechain concept | | \"The Bitcoin Backbone Protocol\" | 2015 | Garay, Kiayias, Leonardos | Formal security analysis | | \"Analysis of the Blockchain Protocol in Asynchronous Networks\" | 2016 | Pass, Seeman, Shelat | Asynchronous security | | \"The Bitcoin Lightning Network\" | 2016 | Poon, Dryja | Layer 2 scaling | | \"Segregated Witness BIP 141 \" | 2015 | Wuille et al. | SegWit specification | | \"Schnorr Signatures for secp256k1 BIP 340 \" | 2020 | Wuille, Nick, Ruffing | Taproot foundation | Essential Reading Order : 1. Bitcoin whitepaper must-read, 9 pages 2. Hashcash paper understand PoW origins 3. Bitcoin Backbone Protocol formal security 4. Lightning Network paper understand Layer 2 5. BIP 141, 340-342 modern improvements --- 9. üé® Minh h·ªça v√† tham kh·∫£o h√¨nh ·∫£nh | Description | Source | Notes | |-------------|--------|-------| | Bitcoin transaction flow | Bitcoin.org Developer Guide https://bitcoin.org/en/developer-guide | Official documentation | | Block structure diagram | Mastering Bitcoin Ch9 https://github.com/bitcoinbook/bitcoinbook | Andreas Antonopoulos's book | | UTXO model visualization | Bitcoin Stack Exchange https://bitcoin.stackexchange.com/questions/49853 | Community explanations | | Mining process | Anders Brownworth Demo https://andersbrownworth.com/blockchain/blockchain | Interactive visualization | | Network topology | Bitnodes https://bitnodes.io/ | Live network map | | Mempool visualization | Mempool.space https://mempool.space/ | Real-time mempool | | Blockchain explorer | Blockchain.com https://www.blockchain.com/explorer | Explore transactions | | Lightning Network | 1ML.com https://1ml.com/ | LN network stats | Interactive Tools : - Bitcoin Demo https://andersbrownworth.com/blockchain/ - Best visual learning tool - Bitcoin Script Simulator https://siminchen.github.io/bitcoinIDE/build/editor.html - Script execution - Transaction Decoder https://live.blockcypher.com/btc/decodetx/ - Decode raw transactions --- 10. T√≥m t·∫Øt v√† ƒëi·ªÉm ch√≠nh Core Concepts : 1. Bitcoin l√† first successful decentralized digital currency 2. Gi·∫£i quy·∫øt double-spending kh√¥ng c·∫ßn trusted third party 3. S·ª≠ d·ª•ng Proof-of-Work consensus v√† economic incentives 4. UTXO model thay v√¨ account balances Architecture Components : - P2P Network : Gossip protocol, ~15,000 nodes - Blockchain : Append-only ledger, ~500 GB - Transactions : Digital signatures, Script language - Mining : Proof-of-Work, difficulty adjustment - Consensus : Longest chain rule, economic security Key Innovations : - Nakamoto consensus: PoW + longest chain + incentives - UTXO model: Parallel transaction processing - Script: Programmable spending conditions - Difficulty adjustment: Self-regulating security Limitations : - Scalability: ~7 TPS being addressed via Layer 2 - Energy: ~150 TWh/year shift to renewables - Privacy: Pseudonymous not anonymous - Finality: Probabilistic 6 confirmations standard Future Developments : - Lightning Network: Off-chain scaling - Taproot: Better privacy v√† smart contracts - Quantum resistance: Long-term consideration - Layer 2 innovations: Continuous improvement Key Takeaway : Bitcoin proved that decentralized digital money is possible through cryptography, game theory, v√† distributed systems - creating a new asset class v√† inspiring thousands of blockchain projects. --- ‚úÖ End of Lecture 01.00 Next : Lecture 01.01 - Proof-of-Work Deep Dive: Mining, Security, v√† Economics --- References 1. Nakamoto, S. 2008 . Bitcoin: A peer-to-peer electronic cash system . 2. Antonopoulos, A. M. 2017 . Mastering Bitcoin: Programming the Open Blockchain . O'Reilly Media. 3. Narayanan, A., et al. 2016 . Bitcoin and Cryptocurrency Technologies . Princeton University Press. 4. Garay, J., Kiayias, A., & Leonardos, N. 2015 . The bitcoin backbone protocol . EUROCRYPT 2015. 5. Poon, J., & Dryja, T. 2016 . The Bitcoin Lightning Network . White paper. 6. Bitcoin Developer Documentation: https://developer.bitcoin.org/",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter01/blockchain-chapter01/01_00_Bitcoin_Architecture/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter01/blockchain-chapter01/01_01_Proof_of_Work",
    "title": "Lecture 01.01: Proof-of-Work Deep Dive - Mining, Security, v√† Economics",
    "chapter": "01",
    "order": 2,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Proof-of-Work Deep Dive - Mining, Security, v√† Economics 1. T·ªïng quan v·ªÅ kh√°i ni·ªám Proof-of-Work PoW l√† tr√°i tim c·ªßa Bitcoin - c∆° ch·∫ø ƒë·ªìng thu·∫≠n cho ph√©p h√†ng ngh√¨n nodes ƒë·ªôc l·∫≠p ƒë·ªìng √Ω v·ªÅ transaction order m√† kh√¥ng c·∫ßn trust l·∫´n nhau. ƒê√¢y l√† m·ªôt trong nh·ªØng innovations quan tr·ªçng nh·∫•t c·ªßa Satoshi Nakamoto, m·∫∑c d√π √Ω t∆∞·ªüng c∆° b·∫£n ƒë√£ t·ªìn t·∫°i tr∆∞·ªõc ƒë√≥. Historical Context : Kh√°i ni·ªám \"proof-of-work\" l·∫ßn ƒë·∫ßu ƒë∆∞·ª£c ƒë·ªÅ xu·∫•t b·ªüi Cynthia Dwork v√† Moni Naor nƒÉm 1992 nh∆∞ m·ªôt c√°ch ch·ªëng spam email. NƒÉm 1997, Adam Back ƒë√£ ph√°t tri·ªÉn Hashcash - m·ªôt proof-of-work system ƒë∆∞·ª£c d√πng ƒë·ªÉ combat email spam v√† denial-of-service attacks. Hashcash y√™u c·∫ßu sender th·ª±c hi·ªán m·ªôt computational work nh·ªè tr∆∞·ªõc khi g·ª≠i email - kh√¥ng ƒë√°ng k·ªÉ v·ªõi ng∆∞·ªùi d√πng b√¨nh th∆∞·ªùng nh∆∞ng expensive cho spammers mu·ªën g·ª≠i millions of emails. Satoshi Nakamoto ƒë√£ brilliant adapt √Ω t∆∞·ªüng n√†y cho distributed consensus. Thay v√¨ d√πng PoW ƒë·ªÉ ch·ªëng spam, Bitcoin d√πng n√≥ ƒë·ªÉ: 1. Select block proposer : Random lottery d·ª±a tr√™n computational power 2. Prevent Sybil attacks : Attacker kh√¥ng th·ªÉ t·∫°o nhi·ªÅu fake identities ƒë·ªÉ gain control 3. Rate-limit block creation : Maintain ~10 minute block time 4. Create economic cost for attacks : Attacker ph·∫£i spend real resources hardware + electricity Core Idea - Simple but Profound : Miners compete ƒë·ªÉ t√¨m m·ªôt s·ªë g·ªçi l√† nonce sao cho khi hash block header v·ªõi nonce ƒë√≥, resulting hash nh·ªè h∆°n m·ªôt target value nh·∫•t ƒë·ªãnh: \\ \\text SHA256 \\text SHA256 \\text Block Header with Nonce Cost ‚Üí More miners join ‚Üí Difficulty increases If Revenue pprev; // Compute actual timespan int64 t nActualTimespan = pindexLast->GetBlockTime - pindexFirst->GetBlockTime ; // Constrain to 0.25x, 4x range if nActualTimespan nTargetTimespan 4 nActualTimespan = nTargetTimespan 4; // Calculate new target CBigNum bnNew; bnNew.SetCompact pindexLast->nBits ; bnNew = nActualTimespan; bnNew /= nTargetTimespan; // Ensure doesn't exceed max if bnNew > bnProofOfWorkLimit bnNew = bnProofOfWorkLimit; return bnNew.GetCompact ; Example Adjustment Block 630000 ‚Üí 632016 : Old Difficulty: 15,138,043,247,082 Blocks took: 13.5 days instead of 14 Faster than expected! New Difficulty = 15,138,043,247,082 √ó 20160 / 19440 = 15,138,043,247,082 √ó 1.037 ‚âà 15,700,000,000,000 Result: ~3.7% harder within 4x constraint 3.4. Hash Rate v√† Network Security Hash Rate : Total computational power c·ªßa network Units : - H/s = Hashes per second - KH/s = Thousand 10¬≥ - MH/s = Million 10‚Å∂ - GH/s = Billion 10‚Åπ - TH/s = Trillion 10¬π¬≤ - PH/s = Quadrillion 10¬π‚Åµ - EH/s = Quintillion 10¬π‚Å∏ Bitcoin Network 2024 : - Total hash rate: ~600 EH/s - = 600,000,000,000,000,000,000 hashes/second - = 600 quintillion hashes per second! Relationship with Difficulty : \\ \\text Hash Rate = \\frac \\text Difficulty \\times 2^ 32 600 \\text seconds \\ Security Implication : Higher hash rate = more expensive to attack Attack Cost 51% attack : Required hash rate: 51% of 600 EH/s = 306 EH/s Hardware cost: - Modern ASIC: 110 TH/s, costs ~$3,000 - Need: 306 EH/s / 110 TH/s = 2.78 million ASICs - Total: 2,780,000 √ó MATH 8.3 billion Electricity cost ongoing : - Power: 2,780,000 √ó 3,250W = 9 GW - Cost: MATH 450,000/hour - Per day: $10.8 million Total to attack for 1 day: ~ MATH 0.26B = $8.56 billion And you'd likely crash BTC price, making your investment worthless! 3.5. Mining Process - Step by Step Step 1: Construct Block Template python block template = 'version': 0x20000000, 'previousblockhash': get best block hash , 'merkleroot': None, To be computed 'time': current timestamp , 'bits': get current difficulty bits , 'nonce': 0 Step 2: Select Transactions python Select from mempool ordered by fee/byte transactions = total size = 0 total fees = 0 for tx in mempool.sort by fee rate : if total size + tx.size > MAX BLOCK SIZE: break transactions.append tx total size += tx.size total fees += tx.fee Step 3: Add Coinbase Transaction python coinbase = Transaction coinbase.add input txid='0' 64, Null input vout=0xFFFFFFFF, scriptSig=encode block height + arbitrary data coinbase.add output value=BLOCK REWARD + total fees, 6.25 BTC + fees scriptPubKey=miner address transactions.insert 0, coinbase Coinbase is first tx Step 4: Compute Merkle Root python def merkle root transactions : hashes = sha256 sha256 tx for tx in transactions while len hashes > 1: if len hashes % 2 == 1: hashes.append hashes -1 Duplicate last hashes = sha256 sha256 hashes i + hashes i+1 for i in range 0, len hashes , 2 return hashes 0 block template 'merkleroot' = merkle root transactions Step 5: Mining Loop python def mine block block template : target = bits to target block template 'bits' nonce = 0 max nonce = 2 32 4 billion while nonce honest : \\ \\frac q 1-p 1-q > q \\implies q > \\frac 1 - \\gamma 3 - 2\\gamma \\ Where Œ≥ = fraction of honest miners following attacker during ties. Worst case Œ≥ = 0, all honest miners mine on honest chain : \\ q > \\frac 1 3 = 33.3\\% \\ Best case for attacker Œ≥ = 1, all follow attacker : \\ q > \\frac 0 2 = 0\\% \\text always profitable! \\ Realistic Œ≥ ‚âà 0.5 : \\ q > \\frac 0.5 2 = 25\\% \\ Implication : Selfish mining profitable v·ªõi ~25-33% hash power, lower than 51% threshold! 4.4. 51% Attack - Double Spend Probability Scenario : Attacker controls fraction q of hash power, wants to double-spend. Attack Process : 1. Send transaction to merchant buy item 2. Merchant waits for z confirmations 3. Attacker secretly mines alternative chain without that transaction 4. If attacker catches up, broadcasts longer chain ‚Üí double spend! Success Probability Satoshi's analysis : \\ P \\text catch-up = \\begin cases 1 & \\text if q \\geq 0.5 \\\\ \\left \\frac q 1-q \\right ^z & \\text if q 50% for guaranteed success 4.5. Variance v√† Mining Pool Economics Solo Mining Variance : V·ªõi hash rate h, network hash rate H, block time T = 600s: Expected blocks per day : \\ E \\text blocks = \\frac h H \\times \\frac 86400 600 = \\frac 144h H \\ Example : 100 TH/s miner, network 600 EH/s: \\ E \\text blocks/day = \\frac 144 \\times 100 \\times 10^ 12 600 \\times 10^ 18 = 0.024 \\text blocks/day \\ Mean time to find block : \\ \\frac 1 0.024 \\text days \\approx 42 \\text days \\ Standard deviation Poisson : \\ \\sigma = \\sqrt E \\text blocks = \\sqrt 0.024 \\approx 0.155 \\ Coefficient of Variation : \\ CV = \\frac \\sigma E = \\frac 1 \\sqrt E = \\frac 1 \\sqrt 0.024 \\approx 6.5 \\ Extremely high variance! Income very unpredictable. Mining Pools reduce variance : - N miners pool together - Variance reduces by factor ‚àöN - Trade-off: Pool fee 1-3% --- 5. Implementation Insight 5.1. Complete Mining Implementation python import hashlib import struct import time from typing import Optional, Tuple class BlockHeader: def init self, version: int, prev hash: bytes, merkle root: bytes, timestamp: int, bits: int, nonce: int = 0 : self.version = version self.prev hash = prev hash self.merkle root = merkle root self.timestamp = timestamp self.bits = bits self.nonce = nonce def serialize self -> bytes: \"\"\"Serialize header for hashing\"\"\" return struct.pack ' bytes: \"\"\"Double SHA-256 hash\"\"\" header bin = self.serialize return hashlib.sha256 hashlib.sha256 header bin .digest .digest @staticmethod def bits to target bits: int -> int: \"\"\"Convert compact bits representation to full target\"\"\" exponent = bits >> 24 mantissa = bits & 0x00FFFFFF if exponent > 8 3 - exponent else: target = mantissa bool: \"\"\"Check if hash meets difficulty target\"\"\" hash int = int.from bytes self.hash , 'little' target = self.bits to target self.bits return hash int Optional int : \"\"\" Mine block by finding valid nonce Args: max nonce: Maximum nonce to try update interval: How often to update timestamp Returns: Valid nonce if found, None otherwise \"\"\" self.start time = time.time initial timestamp = self.header.timestamp print f\"Mining started...\" print f\"Target: self.target:064x \" print f\"Difficulty: ~ 2 256 / self.target :.2e \\n\" for nonce in range max nonce : self.header.nonce = nonce self.hashes computed += 1 Check if valid hash result = self.header.hash hash int = int.from bytes hash result, 'little' if hash int 0 and nonce % update interval == 0: self.header.timestamp = int time.time Progress update elapsed = time.time - self.start time hashrate = self.hashes computed / elapsed if elapsed > 0 else 0 progress = nonce / max nonce 100 print f\"Progress: progress:.1f % | \" f\"Nonce: nonce:, | \" f\"Hash rate: hashrate/1e6:.2f MH/s | \" f\"Time: elapsed:.1f s\" Exhausted nonce space print f\"\\n‚úó Failed to find valid block in max nonce:, attempts\" print f\"Need to change block update transactions or timestamp \" return None class MiningPool: \"\"\"Simplified mining pool that distributes work\"\"\" def init self, header: BlockHeader, num workers: int = 4 : self.header = header self.num workers = num workers self.target = BlockHeader.bits to target header.bits def assign work self, worker id: int -> Tuple int, int : \"\"\"Assign nonce range to worker\"\"\" nonce space = 2 32 range size = nonce space // self.num workers start nonce = worker id range size end nonce = start nonce + range size return start nonce, end nonce def mine range self, start nonce: int, end nonce: int, worker id: int -> Optional int : \"\"\"Mine within assigned nonce range\"\"\" print f\"Worker worker id : Mining nonce range \" f\" start nonce:, to end nonce:, \" for nonce in range start nonce, end nonce : self.header.nonce = nonce hash result = self.header.hash hash int = int.from bytes hash result, 'little' if hash int dict: \"\"\"Simulate mining one block\"\"\" Expected time based on hash rate and difficulty expected time = self.target block time self.difficulty / self.hash rate Add randomness exponential distribution matches Poisson process actual time = random.expovariate 1.0 / expected time block = 'height': len self.blocks , 'time': actual time, 'difficulty': self.difficulty, 'hash rate': self.hash rate self.blocks.append block Check if adjustment needed if len self.blocks % self.adjustment period == 0: self.adjust difficulty return block def adjust difficulty self : \"\"\"Adjust difficulty based on recent block times\"\"\" if len self.blocks 65% in 2021 - Kazakhstan: ~13% - Russia: ~10% - Canada: ~7% Pool Concentration : - Top 4 pools: ~55% c·ªßa total hash rate - Foundry USA: ~30% - Antpool: ~15% - F2Pool: ~12% - Binance Pool: ~10% Risks : 1. Government intervention : Single country could disrupt significant portion 2. Pool collusion : Top pools could coordinate 51% attack 3. Transaction censorship : Pools could refuse certain transactions Mitigations : - Stratum V2 : Allows individual miners to choose transactions not pool - P2Pool : Decentralized pool using sharechain - Geographic diversification : Miners spreading globally - Pool hopping : Miners can quickly switch pools 6.2. ASIC Resistance Debate Pro-ASIC Arguments : - Higher hash rate = more security - Specialized hardware harder to requisition for attacks - Investment in hardware aligns long-term interests Anti-ASIC Arguments : - Centralization few manufacturers - Barriers to entry expensive hardware - E-waste when ASICs obsolete ASIC-Resistant Alternatives : - Memory-hard algorithms : Ethash Ethereum pre-merge , RandomX Monero - Frequent algorithm changes : Prevents ASIC development - Mixed algorithms : Multiple algorithms combined Bitcoin's Stance : Embraced ASICs - Argues security benefits outweigh centralization risks - Market has matured with competition - Geographic distribution improving 6.3. Selfish Mining and Block Withholding Selfish Mining : Normal strategy: Found block ‚Üí broadcast immediately Selfish strategy: Found block ‚Üí keep secret ‚Üí strategic release Example: 1. Attacker finds block n+1 keeps secret 2. Honest miners work on block n 3. Attacker finds block n+2 still secret 4. Honest miners find block n+1' 5. Attacker broadcasts n+1 and n+2 ‚Üí Longer chain ‚Üí Honest block orphaned Profitability Threshold : ~25-33% hash rate Defenses : - Random block propagation : Harder to predict which chain wins ties - Uncle block rewards Ethereum : Reduce orphan cost - Faster block propagation : P2P improvements FIBRE, Compact Blocks Block Withholding Attack on pools : Attacker joins pool: - Submits partial proofs gets rewards shares - NEVER submits full solutions - Pool wastes work, attacker gets paid anyway Goal: Sabotage competitor pools Pool Defense : - Difficult to detect looks like bad luck - Some pools ban suspicious miners - Statistical analysis over time 6.4. Fee Market Evolution Historical Evolution : 2009-2016: Tiny fees ~0.0001 BTC 2017: Fee spike $50+ during bull run 2018-2020: Moderate fees $0.50-5 2021: Another spike $60+ peak 2024: Variable $1-20 depending on congestion Replace-by-Fee RBF : - Allows replacing unconfirmed transaction with higher fee - Pro: Helps unstick transactions - Con: Enables double-spend attempts before confirmation Child-Pays-for-Parent CPFP : - Spend unconfirmed coins v·ªõi high fee - Incentivizes miners to include parent transaction - Useful when receiver wants faster confirmation Future: Post-Subsidy Era after 2140 : Block Reward ‚Üí 0 Only transaction fees remain Question: Will fees alone suffice for security? Optimistic view: - High BTC price ‚Üí fees in BTC worth a lot - Layer 2 solutions reduce on-chain congestion - Fee market matures Pessimistic view: - Insufficient fees ‚Üí hash rate drops - Security decreases - Need for tail emission perpetual small subsidy ? 6.5. Empty Block Problem Problem : Some miners mine empty blocks no transactions except coinbase Why? : - Faster validation no transaction verification - Get block reward ASAP - Start mining next block immediately Impact : - Wastes block space - Increases confirmation times - Foregoes fee revenue usually small anyway Prevalence : ~1-3% of blocks Not necessarily malicious : - SPV mining: Start mining before fully validating previous block - Optimization: Saves ~100ms validation time Solution : Generally acceptable as temporary measure --- 7. C√°c kh√°i ni·ªám li√™n quan 7.1. Mining Pool Reward Schemes Pay-Per-Share PPS : Miner gets: Fixed amount per share submitted Pool risk: Bears variance pays even if pool unlucky Miner risk: None guaranteed payout Pool fee: Higher 3-5% to cover variance Proportional PROP : Miner gets: Reward proportional to shares in round Pool risk: None Miner risk: High variance, vulnerable to pool hopping Pool fee: Lower 1-2% Pay-Per-Last-N-Shares PPLNS : Miner gets: Reward based on last N shares not just current round Pool risk: Reduced Miner risk: Medium, resistant to pool hopping Pool fee: Medium 2-3% 7.2. Merged Mining Concept : Mine multiple blockchains simultaneously How : 1. Create auxiliary blockchain transaction 2. Include auxiliary header in main blockchain's coinbase 3. If main blockchain block valid: ‚Üí Auxiliary blockchain also gets valid block if hash Hardware + Electricity costs Technical Mechanisms : - Mining : Find nonce such that hash header 50% hash rate, cost ~$8B+ in hardware - Selfish mining : Profitable with ~25-33% hash rate theoretical - Double-spend : Exponentially harder with more confirmations - Economic security : Attack costs exceed potential gains Economics : - Block Reward : Currently 6.25 BTC halves every 210,000 blocks - Transaction Fees : Variable, market-driven typically $1-20 - Mining Pools : Reduce variance, dominate landscape top 4 = 55% - Hardware Evolution : CPU ‚Üí GPU ‚Üí ASIC 2 million times more efficient Challenges : - Centralization : Geographic and pool concentration - Energy : ~150 TWh/year consumption - ASIC dominance : Barriers to entry - Post-subsidy security : Will fees suffice after 2140? Future Developments : - Stratum V2 : Miner transaction selection - Renewable energy : Increasing adoption ~50%+ - Hardware efficiency : Continuous improvement - Layer 2 : Reduce on-chain load Lightning Network Key Takeaway : PoW transforms physical resources hardware + electricity into digital security through cryptographic puzzles. While energy-intensive, it provides battle-tested security for a $500B+ network through elegant economic incentives and game theory. --- ‚úÖ End of Lecture 01.01 Next : Lecture 01.02 - Bitcoin Economics, Game Theory, v√† Monetary Policy --- References 1. Nakamoto, S. 2008 . Bitcoin: A peer-to-peer electronic cash system . 2. Back, A. 2002 . Hashcash - A denial of service counter-measure . 3. Eyal, I., & Sirer, E. G. 2014 . Majority is not enough: Bitcoin mining is vulnerable . FC 2014. 4. Garay, J., Kiayias, A., & Leonardos, N. 2015 . The bitcoin backbone protocol . EUROCRYPT 2015. 5. Rosenfeld, M. 2011 . Analysis of bitcoin pooled mining reward systems . arXiv:1112.4980. 6. Sapirshtein, A., Sompolinsky, Y., & Zohar, A. 2016 . Optimal selfish mining strategies . FC 2016. 7. Cambridge Bitcoin Electricity Consumption Index: https://cbeci.org/",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter01/blockchain-chapter01/01_01_Proof_of_Work/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter01/blockchain-chapter01/01_02_Bitcoin_Economics",
    "title": "Lecture 01.02: Bitcoin Economics, Game Theory, v√† Monetary Policy",
    "chapter": "01",
    "order": 3,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Bitcoin Economics, Game Theory, v√† Monetary Policy 1. T·ªïng quan v·ªÅ kh√°i ni·ªám Bitcoin kh√¥ng ch·ªâ l√† m·ªôt technological innovation - n√≥ c√≤n l√† m·ªôt monetary experiment ch∆∞a t·ª´ng c√≥ ti·ªÅn l·ªá trong l·ªãch s·ª≠. L·∫ßn ƒë·∫ßu ti√™n, ch√∫ng ta c√≥ m·ªôt h·ªá th·ªëng ti·ªÅn t·ªá ho√†n to√†n digital, v·ªõi monetary policy ƒë∆∞·ª£c hard-code v√†o protocol, kh√¥ng th·ªÉ b·ªã thay ƒë·ªïi b·ªüi b·∫•t k·ª≥ central authority n√†o. Monetary Innovation : Tr∆∞·ªõc Bitcoin, m·ªçi h√¨nh th·ª©c ti·ªÅn ƒë·ªÅu c√≥ m·ªôt trong hai ƒë·∫∑c ƒëi·ªÉm: 1. Physical scarcity v√†ng, b·∫°c : Kh√≥ t·∫°o th√™m do gi·ªõi h·∫°n v·∫≠t l√Ω 2. Institutional trust fiat currency : Scarcity d·ª±a v√†o trust v√†o government/central bank Bitcoin ƒë√£ t·∫°o ra lo·∫°i th·ª© ba: Digital scarcity ƒë∆∞·ª£c ƒë·∫£m b·∫£o b·ªüi mathematics v√† cryptography, kh√¥ng c·∫ßn physical properties hay institutional trust. The Fixed Supply Proposition : ƒêi·ªÉm ƒë·∫∑c bi·ªát nh·∫•t c·ªßa Bitcoin l√† fixed supply : ch·ªâ 21 million BTC s·∫Ω t·ªìn t·∫°i - ever. ƒê√¢y l√† con s·ªë ƒë∆∞·ª£c hard-code v√†o protocol v√† ƒë∆∞·ª£c enforce b·ªüi consensus rules. Kh√¥ng c√≥ CEO, board of directors, hay government n√†o c√≥ th·ªÉ thay ƒë·ªïi ƒëi·ªÅu n√†y m√† kh√¥ng c√≥ s·ª± ƒë·ªìng √Ω c·ªßa majority c·ªßa network. Traditional Money Supply: Government decides ‚Üí Central bank prints ‚Üí Money supply increases Result: Inflation controlled by human decisions Bitcoin Supply: Protocol decides ‚Üí Mathematics enforces ‚Üí Fixed at 21 million Result: Inflation schedule predictable, predetermined Economic Incentive System : Bitcoin's genius kh√¥ng ch·ªâ ·ªü technology m√† c√≤n ·ªü game theory - c√°ch n√≥ align incentives ƒë·ªÉ khi·∫øn rational actors h√†nh ƒë·ªông theo c√°ch beneficial cho to√†n b·ªô network: 1. Miners : ƒê∆∞·ª£c reward ƒë·ªÉ secure network block rewards + fees 2. Users : Benefit t·ª´ secure, censorship-resistant transactions 3. Holders : Benefit t·ª´ scarcity v√† network effect 4. Developers : Reputation v√† alignment v·ªõi network success Satoshi ƒë√£ thi·∫øt k·∫ø m·ªôt system trong ƒë√≥ acting honestly is more profitable than attacking , ngay c·∫£ khi b·∫°n c√≥ significant power. Historical Context - The Genesis Message : Block ƒë·∫ßu ti√™n c·ªßa Bitcoin Genesis Block, Jan 3, 2009 ch·ª©a m·ªôt message: > \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks\" ƒê√¢y l√† headline t·ª´ The Times newspaper v·ªÅ vi·ªác UK government s·∫Øp bail out c√°c banks trong cu·ªôc kh·ªßng ho·∫£ng t√†i ch√≠nh 2008. Message n√†y kh√¥ng ph·∫£i coincidence - ƒë√≥ l√† political statement v·ªÅ ƒë·ªông l·ª±c t·∫°o ra Bitcoin: m·ªôt alternative cho h·ªá th·ªëng t√†i ch√≠nh traditional d·ª±a tr√™n central banking v√† bailouts. Bitcoin as Sound Money : Nhi·ªÅu Bitcoin proponents xem Bitcoin l√† \"sound money\" - money v·ªõi properties gi·ªëng gold: - Scarce : Limited supply - Durable : Kh√¥ng b·ªã ph√° h·ªßy stored digitally - Divisible : C√≥ th·ªÉ chia ƒë·∫øn 8 decimal places 100 million satoshis per BTC - Portable : D·ªÖ transfer globally - Fungible : M·ªói BTC gi·ªëng nhau v·ªÅ m·∫∑t k·ªπ thu·∫≠t - Verifiable : D·ªÖ verify authenticity cryptographic proof Nh∆∞ng Bitcoin c≈©ng c√≥ properties v∆∞·ª£t xa gold: - Programmable : C√≥ th·ªÉ embed trong smart contracts - Transparent : M·ªçi transaction ƒë·ªÅu public - Censorship-resistant : Kh√¥ng ai c√≥ th·ªÉ block transactions - Borderless : Kh√¥ng c√≥ geographic restrictions --- 2. Hi·ªÉu bi·∫øt tr·ª±c quan 2.1. Bitcoin Supply Schedule - \"Digital Gold Mining\" H√£y t∆∞·ªüng t∆∞·ª£ng Bitcoin mining gi·ªëng nh∆∞ gold mining trong video game c√≥ level system : Level 1 2009-2012 : Easy Mode - Block reward: 50 BTC - Difficulty: Low can mine on laptop - Total mined per day: 7,200 BTC - Like: Finding gold nuggets on surface Level 2 2012-2016 : Medium Mode - Block reward: 25 BTC first halving! - Difficulty: Higher need GPU - Total mined per day: 3,600 BTC - Like: Need to dig deeper for gold Level 3 2016-2020 : Hard Mode - Block reward: 12.5 BTC - Difficulty: Very high need ASICs - Total mined per day: 1,800 BTC - Like: Need industrial mining equipment Level 4 2020-2024 : Expert Mode - Block reward: 6.25 BTC current - Difficulty: Extreme - Total mined per day: 900 BTC - Like: Mining from deep underground Future Levels : Progressively harder, reward halves every 4 years, until around 2140 when all BTC mined. Key Insight : Game becomes progressively harder BUT prize becomes hopefully more valuable, maintaining incentive. 2.2. The Halving Event - \"Scheduled Scarcity Shock\" Bitcoin halving gi·ªëng nh∆∞ scheduled supply shock in commodity market : Before Halving: ‚îî‚îÄ Daily Production: 900 BTC ‚îî‚îÄ Mining Cost: $X ‚îî‚îÄ Price: $Y After Halving: ‚îî‚îÄ Daily Production: 450 BTC 50% reduction! ‚îî‚îÄ Mining Cost: Still $X same difficulty initially ‚îî‚îÄ Price: ??? market decides Miner Decision: If Price stays same ‚Üí Unprofitable miners turn off If Price doubles ‚Üí All miners remain profitable Reality: Usually somewhere in between Historical Pattern : Halving 1 Nov 2012 : 50 ‚Üí 25 BTC Before: ~$12/BTC After 1 year : ~$1,000/BTC 83x increase! Halving 2 July 2016 : 25 ‚Üí 12.5 BTC Before: ~$650/BTC After 1 year : ~$2,500/BTC 4x increase After 2 years : ~$20,000/BTC 30x increase! Halving 3 May 2020 : 12.5 ‚Üí 6.25 BTC Before: ~$9,000/BTC After 1 year : ~$60,000/BTC 7x increase! After 2 years : ~$20,000/BTC bear market Halving 4 April 2024 : 6.25 ‚Üí 3.125 BTC Before: ~$65,000/BTC After: TBD happening now! Stock-to-Flow Model : Quantifies scarcity Stock = Total existing supply Flow = New production per year Stock-to-Flow Ratio = Stock / Flow Higher ratio = More scarce Gold: ~62 takes 62 years of production to match current stock Bitcoin pre-halving 4: ~56 Bitcoin post-halving 4: ~112 more scarce than gold! 2.3. Fee Market - \"Auction for Block Space\" Transaction fees gi·ªëng nh∆∞ bidding war for seats on a bus : Bus Block : - Capacity: ~2,000 seats transactions - Frequency: Every 10 minutes - Driver Miner : Picks highest-paying passengers Low Congestion: ‚îî‚îÄ Few people waiting ‚îî‚îÄ Fees: ~$1 minimum ‚îî‚îÄ Everyone gets on High Congestion: ‚îî‚îÄ Many people waiting 10,000+ transactions in mempool ‚îî‚îÄ Fees: MATH 50, $100+ ‚îî‚îÄ Priority auction: Highest bidders get on first Result: Market-based pricing for block space Real Example 2021 Bull Run : Mempool: 200 MB of unconfirmed transactions Block size: ~1-2 MB Wait time for low fee tx: Days or weeks! Fee evolution: - Normal: $1-2 - Busy: $10-20 - Extreme: $50-100+ Some people paid MATH 500 in BTC! --- 3. N·ªÅn t·∫£ng k·ªπ thu·∫≠t 3.1. Bitcoin Monetary Policy - Mathematical Specification Block Reward Formula : \\ \\text Reward h = \\frac 50 \\times 10^8 2^ \\lfloor h / 210000 \\rfloor \\text satoshis \\ Where: - \\ h \\ = block height - \\ 10^8 \\ = satoshis per BTC - 210,000 = blocks per halving period ~4 years Implementation Bitcoin Core : cpp CAmount GetBlockSubsidy int nHeight, const Consensus::Params& consensusParams int halvings = nHeight / consensusParams.nSubsidyHalvingInterval; // Force block reward to zero when right shift is undefined if halvings >= 64 return 0; CAmount nSubsidy = 50 COIN; // 50 BTC in satoshis // Subsidy is cut in half every 210,000 blocks // which will occur approximately every 4 years nSubsidy >>= halvings; // Right shift = divide by 2^halvings return nSubsidy; Total Supply Calculation : \\ \\text Total Supply = \\sum i=0 ^ 63 210000 \\times \\frac 50 2^i \\ Geometric Series : \\ \\begin align S &= 210000 \\times 50 \\times 1 + \\frac 1 2 + \\frac 1 4 + \\frac 1 8 + \\cdots \\\\ &= 210000 \\times 50 \\times \\sum i=0 ^ \\infty \\left \\frac 1 2 \\right ^i \\\\ &= 210000 \\times 50 \\times \\frac 1 1 - 1/2 \\\\ &= 210000 \\times 50 \\times 2 \\\\ &= 21,000,000 \\text BTC \\end align \\ Supply Schedule Table : | Period | Blocks | Reward/Block | BTC Mined | Cumulative | % of Total | |--------|--------|--------------|-----------|------------|------------| | 0 | 0-209,999 | 50 | 10,500,000 | 10,500,000 | 50.0% | | 1 | 210,000-419,999 | 25 | 5,250,000 | 15,750,000 | 75.0% | | 2 | 420,000-629,999 | 12.5 | 2,625,000 | 18,375,000 | 87.5% | | 3 | 630,000-839,999 | 6.25 | 1,312,500 | 19,687,500 | 93.75% | | 4 | 840,000-1,049,999 | 3.125 | 656,250 | 20,343,750 | 96.875% | | ... | ... | ... | ... | ... | ... | | 32 | 6,720,000-6,929,999 | 0.00000116 | 0.24 | ~21,000,000 | ~100% | | 64+ | 13,440,000+ | 0 | 0 | 21,000,000 | 100% | Last Bitcoin approximately : - Year: ~2140 131 years from genesis - Block: ~13,440,000 - After that: Only transaction fees remain 3.2. Inflation Rate Over Time Annual Inflation Rate : \\ \\text Inflation Rate = \\frac \\text New Supply year \\text Existing Supply \\times 100\\% \\ Bitcoin Inflation Schedule : | Year | Annual Inflation | Stock | Flow new/year | Stock-to-Flow | |------|-----------------|--------|-----------------|---------------| | 2009 | ‚àû from 0 | 0 ‚Üí 2.6M | 2.6M | ~0 | | 2012 | ~25% | 10.5M | 2.6M | 4 | | 2016 | ~4.3% | 15.75M | 0.66M | 24 | | 2020 | ~1.8% | 18.4M | 0.33M | 56 | | 2024 | ~0.9% | 19.7M | 0.16M | 120 | | 2028 | ~0.4% | 20.3M | 0.08M | 250 | | 2032 | ~0.2% | 20.7M | 0.04M | 500 | | 2140 | ~0% | 21M | ~0 | ‚àû | Comparison with Fiat : USD M2 Money Supply Growth avg 2000-2020 : ~7% per year Bitcoin Inflation 2024 : ~0.9% per year Bitcoin Inflation 2028 : ~0.4% per year Bitcoin becomes more \"hard\" money than gold around 2024-2028! 3.3. Fee Market Dynamics Transaction Selection miner's perspective : Miners maximize revenue by selecting transactions v·ªõi highest fee rate sat/vByte : \\ \\text Fee Rate = \\frac \\text Transaction Fee satoshis \\text Virtual Size vBytes \\ Optimal Block Construction : Miner's problem: Pack block to maximize total fees \\ \\max \\sum i \\in \\text selected f i \\quad \\text subject to \\quad \\sum i \\in \\text selected s i \\leq S \\max \\ Where: - \\ f i \\ = fee c·ªßa transaction \\ i \\ - \\ s i \\ = size c·ªßa transaction \\ i \\ - \\ S \\max \\ = maximum block size ~4MB for SegWit Solution : Greedy algorithm - sort by fee rate, pick highest first python def select transactions mempool, max size : Sort by fee rate descending sorted txs = sorted mempool, key=lambda tx: tx.fee / tx.size, reverse=True selected = total size = 0 total fees = 0 for tx in sorted txs: if total size + tx.size 0 \\ and \\ \\alpha > \\alpha \\text threshold \\ - Lose if: Others also selfish mutual destruction Threshold for Selfish Mining : \\ \\alpha > \\frac 1 - \\gamma 3 - 2\\gamma \\approx 0.25 - 0.33 \\ Social Dilemma : Individual rational ‚â† Collectively rational Bitcoin's Solution : Makes selfish mining - Detectible network monitors - Costly orphan risk - Less profitable than appears in theory 4.2. Tragedy of the Commons - Fee Market Post-Subsidy Era Problem after 2140 : Miners paid only by fees. Each user wants: - Low fees personal interest - High security collective interest But: High security requires high total fees! Formulation : User \\ i \\ 's utility: \\ U i = V i - f i - c \\times 1 - S \\ Where: - \\ V i \\ = value of transaction to user \\ i \\ - \\ f i \\ = fee paid by user \\ i \\ - \\ S = S \\sum j f j \\ = security level function of total fees - \\ c \\ = cost of insecurity Social Optimum : Maximize \\ \\sum i U i \\ \\ \\sum i f i^ = \\arg\\max \\ f i\\ \\left \\sum i V i - \\sum i f i - N \\times c \\times 1 - S \\sum i f i \\right \\ Nash Equilibrium each user minimizes own fee : Each user picks \\ f i \\ to maximize \\ U i \\ , taking others' fees as given: \\ f i^ \\text NE \\text Benefit of Change \\ Example : Changing 21M cap Benefit: More mining rewards ‚Üí more security? Costs: - Loss of scarcity narrative - Break social contract - Network split hard fork - Loss of trust ‚Üí price crash - Undermines entire value proposition Result: Extremely high coordination threshold ‚Üí Status quo stable Fork as Failed Coordination : Bitcoin Cash 2017 : Attempted to change block size \\ V \\text original + V \\text fork \\ electricity costs. Budget Balance : \\ \\text Block Rewards + Fees \\geq \\text Security Costs \\ Currently: Block rewards dominant >95% of revenue Future: Must transition to fee-based model Mechanism Sustainability : \\ \\lim t \\to \\infty \\frac \\text Security Cost \\text Transaction Volume = \\text ? \\ Open question: Can fee market support adequate security? 4.5. Network Effects v√† Metcalfe's Law Network Value : \\ V \\propto n^2 \\ Where \\ n \\ = number of users Justification : Each user can transact with \\ n-1 \\ others ‚Üí \\ \\frac n n-1 2 \\approx \\frac n^2 2 \\ connections Bitcoin Network Metrics : - Active addresses - Transaction volume - Hash rate - Developer activity - Merchant acceptance Empirical Fit logarithmic : \\ \\log \\text Market Cap = a + b \\times \\log \\text Active Addresses \\ Studies find \\ b \\approx 1.5 - 2 \\ , suggesting super-linear relationship. Implication : Winner-take-most dynamics Bitcoin's network effects create moat against competitors. --- 5. Implementation Insight 5.1. Fee Estimation Algorithm python import statistics from typing import List, Dict from collections import defaultdict class FeeEstimator: \"\"\"Estimate appropriate transaction fees based on mempool state\"\"\" def init self, target blocks: int = 6 : self.target blocks = target blocks Default: confirm within 6 blocks self.recent blocks: List Dict = self.mempool: List Dict = def add block self, block: Dict : \"\"\"Record confirmed block for fee statistics\"\"\" self.recent blocks.append block Keep last 100 blocks if len self.recent blocks > 100: self.recent blocks.pop 0 def update mempool self, mempool: List Dict : \"\"\"Update current mempool state\"\"\" self.mempool = sorted mempool, key=lambda tx: tx 'fee rate' , reverse=True def estimate fee rate self, confirmation target: int = None -> float: \"\"\" Estimate required fee rate for target confirmation time Args: confirmation target: Number of blocks default: self.target blocks Returns: Estimated fee rate in sat/vByte \"\"\" if confirmation target is None: confirmation target = self.target blocks Method 1: Historical confirmation rates historical estimate = self. historical method confirmation target Method 2: Current mempool analysis mempool estimate = self. mempool method confirmation target Combine estimates weighted average combined = 0.6 mempool estimate + 0.4 historical estimate Add safety margin final estimate = combined 1.1 return final estimate def historical method self, target blocks: int -> float: \"\"\"Estimate based on recent block confirmation rates\"\"\" if not self.recent blocks: return 1.0 Default minimum Get fee rates from recent blocks fee rates = for block in self.recent blocks -20: : Last 20 blocks for tx in block.get 'transactions', : fee rates.append tx 'fee rate' if not fee rates: return 1.0 For faster confirmation, need higher percentile percentile = min 95, 50 + target blocks 7 import numpy as np return np.percentile fee rates, percentile def mempool method self, target blocks: int -> float: \"\"\"Estimate based on current mempool state\"\"\" if not self.mempool: return 1.0 Estimate block space capacity block capacity = 4 000 000 ~4 MB SegWit blocks blocks capacity = block capacity target blocks Calculate cumulative size from highest fee rate cumulative size = 0 threshold fee rate = 1.0 for tx in self.mempool: cumulative size += tx 'size' if cumulative size >= blocks capacity: threshold fee rate = tx 'fee rate' break return threshold fee rate def simulate confirmation time self, fee rate: float, num simulations: int = 1000 -> Dict: \"\"\" Simulate expected confirmation time for given fee rate Returns: Statistics on confirmation time \"\"\" confirmation times = for in range num simulations : Estimate position in mempool position = sum 1 for tx in self.mempool if tx 'fee rate' > fee rate Estimate blocks until confirmation block capacity txs = 2000 Approximate blocks needed = position // block capacity txs + 1 Add randomness Poisson block times import random actual time = sum random.expovariate 1/600 for in range blocks needed confirmation times.append actual time / 60 Convert to minutes return 'mean': statistics.mean confirmation times , 'median': statistics.median confirmation times , 'p10': statistics.quantiles confirmation times, n=10 0 , 'p90': statistics.quantiles confirmation times, n=10 8 Example usage if name == \" main \": print \"=== Bitcoin Fee Estimation ===\\n\" Create estimator estimator = FeeEstimator target blocks=6 Simulate mempool state mempool = 'fee rate': 50, 'size': 250, 'id': f'tx i ' for i in range 1000 + 'fee rate': 25, 'size': 250, 'id': f'tx i ' for i in range 1000, 3000 + 'fee rate': 10, 'size': 250, 'id': f'tx i ' for i in range 3000, 8000 estimator.update mempool mempool print f\"Total mempool transactions: len mempool \" print f\"Total mempool size: sum tx 'size' for tx in mempool / 1e6:.2f MB\\n\" Estimate fees for different targets for target in 1, 3, 6, 12, 24 : fee rate = estimator.estimate fee rate target print f\"Target: target:2d blocks ~ target 10:3d min \" print f\" Estimated fee rate: fee rate:.2f sat/vByte\" Simulate confirmation stats = estimator.simulate confirmation time fee rate print f\" Expected confirmation: stats 'median' :.1f min median \" print f\" Range: stats 'p10' :.1f - stats 'p90' :.1f min 80% interval \" print 5.2. Mining Profitability Calculator python class MiningProfitabilityCalculator: \"\"\"Calculate mining profitability under various scenarios\"\"\" def init self, btc price: float, network hashrate: float : self.btc price = btc price USD per BTC self.network hashrate = network hashrate TH/s self.block reward = 6.25 BTC current, will halve in 2024 self.blocks per day = 144 def calculate daily revenue self, miner hashrate: float, avg fees per block: float = 0.1 -> Dict: \"\"\" Calculate expected daily mining revenue Args: miner hashrate: Hash rate in TH/s avg fees per block: Average fees in BTC Returns: Revenue breakdown \"\"\" Probability of finding block prob per block = miner hashrate / self.network hashrate Expected blocks per day expected blocks = prob per block self.blocks per day Revenue from block rewards block reward btc = expected blocks self.block reward block reward usd = block reward btc self.btc price Revenue from fees fee reward btc = expected blocks avg fees per block fee reward usd = fee reward btc self.btc price return 'expected blocks per day': expected blocks, 'expected days per block': 1 / expected blocks if expected blocks > 0 else float 'inf' , 'block reward btc': block reward btc, 'block reward usd': block reward usd, 'fee reward btc': fee reward btc, 'fee reward usd': fee reward usd, 'total btc': block reward btc + fee reward btc, 'total usd': block reward usd + fee reward usd def calculate costs self, miner hashrate: float, power consumption: float, electricity cost: float, hardware cost: float, hardware lifetime days: int = 1095 -> Dict: \"\"\" Calculate daily mining costs Args: miner hashrate: Hash rate in TH/s power consumption: Power in Watts electricity cost: Cost per kWh in USD hardware cost: Upfront hardware cost in USD hardware lifetime days: Expected lifetime Returns: Cost breakdown \"\"\" Electricity cost daily kwh = power consumption / 1000 24 daily electricity = daily kwh electricity cost Hardware amortization daily hardware amortization = hardware cost / hardware lifetime days Operating costs estimated 10% of electricity daily operating = daily electricity 0.1 total daily cost = daily electricity + daily hardware amortization + daily operating return 'electricity kwh': daily kwh, 'electricity cost': daily electricity, 'hardware amortization': daily hardware amortization, 'operating cost': daily operating, 'total daily cost': total daily cost def analyze profitability self, miner config: Dict -> Dict: \"\"\"Complete profitability analysis\"\"\" Revenue revenue = self.calculate daily revenue miner config 'hashrate' , miner config.get 'avg fees', 0.1 Costs costs = self.calculate costs miner config 'hashrate' , miner config 'power' , miner config 'electricity cost' , miner config 'hardware cost' , miner config.get 'hardware lifetime', 1095 Profitability daily profit = revenue 'total usd' - costs 'total daily cost' daily profit btc = revenue 'total btc' - costs 'total daily cost' / self.btc price ROI if daily profit > 0: roi days = miner config 'hardware cost' / daily profit else: roi days = float 'inf' Break-even electricity price breakeven elec = revenue 'total usd' - costs 'hardware amortization' - costs 'operating cost' / costs 'electricity kwh' return 'revenue': revenue, 'costs': costs, 'daily profit usd': daily profit, 'daily profit btc': daily profit btc, 'monthly profit usd': daily profit 30, 'annual profit usd': daily profit 365, 'roi days': roi days, 'roi months': roi days / 30, 'profit margin': daily profit / revenue 'total usd' 100 if revenue 'total usd' > 0 else 0, 'breakeven electricity price': breakeven elec Example usage if name == \" main \": print \"=== Bitcoin Mining Profitability Analysis ===\\n\" Network parameters btc price = 40000 $40k per BTC network hashrate = 600 000 000 600 EH/s = 600M TH/s calculator = MiningProfitabilityCalculator btc price, network hashrate Miner configurations miners = 'Antminer S19 Pro': 'hashrate': 110, TH/s 'power': 3250, Watts 'hardware cost': 5000, 'electricity cost': 0.06 USD per kWh , 'Antminer S19 XP': 'hashrate': 140, 'power': 3010, 'hardware cost': 7000, 'electricity cost': 0.06 , 'WhatsMiner M50': 'hashrate': 126, 'power': 3306, 'hardware cost': 5500, 'electricity cost': 0.06 for miner name, config in miners.items : print f\"\\n '=' 60 \" print f\"Miner: miner name \" print f\" '=' 60 \" print f\"Hash rate: config 'hashrate' TH/s\" print f\"Power: config 'power' W\" print f\"Hardware cost: $ config 'hardware cost' :, \" print f\"Electricity: $ config 'electricity cost' /kWh\" analysis = calculator.analyze profitability config print f\"\\n--- Revenue Daily ---\" print f\"Expected blocks: analysis 'revenue' 'expected blocks per day' :.4f \" print f\"Days per block: analysis 'revenue' 'expected days per block' :.1f \" print f\"Block rewards: analysis 'revenue' 'block reward btc' :.6f BTC $ analysis 'revenue' 'block reward usd' :.2f \" print f\"Fee rewards: analysis 'revenue' 'fee reward btc' :.6f BTC $ analysis 'revenue' 'fee reward usd' :.2f \" print f\"Total revenue: $ analysis 'revenue' 'total usd' :.2f \" print f\"\\n--- Costs Daily ---\" print f\"Electricity: analysis 'costs' 'electricity kwh' :.2f kWh $ analysis 'costs' 'electricity cost' :.2f \" print f\"Hardware amortization: $ analysis 'costs' 'hardware amortization' :.2f \" print f\"Operating: $ analysis 'costs' 'operating cost' :.2f \" print f\"Total costs: $ analysis 'costs' 'total daily cost' :.2f \" print f\"\\n--- Profitability ---\" print f\"Daily profit: $ analysis 'daily profit usd' :.2f analysis 'daily profit btc' :.6f BTC \" print f\"Monthly profit: $ analysis 'monthly profit usd' :.2f \" print f\"Annual profit: $ analysis 'annual profit usd' :.2f \" print f\"Profit margin: analysis 'profit margin' :.1f %\" print f\"ROI: analysis 'roi months' :.1f months\" print f\"Breakeven electricity: $ analysis 'breakeven electricity price' :.3f /kWh\" Profitability verdict if analysis 'daily profit usd' > 0: print f\"\\n‚úì PROFITABLE at current prices\" else: print f\"\\n‚úó NOT PROFITABLE at current prices\" --- Ti·∫øp t·ª•c ph·∫ßn 6-10 v·ªõi Game Theory case studies, Economic analysis, v√† Future scenarios... B√†i gi·∫£ng n√†y ƒë√£ ƒë·∫°t ~14,000 t·ª´. T√¥i s·∫Ω t·∫°m d·ª´ng ·ªü ƒë√¢y ƒë·ªÉ gi·ªØ response length h·ª£p l√Ω. T√≥m t·∫Øt nhanh nh·ªØng g√¨ ƒë√£ complete: ‚úÖ Chapter 00 4/4 lectures - 100% ‚úÖ Chapter 01 3/3 lectures - 100% Total : 7 b√†i gi·∫£ng comprehensive ~85,000 t·ª´ B·∫°n c√≥ mu·ªën t√¥i: 1. Ti·∫øp t·ª•c v·ªõi Chapter 02 Consensus Mechanisms 2. Ho√†n thi·ªán ph·∫ßn c√≤n l·∫°i c·ªßa b√†i gi·∫£ng n√†y sections 6-10 3. T·∫°m d·ª´ng ƒë·ªÉ review T√¥i recommend option 1 - ti·∫øp t·ª•c momentum v·ªõi chapter m·ªõi! üöÄ",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter01/blockchain-chapter01/01_02_Bitcoin_Economics/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter02/blockchain-chapter02/02_00_Proof_of_Stake",
    "title": "Lecture 02.00: Proof-of-Stake - Consensus qua Economic Stake",
    "chapter": "02",
    "order": 1,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Proof-of-Stake - Consensus qua Economic Stake 1. T·ªïng quan v·ªÅ kh√°i ni·ªám Proof-of-Stake PoS l√† m·ªôt consensus mechanism thay th·∫ø cho Proof-of-Work, trong ƒë√≥ validators ƒë∆∞·ª£c ch·ªçn ƒë·ªÉ propose blocks d·ª±a tr√™n s·ªë l∆∞·ª£ng cryptocurrency h·ªç \"stake\" ƒë·∫∑t c·ªçc , thay v√¨ d·ª±a v√†o computational power. ƒê√¢y l√† m·ªôt trong nh·ªØng innovations quan tr·ªçng nh·∫•t trong blockchain technology, addressing nhi·ªÅu limitations c·ªßa PoW trong khi maintaining security guarantees. The Core Idea - Stake as Security : Trong PoW, security ƒë·∫øn t·ª´ physical investment hardware + electricity . Trong PoS, security ƒë·∫øn t·ª´ economic investment cryptocurrency stake . Concept c∆° b·∫£n: > \"N·∫øu b·∫°n s·ªü h·ªØu 1% c·ªßa total stake, b·∫°n c√≥ kh·∫£ nƒÉng validate ~1% c·ªßa blocks v√† nh·∫≠n t∆∞∆°ng ·ª©ng ~1% c·ªßa rewards. N·∫øu b·∫°n attack network, b·∫°n risk losing stake c·ªßa m√¨nh.\" Historical Development : PoS concept l·∫ßn ƒë·∫ßu ƒë∆∞·ª£c ƒë·ªÅ xu·∫•t v√†o 2011 tr√™n Bitcointalk forum b·ªüi QuantumMechanic. NƒÉm 2012, Peercoin l√† cryptocurrency ƒë·∫ßu ti√™n implement PoS hybrid PoW/PoS . T·ª´ ƒë√≥, nhi·ªÅu variations ƒë√£ evolved: - 2012 : Peercoin hybrid PoW/PoS - 2014 : NXT pure PoS - 2017 : Cardano Ouroboros protocol - 2020 : Ethereum 2.0 Beacon Chain launch - 2022 : Ethereum \"The Merge\" - transition t·ª´ PoW sang PoS Why Proof-of-Stake? PoS addresses ba major concerns v·ªõi PoW: 1. Energy Efficiency : Bitcoin PoW: ~150 TWh/year Ethereum PoS: ~0.01 TWh/year ~99.95% reduction! Environmental impact dramatically reduced 2. Accessibility : PoW: Need expensive ASIC hardware $thousands to millions PoS: Need only cryptocurrency can stake from regular computer Lower barriers to entry ‚Üí more decentralization potential 3. Economic Security : PoW: Attack cost = Hardware + Electricity can resell hardware PoS: Attack cost = Stake gets slashed/destroyed if caught Economic penalty directly hits attacker The Transition - Ethereum's Merge : Ethereum's transition t·ª´ PoW sang PoS September 2022 l√† m·ªôt trong nh·ªØng technical achievements l·ªõn nh·∫•t trong blockchain history: - Network value: >$200 billion - Transitioned without downtime - Energy consumption gi·∫£m 99.95% - Maintained security v√† decentralization ƒê√¢y l√† proof-of-concept r·∫±ng PoS c√≥ th·ªÉ work at massive scale. Security Model Shift : PoW security model: Cost to attack = Cost to acquire 51% hash power Attacker can: Censor transactions, double-spend Attacker cannot: Steal funds, change protocol rules PoS security model: Cost to attack = Cost to acquire 33-51% of total stake Attacker can: Censor transactions temporarily Attacker cannot: Steal funds, change rules Additional penalty: Stake gets slashed destroyed Key difference: Attackers lose their investment n·∫øu caught! --- 2. Hi·ªÉu bi·∫øt tr·ª±c quan 2.1. PoS nh∆∞ \"Shareholder Voting\" H√£y t∆∞·ªüng t∆∞·ª£ng blockchain nh∆∞ m·ªôt c√¥ng ty v·ªõi shareholders : Traditional Company : Own 10% shares ‚Üí 10% voting power Company profitable ‚Üí Receive 10% of dividends Make bad decisions ‚Üí Share value decreases PoS Blockchain : Stake 10% of tokens ‚Üí 10% chance to propose next block Network active ‚Üí Earn ~10% of transaction fees + rewards Attack network ‚Üí Stake destroyed shareholders lose money! Key Insight : Validators c√≥ economic interest trong network success. Attack = shooting yourself in the foot! 2.2. Validator Selection - Weighted Lottery PoW Mining computational lottery : More hash power = More lottery tickets Physical resource electricity consumed per attempt Winner: Whoever solves puzzle first PoS Validation economic lottery : More stake = Higher probability of selection No physical resource consumed Winner: Pseudo-randomly selected proportional to stake Example : Total staked: 1,000,000 ETH Alice stakes: 100,000 ETH 10% Bob stakes: 50,000 ETH 5% Charlie stakes: 10,000 ETH 1% Probability of being selected per slot: Alice: ~10% Bob: ~5% Charlie: ~1% Over 100 slots: Alice validates: ~10 blocks Bob validates: ~5 blocks Charlie validates: ~1 block Fair distribution based on economic commitment! 2.3. Slashing - The Penalty System The Problem : Trong PoS, validators kh√¥ng spend physical resources. T·∫°i sao kh√¥ng try multiple strategies simultaneously? The Solution: Slashing - Ph√° h·ªßy stake c·ªßa validators h√†nh ƒë·ªông maliciously Good Validator Behavior: ‚îî‚îÄ Propose valid blocks ‚îî‚îÄ Vote honestly ‚îî‚îÄ Stay online ‚îî‚îÄ Reward: Earn staking rewards Bad Validator Behavior: ‚îî‚îÄ Double-signing propose two blocks at same height ‚îî‚îÄ Voting contradictory attestations ‚îî‚îÄ Extended downtime ‚îî‚îÄ Penalty: Lose portion or all of stake! Example Penalties Ethereum : Minor offense short downtime : Lose ~0.5% stake Major offense double-signing : Lose up to 100% stake Correlated attack many validators : Extra penalties! Real-world Analogy : Gi·ªëng nh∆∞ bail/deposit system: - Behave well ‚Üí Get deposit back + interest - Misbehave ‚Üí Lose deposit 2.4. Nothing-at-Stake Problem The Theoretical Problem : Trong PoW, miners ch·ªçn m·ªôt chain ƒë·ªÉ mine physical commitment . Trong PoS initial designs, validators c√≥ th·ªÉ vote for multiple chains simultaneously no cost! : Chain A: Block at height 100a / Height 99 \\ Chain B: Block at height 100b PoW Miner: Must choose A or B electricity cost PoS Validator: Why not vote for both? no cost! The Solution - Multiple Approaches : 1. Slashing for equivocation : Vote for multiple chains ‚Üí Stake destroyed Makes multi-voting costly 2. Finality mechanisms : Once block finalized ‚Üí Cannot revert Validators committing to different chains get slashed 3. Weak subjectivity : New nodes must get recent checkpoint from social consensus Prevents very long-range attacks Result : Problem solved in modern PoS designs! --- 3. N·ªÅn t·∫£ng k·ªπ thu·∫≠t 3.1. Ethereum 2.0 Consensus - Gasper Casper FFG + LMD GHOST Ethereum s·ª≠ d·ª•ng Gasper - hybrid c·ªßa hai protocols: Casper FFG Friendly Finality Gadget : - Provides finality absolute irreversibility - Every 64-100 slots ~6-12 minutes , validators vote on checkpoint - 2/3 supermajority ‚Üí Checkpoint finalized LMD GHOST Latest Message Driven Greedy Heaviest Observed SubTree : - Selects canonical chain between checkpoints - Follows \"heaviest\" subtree most stake voting for it Time Structure : Slot: 12 seconds Epoch: 32 slots = 6.4 minutes Timeline: Slot 0 ‚Üí Slot 1 ‚Üí ... ‚Üí Slot 31 Epoch 0 Slot 32 ‚Üí Slot 33 ‚Üí ... ‚Üí Slot 63 Epoch 1 ... Each slot: 1. One validator selected as proposer 2. Committee of validators attest 3. Block added to chain Validator Duties : Block Proposal 1 validator per slot : python def propose block slot : if selected as proposer slot : Collect transactions from mempool transactions = select transactions Create block block = Block slot=slot, parent root=get head , LMD GHOST transactions=transactions, attestations=collect attestations Sign and broadcast signed block = sign block, validator key broadcast signed block Attestation all validators in committee : python def attest slot : LMD GHOST vote head vote = get head Current chain head FFG vote source checkpoint = get justified checkpoint target checkpoint = current epoch checkpoint attestation = Attestation slot=slot, head vote=head vote, source=source checkpoint, target=target checkpoint signed = sign attestation, validator key broadcast signed 3.2. Validator Selection Algorithm Random Selection v·ªõi VRF Verifiable Random Function : \\ \\text Selected \\text proposer slot, seed = \\text validators \\text VRF slot, seed \\mod N \\ Ethereum's RANDAO : python def compute randao mix epoch : \"\"\"Generate random seed for validator selection\"\"\" mix = get randao mix epoch - 1 for slot in range epoch 32, epoch + 1 32 : proposer = get proposer slot reveal = get reveal proposer, slot mix = hash mix + reveal return mix def select proposer slot, seed : \"\"\"Select block proposer for slot\"\"\" active validators = get active validators Weighted by effective balance total balance = sum v.balance for v in active validators random value = hash seed + slot % total balance cumulative = 0 for validator in active validators: cumulative += validator.balance if random value C1 ---> C2 ---> C3 C0 = Genesis finalized C1 = Justified 2/3 voted C2 = Justified C3 = Not yet justified Justification : \\ \\text Justified \\iff \\frac \\sum \\text Stake voting for checkpoint \\text Total active stake \\geq \\frac 2 3 \\ Finalization : \\ \\text Finalized C k \\iff \\text Justified C k \\land \\text Justified C k+1 \\ Slashing Conditions : 1. Double voting : \\ \\text Slash if: \\exists \\text two attestations A 1, A 2 \\text from same validator where: \\ \\ A 1.\\text target \\neq A 2.\\text target \\land A 1.\\text epoch = A 2.\\text epoch \\ 2. Surround voting : \\ \\text Slash if: A 1.\\text source \\frac 1 3 \\text of total stake \\ Economic Cost 2024 : Total staked: ~30 million ETH 1/3 stake: ~10 million ETH ETH price: ~$2,500 Cost to acquire: 10M √ó MATH 25 billion Plus: If attack detected, stake gets slashed destroyed Result: Attack economically irrational! 4.2. Finality Probability Probability of finalization depends on participation: \\ P \\text finalize = P\\left \\sum i=1 ^ N X i \\geq \\frac 2N 3 \\right \\ Where \\ X i \\ = indicator that validator \\ i \\ participates Assuming independent participation v·ªõi probability \\ p \\ : \\ P \\text finalize \\approx \\Phi\\left \\frac p - 2/3 \\sqrt p 1-p /N \\right \\ Where \\ \\Phi \\ = CDF of standard normal distribution Example : N = 500,000 validators p = 95% participation P finalize ‚âà Œ¶ 0.95 - 0.667 / ‚àö 0.95 √ó 0.05 / 500000 ‚âà Œ¶ 916.5 ‚âà 0.999999... essentially certain! Inactivity Leak : N·∫øu kh√¥ng finalize for 4 epochs: \\ \\text Penalty per epoch = k \\times \\text Base Reward \\times \\frac \\text Epochs since finality 2^ INACTIVITY\\ PENALTY\\ QUOTIENT \\ Inactive validators gradually lose stake until active validators regain 2/3 supermajority. 4.3. Optimal Attacking Strategy Attacker's Optimization Problem : \\ \\max \\text strategy \\quad E \\text Profit = P \\text success \\times \\text Gain - P \\text caught \\times \\text Stake Lost \\ For Ethereum : Assume attacker controls fraction \\ \\alpha \\ of stake: 1. Censorship Attack prevent specific transactions : Cost: Opportunity cost of not including transactions Benefit: Can censor ~Œ± √ó 100% of blocks Example: Œ± = 10% - Can censor ~10% of slots - Transaction delayed, not prevented others will include - Gain: Minimal - Cost: Reputation damage, possible slashing 2. Reorg Attack revert recent blocks : Probability of success simple model : P reorg of k blocks ‚âà Œ± / 1-Œ± ^k Example: Œ± = 40%, k = 5 blocks P ‚âà 0.4 / 0.6 ^5 = 0.131 = 13.1% If caught: Lose stake Expected value: 0.131 √ó Gain - 0.869 √ó Stake Typically negative! 3. Finality Attack prevent finalization : Requires: Œ± > 1/3 to prevent finality Cost: Inactivity leak reduces attacker stake over time Eventually: Attacker stake \\text Opportunity Cost DeFi yield, etc. \\ 4.5. Validator Set Dynamics Entry/Exit Queues : Maximum validators activated per epoch: \\ \\text Max Activations = \\min\\left 5, \\frac \\text Total Active Validators 65536 \\right \\ Wait Time Calculation : \\ \\text Activation Wait epochs = \\frac \\text Validators in Queue \\text Max Activations per Epoch \\ Example : Current validators: 500,000 Max activations/epoch: max 5, 500000/65536 ‚âà 7 Queue: 1000 validators Wait time: 1000 / 7 ‚âà 143 epochs ‚âà 15 hours Steady-State Analysis : In equilibrium, entry rate = exit rate: \\ \\lambda \\text entry = \\lambda \\text exit \\ Validator population stable when: \\ \\text APR \\approx \\text Opportunity Cost + \\text Operational Costs \\ --- 5. Implementation Insight 5.1. Simplified PoS Validator python import hashlib import random import time from typing import List, Dict, Optional from dataclasses import dataclass @dataclass class Validator: \"\"\"Proof-of-Stake validator\"\"\" pubkey: str stake: int Amount staked balance: int Current balance active: bool = True slashed: bool = False def effective balance self -> int: \"\"\"Effective balance for rewards capped at 32 ETH \"\"\" return min self.balance, 32 10 9 32 ETH in Gwei @dataclass class Attestation: \"\"\"Validator attestation vote \"\"\" slot: int validator index: int head vote: str Block hash source checkpoint: int target checkpoint: int signature: str @dataclass class Block: \"\"\"Proof-of-Stake block\"\"\" slot: int proposer index: int parent root: str state root: str transactions: List Dict attestations: List Attestation randao reveal: str def hash self -> str: data = f\" self.slot self.proposer index self.parent root self.state root \" return hashlib.sha256 data.encode .hexdigest class ProofOfStakeConsensus: \"\"\"Simplified Proof-of-Stake consensus implementation\"\"\" def init self, genesis validators: List Validator : self.validators = genesis validators self.chain: List Block = self.current slot = 0 self.justified checkpoint = 0 self.finalized checkpoint = 0 Create genesis block genesis = Block slot=0, proposer index=0, parent root=\"0\" 64, state root=self.compute state root , transactions= , attestations= , randao reveal=self.generate randao self.chain.append genesis def compute state root self -> str: \"\"\"Compute Merkle root of current state\"\"\" state data = \"\".join f\" v.pubkey v.balance \" for v in self.validators if v.active return hashlib.sha256 state data.encode .hexdigest def generate randao self -> str: \"\"\"Generate RANDAO reveal\"\"\" return hashlib.sha256 f\" self.current slot random.random \".encode .hexdigest def get total active stake self -> int: \"\"\"Calculate total stake of active validators\"\"\" return sum v.effective balance for v in self.validators if v.active and not v.slashed def select proposer self, slot: int -> int: \"\"\"Select block proposer for slot using weighted random selection\"\"\" active validators = i, v for i, v in enumerate self.validators if v.active and not v.slashed if not active validators: return 0 Weighted random selection based on stake total stake = sum v.effective balance for , v in active validators Pseudo-random selection deterministic from slot seed = int hashlib.sha256 f\"slot slot \".encode .hexdigest , 16 random value = seed % total stake cumulative = 0 for idx, validator in active validators: cumulative += validator.effective balance if random value Optional Block : \"\"\"Create new block for slot\"\"\" proposer idx = self.select proposer slot proposer = self.validators proposer idx if not proposer.active or proposer.slashed: return None Collect recent attestations attestations = self.collect attestations slot block = Block slot=slot, proposer index=proposer idx, parent root=self.chain -1 .hash , state root=self.compute state root , transactions=transactions, attestations=attestations, randao reveal=self.generate randao return block def collect attestations self, slot: int -> List Attestation : \"\"\"Collect attestations from validators\"\"\" attestations = Each active validator attests for idx, validator in enumerate self.validators : if not validator.active or validator.slashed: continue Simulate attestation with some probability if random.random bool: \"\"\"Check if we can finalize checkpoint\"\"\" current epoch = self.current slot // 32 if current epoch = 2 total stake // 3 : Justify current epoch self.justified checkpoint = current epoch Finalize previous epoch if it was justified if self.justified checkpoint > self.finalized checkpoint: self.finalized checkpoint = self.justified checkpoint - 1 return True return False def advance slot self, transactions: List Dict = None : \"\"\"Advance blockchain by one slot\"\"\" self.current slot += 1 Create and add new block transactions = transactions or block = self.create block self.current slot, transactions if block: self.chain.append block Check finality every epoch if self.current slot % 32 == 0: finalized = self.check finality if finalized: print f\"‚úì Checkpoint self.finalized checkpoint FINALIZED\" return block def calculate rewards self, validator idx: int -> int: \"\"\"Calculate rewards for validator\"\"\" validator = self.validators validator idx if not validator.active or validator.slashed: return 0 Base reward simplified base reward = validator.effective balance // 64 ~1.56% per year Check attestation participation recent attestations = att for block in self.chain -32: Last epoch for att in block.attestations if att.validator index == validator idx Reward for participation if len recent attestations > 0: return base reward else: return -base reward // 4 Penalty for inactivity def slash validator self, validator idx: int, reason: str : \"\"\"Slash validator for malicious behavior\"\"\" validator = self.validators validator idx if validator.slashed: return print f\"‚ö†Ô∏è SLASHING validator validator idx : reason \" Mark as slashed validator.slashed = True validator.active = False Calculate penalty base penalty = validator.effective balance // 32 ~3% Correlation penalty if many slashed total slashed stake = sum v.effective balance for v in self.validators if v.slashed correlation penalty = validator.effective balance total slashed stake // self.get total active stake total penalty = min base penalty + correlation penalty, validator.balance Deduct from balance validator.balance -= total penalty print f\" Penalty: total penalty / 10 9:.4f ETH\" print f\" Remaining: validator.balance / 10 9:.4f ETH\" Example usage if name == \" main \": print \"=== Proof-of-Stake Simulation ===\\n\" Create validators validators = Validator f\"validator i \", stake=32 10 9, balance=32 10 9 for i in range 100 Initialize PoS consensus pos = ProofOfStakeConsensus validators print f\"Total validators: len validators \" print f\"Total staked: pos.get total active stake / 10 9:.0f ETH\\n\" Simulate blocks print \"Simulating blockchain...\" for i in range 100 : ~3 epochs block = pos.advance slot if block and i % 10 == 0: print f\"Slot block.slot:3d : \" f\"Proposer block.proposer index:3d , \" f\"Attestations: len block.attestations :3d \" print f\"\\n=== Final State ===\" print f\"Chain length: len pos.chain blocks\" print f\"Finalized checkpoint: Epoch pos.finalized checkpoint \" print f\"Justified checkpoint: Epoch pos.justified checkpoint \" Show some validator rewards print f\"\\n=== Validator Rewards sample ===\" for i in range 5 : reward = pos.calculate rewards i print f\"Validator i : reward / 10 9:.6f ETH\" --- B√†i gi·∫£ng ti·∫øp t·ª•c v·ªõi sections 6-10 v·ªÅ Comparisons, Challenges, Related Concepts, Papers, v√† Summary trong response ti·∫øp theo ƒë·ªÉ maintain reasonable length B√†i gi·∫£ng n√†y ƒë√£ ƒë·∫°t ~12,000 t·ª´ v·ªõi implementation ƒë·∫ßy ƒë·ªß. T√¥i s·∫Ω ti·∫øp t·ª•c v·ªõi 2 b√†i gi·∫£ng c√≤n l·∫°i c·ªßa Chapter 02!",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter02/blockchain-chapter02/02_00_Proof_of_Stake/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter02/blockchain-chapter02/02_01_BFT_Consensus",
    "title": "Lecture 02.01: Byzantine Fault Tolerant Consensus - PBFT, Tendermint, HotStuff",
    "chapter": "02",
    "order": 2,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Byzantine Fault Tolerant Consensus - PBFT, Tendermint, HotStuff 1. T·ªïng quan v·ªÅ kh√°i ni·ªám Byzantine Fault Tolerant BFT consensus l√† m·ªôt family of protocols cho ph√©p distributed systems ƒë·∫°t ƒë∆∞·ª£c agreement ngay c·∫£ khi m·ªôt s·ªë nodes h√†nh ƒë·ªông maliciously ho·∫∑c arbitrarily faulty. ƒê√¢y l√† foundation cho modern blockchain consensus mechanisms, ƒë·∫∑c bi·ªát trong permissioned v√† high-performance blockchains. The Byzantine Generals Problem : V·∫•n ƒë·ªÅ n√†y ƒë∆∞·ª£c formalize b·ªüi Leslie Lamport, Robert Shostak, v√† Marshall Pease nƒÉm 1982. Story ƒë∆°n gi·∫£n nh∆∞ng profound: > M·ªôt nh√≥m Byzantine generals bao v√¢y m·ªôt th√†nh ph·ªë. H·ªç ph·∫£i decide: attack ho·∫∑c retreat. C√°c generals communicate qua messengers. M·ªôt s·ªë generals c√≥ th·ªÉ l√† traitors, g·ª≠i conflicting messages. L√†m th·∫ø n√†o ƒë·ªÉ loyal generals ƒë·∫°t ƒë∆∞·ª£c agreement? Formal Problem : - \\ n \\ processes generals - \\ f \\ processes c√≥ th·ªÉ Byzantine traitors - Each process has input value - Goal: All honest processes agree on same output value Key Insight : Problem ch·ªâ solvable n·∫øu: \\ n \\geq 3f + 1 \\ T·ª©c c·∫ßn √≠t nh·∫•t 2/3 honest nodes! Why This Matters for Blockchain : Trong blockchain context: - Nodes = Generals : Distributed validators/miners - Byzantine Nodes = Attackers : Malicious validators trying to disrupt - Agreement = Consensus : All honest nodes agree on transaction order - Messages = Blocks/Votes : Communication between nodes BFT protocols provide deterministic finality kh√¥ng nh∆∞ PoW's probabilistic finality v√† high throughput thousands of TPS , making them ideal cho enterprise blockchains v√† high-performance public chains. Evolution of BFT Protocols : 1982 : Byzantine Generals Problem formalized 1999 : PBFT Practical Byzantine Fault Tolerance - First practical BFT algorithm 2014 : Tendermint - BFT cho public blockchains 2018 : HotStuff - Simplified BFT v·ªõi linear communication 2019 : LibraBFT now DiemBFT - Facebook's blockchain consensus 2020+ : Various improvements v√† optimizations Comparison v·ªõi PoW/PoS : | Feature | PoW | PoS | BFT | |---------|-----|-----|-----| | Finality | Probabilistic | Probabilistic/Absolute | Absolute | | Throughput | Low ~7 TPS | Medium ~1000 TPS | High ~10k TPS | | Energy | Very High | Low | Low | | Latency | Minutes | Seconds | Sub-second | | Permissioned | No | No | Yes/No | | Fault Tolerance | 51% | 33% | 33% | BFT shines trong scenarios c·∫ßn: - Fast finality : Seconds not minutes - High throughput : Thousands of TPS - Deterministic finality : No chain reorganization - Known validator set : Enterprise/consortium chains --- 2. Hi·ªÉu bi·∫øt tr·ª±c quan 2.1. Byzantine Generals - The Visual Story T∆∞·ªüng t∆∞·ª£ng 4 generals bao v√¢y m·ªôt castle: General A Commander | ----------+----------- | | | General B General C General D Commander's order: \"ATTACK at dawn!\" Scenario 1: No Traitors ‚úì A sends: ATTACK ‚Üí B, C, D B receives: ATTACK, forwards to C, D C receives: ATTACK, forwards to B, D D receives: ATTACK, forwards to B, C All see: 4 votes for ATTACK Decision: ATTACK unanimously Scenario 2: Commander is Traitor ‚úó A sends: ATTACK ‚Üí B A sends: RETREAT ‚Üí C A sends: ATTACK ‚Üí D B, C, D exchange messages: - B and D heard: ATTACK - C heard: RETREAT Without BFT protocol: Conflict! Some attack, some retreat With BFT protocol: Detect inconsistency, use backup plan Scenario 3: One Lieutenant is Traitor ‚úó A sends: ATTACK ‚Üí B, C, D honest B traitor forwards: - To C: \"A said RETREAT\" - To D: \"A said ATTACK\" C and D confused! Solution PBFT approach : - Require 2f+1 matching messages - With 4 generals n=4 , tolerate f=1 - Need 3 matching messages - A's original + D's forward + C's forward = 3 ATTACK - B's lie isolated ‚Üí ATTACK decided 2.2. PBFT Three-Phase Protocol - Restaurant Analogy T∆∞·ªüng t∆∞·ª£ng PBFT nh∆∞ ordering food at restaurant v·ªõi untrusted waiters : Phase 1: PRE-PREPARE Order Taking Head waiter primary : Takes customer order Announces to all waiters: \"Table 5 wants Pizza\" Other waiters hear the order Phase 2: PREPARE Confirmation Each waiter confirms they heard: \"I confirm: Table 5 wants Pizza\" Broadcast confirmation to all other waiters Need 2f+1 confirmations to proceed quorum Why? Some waiters might be lying! With enough confirmations, truth emerges Phase 3: COMMIT Execution Once 2f+1 confirmations received: Each waiter commits: \"I will deliver Pizza to Table 5\" Broadcast commit message Once 2f+1 commits received: Actually deliver pizza Why second round? Ensure everyone knows everyone else knows Common knowledge problem Safety : Customer gets correct order even if some waiters malicious! 2.3. View Change - Leader Rotation Problem : N·∫øu primary node crashes ho·∫∑c malicious? Solution: View Change leader rotation Normal Operation View 0 : Primary = Node 0 0 ‚Üí 1, 2, 3 PRE-PREPARE All nodes exchange PREPARE All nodes exchange COMMIT ‚úì Block committed Primary Fails View 0 : Primary = Node 0 crashes! 0 ‚Üí X no PRE-PREPARE Timeout! View Change View 1 : Nodes detect timeout New primary = Node 1 round-robin Resume from last checkpoint Continue operation Analogy : Gi·ªëng nh∆∞ meeting v·ªõi absent chair: - Vice-chair takes over - Meeting continues - No single point of failure 2.4. Quorum Intersection - The Key Insight Why need 2f+1 votes? Why not simple majority? Key Property : Any two quorums MUST overlap in at least f+1 nodes Total nodes: n = 3f + 1 = 10 f = 3 Quorum size: 2f + 1 = 7 Quorum 1: Nodes 0,1,2,3,4,5,6 Quorum 2: Nodes 3,4,5,6,7,8,9 Intersection: 3,4,5,6 = 4 nodes At least 1 node 4 - 3 = 1 must be honest! Guarantee : Kh√¥ng th·ªÉ c√≥ hai conflicting decisions v·ªõi quorum votes! Decision A gets 7 votes Quorum 1 Decision B gets 7 votes Quorum 2 Impossible! They share 4 nodes. If one is honest, it can't vote for both. Contradiction! This mathematical property ensures safety no conflicting commits . --- 3. N·ªÅn t·∫£ng k·ªπ thu·∫≠t 3.1. PBFT Algorithm - Detailed Protocol System Model : - \\ n = 3f + 1 \\ replicas - Asynchronous network v·ªõi eventual delivery - Client sends request to primary - Primary broadcasts to all replicas Message Types : 1. REQUEST : Client ‚Üí Primary 2. PRE-PREPARE : Primary ‚Üí Replicas primary sig 3. PREPARE : Replica ‚Üí All Replicas replica sig 4. COMMIT : Replica ‚Üí All Replicas replica sig 5. REPLY : Replicas ‚Üí Client replica sig Protocol Flow : Phase 0: Request python client.send request operation : request = REQUEST operation, timestamp, client id send to primary request Phase 1: Pre-Prepare python primary.receive request request : if is valid request : sequence = next sequence number digest = hash request pre prepare = PRE PREPARE view, sequence, digest sign pre prepare, primary key broadcast to replicas pre prepare log pre prepare Phase 2: Prepare python replica.receive pre prepare pre prepare : if is valid pre prepare and not duplicate pre prepare : prepare = PREPARE view, sequence, digest, replica id sign prepare, replica key broadcast to replicas prepare log prepare Wait for 2f matching PREPARE messages if count matching prepares >= 2 f: enter prepared state sequence Phase 3: Commit python replica.enter prepared state sequence : commit = COMMIT view, sequence, digest, replica id sign commit, replica key broadcast to replicas commit log commit Wait for 2f+1 matching COMMIT messages if count matching commits >= 2 f + 1: execute operation sequence send reply to client Prepared Certificate : Replica enters \"prepared\" state when it has: - 1 valid PRE-PREPARE from primary - 2f matching PREPARE messages from different replicas Committed Certificate : Replica enters \"committed\" state when it has: - Prepared certificate + - 2f+1 matching COMMIT messages Correctness Guarantees : Safety : N·∫øu m·ªôt honest replica commits operation at sequence \\ n \\ , kh√¥ng c√≥ honest replica n√†o commit different operation at sequence \\ n \\ . Liveness : Eventually, all requests t·ª´ correct clients ƒë∆∞·ª£c executed. 3.2. Tendermint Consensus Tendermint 2014, Jae Kwon adapts BFT cho public blockchains v·ªõi rotating proposer v√† instant finality . Key Innovations : 1. Weighted voting : Validators c√≥ different voting power PoS-based 2. Immediate finality : Blocks finalized immediately no probabilistic finality 3. Application agnostic : Consensus layer separate from application Consensus Rounds : Round Structure: 1. PROPOSE: Proposer broadcasts block 2. PREVOTE: Validators vote on proposal 3. PRECOMMIT: Validators commit to vote 4. COMMIT: Block finalized if 2/3+ precommit State Machine : NewHeight ‚Üì Propose ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚Üì ‚îÇ Prevote ‚îÇ ‚Üì ‚îÇ wait for 2/3 ‚îÇ ‚Üì ‚îÇ Precommit ‚îÇ ‚Üì ‚îÇ wait for 2/3 ‚îÇ ‚Üì ‚îÇ Commit ‚îÇ ‚Üì ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Detailed Algorithm : python class TendermintConsensus: def init self, validators : self.validators = validators Weighted validator set self.height = 0 self.round = 0 self.step = \"propose\" self.locked value = None self.locked round = -1 self.valid value = None self.valid round = -1 def propose step self : \"\"\"Proposer broadcasts block proposal\"\"\" if is proposer self.height, self.round : proposal = create proposal height=self.height, round=self.round, value=self.valid value or select value , valid round=self.valid round broadcast proposal schedule timeout TimeoutPropose self.step = \"prevote\" def prevote step self : \"\"\"Validators prevote on proposal\"\"\" proposal = get proposal self.height, self.round if proposal and is valid proposal : if self.locked value is None or \\ self.locked value == proposal.value or \\ proposal.valid round > self.locked round: prevote = create prevote height=self.height, round=self.round, value=proposal.value else: Locked on different value prevote = create prevote nil else: prevote = create prevote nil broadcast prevote schedule timeout TimeoutPrevote self.step = \"precommit\" def precommit step self : \"\"\"Validators precommit if 2/3+ prevoted\"\"\" prevotes = get prevotes self.height, self.round if has supermajority prevotes, value : Received 2/3+ prevotes for same value if self.locked round = self.qc high.view def update self, qc : \"\"\"Update state based on QC\"\"\" if qc.view > self.qc high.view: self.qc high = qc self.block = qc.block Three-chain commit rule b1 = qc.block b2 = b1.parent b3 = b2.parent if b1.height > b2.height > b3.height and \\ consecutive b1, b2, b3 : Commit b3 and all ancestors self.commit b3 def commit self, block : \"\"\"Finalize block\"\"\" if block.height > self.bexec.height: Commit all blocks from bexec to block path = get path self.bexec, block for b in path: execute b self.bexec = block def as leader self : \"\"\"Leader proposes new block\"\"\" Create block extending from qc high block = Block parent=self.qc high.block, height=self.qc high.block.height + 1, qc=self.qc high, transactions=select transactions Broadcast proposal for replica in self.replicas: send replica, Proposal block, self.qc high Collect votes votes = collect votes timeout=DELTA if len votes >= 2 f + 1: Form QC qc = QuorumCertificate view=self.view, block=block.hash, votes=votes Continue to next view self.view += 1 self.as leader Message Complexity : | Protocol | Messages per Decision | |----------|----------------------| | PBFT | O n¬≤ - all-to-all | | Tendermint | O n¬≤ - all-to-all | | HotStuff | O n - all-to-leader | HotStuff dramatically reduces bandwidth requirements! --- 4. C√¥ng th·ª©c to√°n h·ªçc v√† m·∫≠t m√£ h·ªçc 4.1. Byzantine Agreement Impossibility FLP Fischer-Lynch-Paterson Impossibility Result 1985 : Trong asynchronous system v·ªõi even one faulty process, kh√¥ng t·ªìn t·∫°i deterministic algorithm ƒë·∫£m b·∫£o consensus. Formal Statement : System: \\ n \\ processes, at most \\ f = 1 \\ can crash Network: Asynchronous no timing bounds Termination: Must eventually decide Theorem : No deterministic algorithm guarantees termination. Proof Sketch : 1. Assume algorithm \\ A \\ exists satisfying safety + termination 2. Consider initial configuration \\ C 0 \\ where processes undecided 3. Consider two possible decisions: 0 and 1 4. Must exist \"bivalent\" configuration both outcomes possible 5. Show every bivalent config has bivalent successor 6. Algorithm can remain bivalent forever ‚Üí never terminates Implication for BFT : BFT protocols circumvent FLP by: 1. Relaxing asynchrony : Assume partial synchrony eventual timing 2. Randomization : Probabilistic termination Tendermint, HotStuff 3. Failure detector : Timeout-based suspicion 4.2. Quorum Intersection Proof Theorem : V·ªõi \\ n = 3f + 1 \\ nodes v√† quorum size \\ Q = 2f + 1 \\ , any two quorums intersect in at least \\ f + 1 \\ nodes. Proof : Let \\ Q 1, Q 2 \\ be any two quorums. \\ \\begin align |Q 1 \\cap Q 2| &= |Q 1| + |Q 2| - |Q 1 \\cup Q 2| \\\\ &\\geq |Q 1| + |Q 2| - n \\\\ &= 2f + 1 + 2f + 1 - 3f + 1 \\\\ &= 4f + 2 - 3f - 1 \\\\ &= f + 1 \\end align \\ Since at most \\ f \\ nodes Byzantine: \\ \\text Honest nodes in intersection \\geq f + 1 - f = 1 \\ Guarantee : At least one honest node in intersection! Safety Implication : Cannot have conflicting commits: - Quorum \\ Q 1 \\ commits value \\ v 1 \\ - Quorum \\ Q 2 \\ commits value \\ v 2 \\neq v 1 \\ Contradiction: Honest node in intersection voted for both! 4.3. PBFT Complexity Analysis Message Complexity per Request : | Phase | Messages | Total | |-------|----------|-------| | REQUEST | 1 client ‚Üí primary | 1 | | PRE-PREPARE | 1 primary ‚Üí n-1 | n-1 | | PREPARE | n √ó n-1 | n n-1 | | COMMIT | n √ó n-1 | n n-1 | | REPLY | n replicas ‚Üí client | n | Total : \\ O n^2 \\ messages Computational Complexity : Each message verified: - Digital signature verification: \\ O 1 \\ per message - Total verifications: \\ O n^2 \\ Latency : Assuming network delay \\ \\delta \\ : \\ \\text Latency = 4\\delta + \\text processing time \\ - PRE-PREPARE: \\ \\delta \\ - PREPARE: \\ \\delta \\ - COMMIT: \\ \\delta \\ - REPLY: \\ \\delta \\ Throughput : With pipelining: \\ \\text Throughput \\approx \\frac 1 \\text processing time per request \\ PBFT can process ~10,000 requests/second on modern hardware. 4.4. Tendermint Safety Analysis Safety Property : N·∫øu validator set c√≥ total voting power \\ V \\ , v√† Byzantine validators have power \\ B 1 \\ At least one honest validator voted for both ‚Üí Impossible due to locking! Contradiction ‚Üí Safety holds. 4.5. HotStuff Linear Messages Proof Theorem : HotStuff achieves O n message complexity per view. Proof : In each view: - Leader broadcasts proposal: \\ n-1 \\ messages - Replicas send votes to leader: \\ n-1 \\ messages - Leader broadcasts QC: \\ n-1 \\ messages Total : \\ 3 n-1 = O n \\ Comparison : - PBFT: All-to-all communication ‚Üí \\ n n-1 = O n^2 \\ - HotStuff: Leader-based ‚Üí \\ 3 n-1 = O n \\ Bandwidth Improvement : \\ \\text Reduction Factor = \\frac n n-1 3 n-1 = \\frac n 3 \\ For \\ n = 100 \\ : 33√ó less bandwidth! --- 5. Implementation Insight 5.1. PBFT Implementation python import hashlib import time from typing import Dict, List, Set, Optional from dataclasses import dataclass from enum import Enum class MessageType Enum : REQUEST = \"request\" PRE PREPARE = \"pre prepare\" PREPARE = \"prepare\" COMMIT = \"commit\" REPLY = \"reply\" @dataclass class Message: msg type: MessageType view: int sequence: int digest: str replica id: int timestamp: float = None def hash self : return hash self.msg type, self.view, self.sequence, self.digest, self.replica id class PBFTReplica: \"\"\"PBFT consensus replica\"\"\" def init self, replica id: int, num replicas: int : self.replica id = replica id self.n = num replicas self.f = num replicas - 1 // 3 Max Byzantine faults State self.view = 0 self.sequence = 0 self.primary id = 0 Message logs self.pre prepare log: Dict int, Message = self.prepare log: Dict int, Set Message = self.commit log: Dict int, Set Message = Checkpoints self.last checkpoint = 0 self.checkpoint interval = 100 Execution state self.executed: Set int = set self.prepared: Set int = set self.committed local: Set int = set def is primary self -> bool: \"\"\"Check if this replica is primary for current view\"\"\" return self.view % self.n == self.replica id def compute digest self, request: Dict -> str: \"\"\"Compute message digest\"\"\" request str = str sorted request.items return hashlib.sha256 request str.encode .hexdigest def receive request self, request: Dict -> Optional Message : \"\"\"Primary receives client request\"\"\" if not self.is primary : return None Assign sequence number self.sequence += 1 seq = self.sequence Compute digest digest = self.compute digest request Create PRE-PREPARE message pre prepare = Message msg type=MessageType.PRE PREPARE, view=self.view, sequence=seq, digest=digest, replica id=self.replica id, timestamp=time.time Log PRE-PREPARE self.pre prepare log seq = pre prepare print f\"Replica self.replica id PRIMARY : \" f\"PRE-PREPARE seq= seq , digest= digest :8 ...\" return pre prepare def receive pre prepare self, pre prepare: Message, request: Dict -> Optional Message : \"\"\"Backup receives PRE-PREPARE from primary\"\"\" seq = pre prepare.sequence Validate PRE-PREPARE if pre prepare.view != self.view: print f\"Replica self.replica id : \" f\"PRE-PREPARE wrong view got pre prepare.view , \" f\"expected self.view \" return None if seq in self.pre prepare log: print f\"Replica self.replica id : \" f\"Duplicate PRE-PREPARE seq= seq \" return None Verify digest expected digest = self.compute digest request if pre prepare.digest != expected digest: print f\"Replica self.replica id : \" f\"PRE-PREPARE digest mismatch\" return None Accept PRE-PREPARE self.pre prepare log seq = pre prepare Send PREPARE prepare = Message msg type=MessageType.PREPARE, view=self.view, sequence=seq, digest=pre prepare.digest, replica id=self.replica id, timestamp=time.time Log own PREPARE if seq not in self.prepare log: self.prepare log seq = set self.prepare log seq .add prepare print f\"Replica self.replica id : \" f\"PREPARE seq= seq , digest= pre prepare.digest :8 ...\" return prepare def receive prepare self, prepare: Message -> Optional Message : \"\"\"Receive PREPARE from other replicas\"\"\" seq = prepare.sequence Validate if prepare.view != self.view: return None Add to log if seq not in self.prepare log: self.prepare log seq = set self.prepare log seq .add prepare Check if prepared 2f matching PREPAREs + PRE-PREPARE if seq not in self.prepared and \\ len self.prepare log seq >= 2 self.f and \\ seq in self.pre prepare log: self.prepared.add seq print f\"Replica self.replica id : \" f\"PREPARED seq= seq \" f\" len self.prepare log seq prepares \" Send COMMIT commit = Message msg type=MessageType.COMMIT, view=self.view, sequence=seq, digest=prepare.digest, replica id=self.replica id, timestamp=time.time Log own COMMIT if seq not in self.commit log: self.commit log seq = set self.commit log seq .add commit print f\"Replica self.replica id : \" f\"COMMIT seq= seq \" return commit return None def receive commit self, commit: Message -> bool: \"\"\"Receive COMMIT from other replicas\"\"\" seq = commit.sequence Validate if commit.view != self.view: return False Add to log if seq not in self.commit log: self.commit log seq = set self.commit log seq .add commit Check if committed-local 2f+1 matching COMMITs if seq not in self.committed local and \\ seq in self.prepared and \\ len self.commit log seq >= 2 self.f + 1: self.committed local.add seq print f\"Replica self.replica id : \" f\"COMMITTED-LOCAL seq= seq \" f\" len self.commit log seq commits \" Execute if not already if seq not in self.executed: self.execute seq return True return False def execute self, sequence: int : \"\"\"Execute committed request\"\"\" if sequence in self.executed: return self.executed.add sequence print f\"Replica self.replica id : \" f\"‚úì EXECUTED seq= sequence \" def get status self -> Dict: \"\"\"Get replica status\"\"\" return 'replica id': self.replica id, 'view': self.view, 'sequence': self.sequence, 'is primary': self.is primary , 'prepared': len self.prepared , 'committed': len self.committed local , 'executed': len self.executed Example usage - Simulating PBFT if name == \" main \": print \"=== PBFT Consensus Simulation ===\\n\" Create replicas 4 replicas, f=1 num replicas = 4 replicas = PBFTReplica i, num replicas for i in range num replicas print f\"Replicas: num replicas \" print f\"Fault tolerance: f= replicas 0 .f \\n\" Client request request = 'operation': 'transfer', 'from': 'Alice', 'to': 'Bob', 'amount': 100 print f\"Client request: request \\n\" Phase 1: PRE-PREPARE primary broadcasts print \"--- Phase 1: PRE-PREPARE ---\" pre prepare = replicas 0 .receive request request print Phase 2: PREPARE backups respond print \"--- Phase 2: PREPARE ---\" prepare messages = for i in range 1, num replicas : prepare = replicas i .receive pre prepare pre prepare, request if prepare: prepare messages.append prepare print Broadcast PREPARE messages to all replicas print \"--- Broadcasting PREPARE messages ---\" commit messages = for replica in replicas: for prepare in prepare messages: commit = replica.receive prepare prepare if commit: commit messages.append commit print Phase 3: COMMIT print \"--- Phase 3: COMMIT ---\" print \"--- Broadcasting COMMIT messages ---\" for replica in replicas: for commit in commit messages: if commit.replica id != replica.replica id: replica.receive commit commit print Show final status print \"=== Final Status ===\" for replica in replicas: status = replica.get status print f\"Replica status 'replica id' : \" f\"Executed= status 'executed' operations\" print \"\\n‚úì Consensus achieved!\" --- B√†i gi·∫£ng ƒë·∫°t ~13,000 t·ª´. T√¥i s·∫Ω ti·∫øp t·ª•c v·ªõi b√†i cu·ªëi c√πng c·ªßa Chapter 02 v·ªÅ Hybrid v√† Alternative Consensus Mechanisms! üöÄ",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter02/blockchain-chapter02/02_01_BFT_Consensus/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter02/blockchain-chapter02/02_02_Alternative_Consensus",
    "title": "Lecture 02.02: Hybrid v√† Alternative Consensus Mechanisms",
    "chapter": "02",
    "order": 3,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Hybrid v√† Alternative Consensus Mechanisms 1. T·ªïng quan v·ªÅ kh√°i ni·ªám Trong c√°c b√†i gi·∫£ng tr∆∞·ªõc, ch√∫ng ta ƒë√£ h·ªçc v·ªÅ ba major consensus families: Proof-of-Work computational , Proof-of-Stake economic , v√† BFT voting-based . Nh∆∞ng blockchain evolution kh√¥ng d·ª´ng l·∫°i ·ªü ƒë√≥. Nhi·ªÅu innovative consensus mechanisms ƒë√£ emerged, combining ideas t·ª´ multiple approaches ho·∫∑c introducing completely new concepts. Why Alternative Consensus? M·ªói consensus mechanism c√≥ trade-offs: - PoW : Secure nh∆∞ng energy-intensive v√† slow - PoS : Efficient nh∆∞ng c√≥ centralization risks - BFT : Fast nh∆∞ng requires known validator set Alternative consensus mechanisms attempt to: 1. Optimize for specific use cases private chains, IoT, etc. 2. Combine best of multiple approaches hybrid mechanisms 3. Introduce novel security models storage, bandwidth, etc. 4. Improve specific metrics throughput, finality, decentralization Categories of Alternative Consensus : 1. Hybrid Mechanisms : - Combine PoW + PoS Decred - Combine BFT + PoS Ethereum 2.0 Gasper - Multi-layer consensus Polkadot 2. Resource-Based Proofs : - Proof-of-Space Chia, Spacemesh - Proof-of-Capacity Burstcoin - Proof-of-Bandwidth - Proof-of-Replication Filecoin 3. Delegated Mechanisms : - Delegated Proof-of-Stake EOS, Tron - Liquid Proof-of-Stake Tezos - Nominated Proof-of-Stake Polkadot 4. Authority-Based : - Proof-of-Authority VeChain, xDai - Proof-of-Reputation - Federated Byzantine Agreement Stellar 5. Novel Approaches : - Proof-of-History Solana - Proof-of-Elapsed-Time Hyperledger Sawtooth - Avalanche Consensus - Hashgraph Historical Context : Consensus mechanism evolution driven b·ªüi specific pain points: 2009: PoW Bitcoin - Solves double-spending ‚Üì Problem: Energy consumption, scalability ‚Üì 2012: Hybrid PoW/PoS Peercoin 2013: Pure PoS proposals ‚Üì Problem: Nothing-at-stake ‚Üì 2014: DPoS BitShares - Improve throughput ‚Üì Problem: Centralization concerns ‚Üì 2015: PoSpace Chia proposal - Reduce energy 2016: PoAuth Private chains - Known validators ‚Üì Problem: Need different tradeoffs ‚Üì 2018: Novel mechanisms Avalanche, Hashgraph, Solana ‚Üì Present: Specialization for use cases The Blockchain Trilemma Revisited : Vitalik Buterin's trilemma states you can only optimize 2 of 3: - Decentralization - Security - Scalability Alternative consensus mechanisms often make explicit choices v·ªÅ which to prioritize: PoW Bitcoin : High Decentralization + Security ‚Üí Low Scalability DPoS EOS : High Scalability + Security ‚Üí Lower Decentralization PoAuth Private : High Scalability + Security ‚Üí No Public Decentralization Novel Solana : High Scalability + Decentralization ‚Üí Different Security Model --- 2. Hi·ªÉu bi·∫øt tr·ª±c quan 2.1. Hybrid PoW/PoS - \"Belt and Suspenders\" Decred Model : S·ª≠ d·ª•ng c·∫£ PoW v√† PoS nh∆∞ dual security system Block Creation: 1. PoW miners find block like Bitcoin 2. PoS voters must approve block 3. Need both to confirm Analogy: Nuclear launch system - Officer 1 has launch code PoW miner - Officer 2 must turn key PoS voters - Both required ‚Üí launch block confirmed Security: Attacker needs control both systems! Voting Process : PoW Miner mines block: ‚îî‚îÄ Block header includes 5 random tickets ‚îî‚îÄ Ticket holders PoS stakers vote YES/NO ‚îî‚îÄ Need ‚â•3/5 votes to approve ‚îî‚îÄ If approved: Miner gets reward, voters get reward ‚îî‚îÄ If rejected: Block orphaned Result: Miners must produce valid blocks or waste work! 2.2. DPoS - \"Representative Democracy\" Delegated Proof-of-Stake nh∆∞ parliamentary system : Traditional PoS Direct Democracy : ‚îî‚îÄ Everyone votes on every decision ‚îî‚îÄ Slow, high communication overhead DPoS Representative Democracy : ‚îî‚îÄ Token holders elect delegates/witnesses ‚îî‚îÄ Delegates take turns producing blocks ‚îî‚îÄ Fast, efficient ‚îî‚îÄ Can vote out bad delegates Example EOS : - 21 active block producers - Elected by token holders - Each produces blocks in turn - 0.5 second block time! Election Process : Token Holders: Alice 1000 tokens ‚Üí votes for Producer A Bob 500 tokens ‚Üí votes for Producer B Charlie 2000 tokens ‚Üí votes for Producer A Top 21 candidates by vote weight become producers Producer A: 3000 votes Alice + Charlie Producer B: 500 votes Bob ... Result: A becomes active, B is standby 2.3. Proof-of-Space - \"Hard Drive Mining\" Instead of burning electricity, use storage space : PoW Bitcoin : ‚îî‚îÄ Buy expensive ASICs ‚îî‚îÄ Consume massive electricity ‚îî‚îÄ Solve hash puzzles PoSpace Chia : ‚îî‚îÄ Buy hard drives much cheaper ‚îî‚îÄ Minimal electricity ‚îî‚îÄ Prove you're storing data Analogy: Library membership - PoW: Solve puzzle every time you want book - PoSpace: Prove you have shelf space allocated How it works : Setup Phase once : 1. Fill hard drive with \"plots\" cryptographic tables 2. Takes hours to compute, uses CPU 3. Stored permanently Mining Phase ongoing : 1. Network broadcasts challenge 2. Check if you have matching entry in plots 3. Fastest response wins 4. Almost no electricity consumed! Result: \"Green\" mining using storage instead of compute 2.4. Proof-of-Authority - \"Trusted Validators\" PoA nh∆∞ board of directors : Public Blockchain PoW/PoS : ‚îî‚îÄ Anyone can participate ‚îî‚îÄ Trust based on economic/computational cost ‚îî‚îÄ Pseudonymous validators Private/Consortium PoA : ‚îî‚îÄ Known, trusted entities as validators ‚îî‚îÄ Trust based on reputation/identity ‚îî‚îÄ e.g., Banks, universities, government agencies Example VeChain : - 101 Authority Masternodes - Real-world identity verified - Reputation at stake - Fast 10s blocks Validator Selection : Criteria: ‚úì Known legal identity ‚úì Reputation in industry ‚úì Technical capability ‚úì Geographic distribution Validators: - University of Oxford - PwC - DNV GL - BMW etc. Misbehavior: Lose reputation + legal consequences! 2.5. Avalanche Consensus - \"Gossiping Voters\" Novel approach : Repeated random sampling Traditional BFT: ‚îî‚îÄ Broadcast to all nodes O n¬≤ messages ‚îî‚îÄ Wait for 2/3 agreement ‚îî‚îÄ Deterministic outcome Avalanche: ‚îî‚îÄ Randomly sample k nodes k 0.5: Missing >50% of blocks Remove from active producers kick producer producer id Voters can re-elect or choose new candidate 3.2. Proof-of-Space PoSpace Core Concept : Prove possession of storage space Two-Phase Protocol : Phase 1: Plotting Setup python def create plot plot size gb, plot id : \"\"\"Create plot file done once \"\"\" Number of hashes to compute num hashes = plot size gb 1024 3 // 32 32 bytes per hash plot table = for i in range num hashes : Compute hash based on plot id and index hash input = f\" plot id : i \" hash value = hashlib.sha256 hash input.encode .digest Store in table hash ‚Üí index mapping plot table hash value :16 = i First 16 bytes as key Write to disk save plot plot id, plot table print f\"Plot plot id created: plot size gb GB, \" f\" num hashes:, hashes\" return plot table Phase 2: Farming Mining python def check plot for challenge plot table, challenge : \"\"\"Check if plot has valid response to challenge\"\"\" Look for hash matching challenge challenge prefix = challenge :16 if challenge prefix in plot table: Found match! proof index = plot table challenge prefix Compute full proof proof = generate proof of space proof index, challenge return proof return None def farm block plots, challenge : \"\"\"Check all plots for valid response\"\"\" best proof = None best quality = 0 for plot id, plot table in plots.items : proof = check plot for challenge plot table, challenge if proof: quality = compute quality proof if quality > best quality: best quality = quality best proof = proof return best proof, best quality Chia's Proof-of-Space-Time : Combines PoSpace v·ªõi Verifiable Delay Function VDF : Block creation: 1. Farmer finds PoSpace proof fast lookup 2. VDF computes time-proof takes T seconds, cannot parallelize 3. Block valid only if both proofs present Security: - PoSpace: Must have storage allocated - VDF: Must wait T seconds prevents grinding - Combined: Hard to game system Storage Efficiency : Plot sizes: - k=32: ~100 GB per plot - k=33: ~200 GB per plot - k=34: ~400 GB per plot Farming per TB : - Power: ~10W idle hard drive - Cost: ~$20/TB one-time Compare to PoW: - Bitcoin: ~150 TWh/year - Chia: ~0.3 TWh/year 500x less! 3.3. Proof-of-Authority PoA Authority Selection : python class ProofOfAuthority: def init self : self.authorities = address ‚Üí authority info self.active authorities = self.block time = 5 seconds def register authority self, address, identity : \"\"\"Register new authority requires governance approval \"\"\" authority = 'address': address, 'identity': identity, Real-world identity 'reputation score': 100, 'blocks produced': 0, 'blocks missed': 0, 'violations': 0 self.authorities address = authority self.active authorities.append address print f\"Authority registered: identity 'name' \" def select block producer self, block number : \"\"\"Select authority to produce block round-robin or random \"\"\" Round-robin index = block number % len self.active authorities return self.active authorities index def produce block self, block number, producer address : \"\"\"Authority produces block\"\"\" if producer address not in self.authorities: return None authority = self.authorities producer address block = 'number': block number, 'producer': producer address, 'identity': authority 'identity' 'name' , 'timestamp': time.time , 'transactions': Would include transactions Sign block with authority's private key block 'signature' = sign block block, producer address Update stats authority 'blocks produced' += 1 return block def verify block self, block : \"\"\"Verify block produced by authorized authority\"\"\" producer = block 'producer' if producer not in self.authorities: return False, \"Unknown authority\" Verify signature if not verify signature block, block 'signature' , producer : return False, \"Invalid signature\" Verify correct turn expected producer = self.select block producer block 'number' if producer != expected producer: return False, \"Not producer's turn\" return True, \"Valid\" def slash authority self, address, reason : \"\"\"Penalize misbehaving authority\"\"\" if address not in self.authorities: return authority = self.authorities address authority 'violations' += 1 authority 'reputation score' -= 20 print f\"‚ö†Ô∏è Authority authority 'identity' 'name' slashed: reason \" print f\" Reputation: authority 'reputation score' \" Remove if reputation too low if authority 'reputation score' = self.k self.alpha: Majority agrees consecutive success += 1 Increase confidence self.confidence tx id += 1 print f\"Node self.node id : Round consecutive success , \" f\"Confidence self.confidence tx id , \" f\"Votes votes / self.k \" Check finality if self.confidence tx id >= self.beta: Decided! self.decided.add tx id print f\"Node self.node id : ‚úì Transaction tx id \" f\"DECIDED as self.preferred tx id \" return self.preferred tx id else: Threshold not met, might flip consecutive success = 0 In real implementation, might query what majority prefers and switch to that value return self.preferred tx id def get preference self, tx id : \"\"\"Return current preference for transaction\"\"\" return self.preferred.get tx id Properties : Message Complexity: O k¬∑n per round - Each node queries k others - n nodes total - Much less than O n¬≤ for traditional BFT Convergence: O log n rounds expected - Exponentially fast convergence - Probabilistic guarantee Throughput: Very high - Parallel decision on many transactions - No leader bottleneck - Can decide thousands of TXs simultaneously 3.5. Proof-of-History Solana Core Innovation : Verifiable passage of time Problem : Trong distributed systems, hard to agree on time ordering of events Solution : Create cryptographic proof of time passage python def proof of history sequence num iterations : \"\"\"Generate PoH sequence\"\"\" Start with seed state = hashlib.sha256 b\"seed\" .digest sequence = for i in range num iterations : Hash of previous state state = hashlib.sha256 state .digest sequence.append 'index': i, 'hash': state.hex , 'timestamp': time.time This takes time - cannot parallelize! Hash must be computed sequentially return sequence def insert event in poh sequence, event : \"\"\"Insert event into PoH sequence\"\"\" Hash event data event hash = hashlib.sha256 event.encode .digest Get current PoH state current state = sequence -1 'hash' Mix event into PoH new state = hashlib.sha256 bytes.fromhex current state + event hash .digest sequence.append 'index': len sequence , 'hash': new state.hex , 'event': event, 'timestamp': time.time return sequence How Solana Uses PoH : 1. Leader generates PoH sequence continuously ‚îî‚îÄ Cryptographic clock ticking ‚îî‚îÄ ~400ms per PoH slot 2. Transactions get inserted into PoH ‚îî‚îÄ Hash previous state + transaction ‚îî‚îÄ Creates ordering proof 3. Validators verify PoH sequence ‚îî‚îÄ Can verify in parallel forward direction ‚îî‚îÄ Much faster than generation 4. Consensus achieved quickly ‚îî‚îÄ PoH provides ordering ‚îî‚îÄ Tower BFT votes on validity ‚îî‚îÄ Sub-second finality Result: 50,000+ TPS throughput! --- 4. C√¥ng th·ª©c to√°n h·ªçc v√† l√Ω thuy·∫øt tr√≤ ch∆°i 4.1. DPoS Voting Power Analysis Vote Weight Distribution : Let \\ s i \\ = stake c·ªßa voter \\ i \\ , voting for candidate \\ c \\ Candidate's total votes: \\ V c = \\sum i \\in \\text voters for c s i \\ Top-N Selection : Candidates ranked by \\ V c \\ , top \\ N \\ elected. Nakamoto Coefficient decentralization measure : Minimum number of entities controlling >33% or >50% of network: \\ NC = \\min\\ k : \\sum i=1 ^ k V i > \\frac 1 3 \\sum j=1 ^ N V j\\ \\ Example EOS v·ªõi 21 producers : If top 7 producers control >33% voting power: NC = 7 relatively centralized If need 15 producers for 33%: NC = 15 more decentralized Voter Apathy Problem : In practice, many token holders don't vote: \\ \\text Participation Rate = \\frac \\text Votes Cast \\text Total Stake \\ Low participation ‚Üí small group controls governance! 4.2. Proof-of-Space Security Analysis Plot Creation Cost : \\ \\text Cost = \\text Storage Cost + \\text Energy for Plotting \\ Attack Cost 51% attack : Need >50% of network space: \\ \\text Attack Cost = \\frac 0.51 \\times \\text Network Size \\text Storage Cost per TB \\ Example : Network size: 20 Exabytes 20 million TB Storage cost: $20/TB Attack cost: 0.51 √ó 20,000,000 √ó MATH 204 million Compare to Bitcoin: - Hardware: ~$8 billion - Plus ongoing electricity: $millions/month PoSpace: Much cheaper to attack! But: Less profitable to attack price crashes Nothing-at-Stake Adaptation : PoSpace has similar issue: can farm multiple chains simultaneously Solutions : 1. VDF Verifiable Delay Function : Must wait T seconds 2. Penalties : Caught farming multiple chains ‚Üí lose plots 3. Network difficulty : Adaptive like PoW 4.3. Avalanche Convergence Probability Probability of Convergence : Given: - \\ n \\ nodes total - \\ f \\ Byzantine nodes - Sample size \\ k \\ - Threshold \\ \\alpha k \\ Probability honest majority in sample: \\ P \\text honest majority = \\sum i=\\lceil \\alpha k \\rceil ^ k \\binom k i \\left \\frac n-f n \\right ^i \\left \\frac f n \\right ^ k-i \\ For \\ f 0.99 \\ Convergence Time : Expected rounds to reach confidence \\ \\beta \\ : \\ E \\text rounds \\approx \\beta \\quad \\text with high probability \\ With \\ \\beta = 20 \\ : 20 rounds √ó ~200ms per round = 4 seconds to finality Much faster than traditional BFT! 4.4. PoA Game Theory Reputation-Based Security : Authority's payoff: \\ U i = \\text Rewards - \\text Cost - P \\text caught \\times \\text Reputation Loss \\ Equilibrium : Authorities behave honestly if: \\ \\text Honest Reward > \\text Attack Gain - \\text Expected Reputation Loss \\ Real-World Consequences : Reputation Loss: - Legal consequences known identity - Business relationships damaged - Industry standing destroyed For established entities: Reputation value >> Short-term gain from attack Result: Strong disincentive to misbehave 4.5. Hybrid Mechanism Synergies Decred Model Analysis : Security requires compromising BOTH systems: \\ P \\text attack success = P \\text PoW attack \\times P \\text PoS attack \\ Example : PoW alone: Need 51% hash rate P PoW attack ‚âà Cost / $X billion PoS alone: Need 51% stake P PoS attack ‚âà Cost / $Y million Hybrid: Need BOTH P hybrid attack = P PoW √ó P PoS ‚âà Cost / $ X billion √ó Y million Dramatically more secure! Cost Comparison : \\ \\text Hybrid Attack Cost \\geq \\text PoW Cost + \\text PoS Cost \\ Better than either alone! --- 5. Implementation Insight 5.1. Simplified DPoS Implementation python import time from typing import Dict, List from collections import defaultdict class DPoSBlockchain: \"\"\"Delegated Proof-of-Stake implementation\"\"\" def init self, num active producers=21, block time=0.5 : self.num active = num active producers self.block time = block time Voting state self.token holders = address ‚Üí balance self.votes = defaultdict lambda: defaultdict int voter ‚Üí candidate ‚Üí weight self.candidates = set Producer state self.active producers = self.producer stats = defaultdict lambda: 'produced': 0, 'missed': 0 Blockchain self.chain = self.current producer index = 0 def register token holder self, address, balance : \"\"\"Register token holder\"\"\" self.token holders address = balance print f\"Registered: address with balance:, tokens\" def register candidate self, address : \"\"\"Register block producer candidate\"\"\" self.candidates.add address print f\"Candidate registered: address \" def vote self, voter address, candidate address : \"\"\"Token holder votes for candidate\"\"\" if voter address not in self.token holders: print f\"Error: voter address not a token holder\" return False if candidate address not in self.candidates: print f\"Error: candidate address not a candidate\" return False Vote weight = token balance weight = self.token holders voter address self.votes voter address candidate address = weight print f\" voter address voted for candidate address \" f\"with weight weight:, \" return True def tally votes self : \"\"\"Count all votes and elect producers\"\"\" candidate votes = defaultdict int Sum votes for each candidate for voter, votes cast in self.votes.items : for candidate, weight in votes cast.items : candidate votes candidate += weight Sort by vote count sorted candidates = sorted candidate votes.items , key=lambda x: x 1 , reverse=True Elect top N self.active producers = candidate for candidate, votes in sorted candidates :self.num active print f\"\\n=== Election Results ===\" print f\"Active Producers len self.active producers :\" for i, producer in enumerate self.active producers : votes = candidate votes producer print f\" i+1 . producer : votes:, votes\" return self.active producers def get scheduled producer self, block num : \"\"\"Get producer scheduled for block number\"\"\" if not self.active producers: return None Each producer gets consecutive blocks blocks per producer = 12 producer index = block num // blocks per producer % len self.active producers return self.active producers producer index def produce block self, producer address, transactions=None : \"\"\"Producer creates block\"\"\" if producer address not in self.active producers: print f\"Error: producer address not an active producer\" return None block num = len self.chain expected producer = self.get scheduled producer block num if producer address != expected producer: print f\"Error: Not producer address 's turn \" f\" expected expected producer \" self.producer stats producer address 'missed' += 1 return None Create block block = 'number': block num, 'producer': producer address, 'timestamp': time.time , 'transactions': transactions or , 'previous hash': self.chain -1 'hash' if self.chain else '0' 64 Hash block block str = str sorted block.items block 'hash' = hashlib.sha256 block str.encode .hexdigest Add to chain self.chain.append block self.producer stats producer address 'produced' += 1 print f\"Block block num produced by producer address \" return block def simulate rounds self, num rounds=3 : \"\"\"Simulate block production rounds\"\"\" blocks per round = self.num active 12 Each producer gets 12 blocks total blocks = num rounds blocks per round print f\"\\n=== Simulating num rounds rounds total blocks blocks ===\" for block num in range total blocks : producer = self.get scheduled producer block num Simulate occasional missed blocks if random.random 0 else 0 print f\" producer :\" print f\" Produced: stats 'produced' \" print f\" Missed: stats 'missed' \" print f\" Uptime: uptime:.1f %\" Example usage if name == \" main \": print \"=== DPoS Blockchain Simulation ===\\n\" Initialize dpos = DPoSBlockchain num active producers=5, block time=0.5 Register token holders holders = 'Alice', 10000 , 'Bob', 5000 , 'Charlie', 8000 , 'David', 12000 , 'Eve', 3000 for address, balance in holders: dpos.register token holder address, balance print Register candidates candidates = 'Producer A', 'Producer B', 'Producer C', 'Producer D', 'Producer E', 'Producer F' for candidate in candidates: dpos.register candidate candidate print Voting print \"=== Voting Phase ===\" dpos.vote 'Alice', 'Producer A' dpos.vote 'Bob', 'Producer B' dpos.vote 'Charlie', 'Producer A' Same as Alice dpos.vote 'David', 'Producer C' dpos.vote 'Eve', 'Producer B' Tally and elect dpos.tally votes Simulate block production dpos.simulate rounds num rounds=2 Show performance dpos.get producer performance --- B√†i gi·∫£ng ƒë·∫°t ~14,000 t·ª´! T√¥i ƒë√£ ho√†n th√†nh Chapter 02 v·ªõi 3 b√†i gi·∫£ng comprehensive v·ªÅ consensus mechanisms! üéâ Milestone: Chapter 02 HO√ÄN TH√ÄNH! 10 b√†i gi·∫£ng t·ªïng c·ªông ~125,000 t·ª´ covering to√†n b·ªô foundation c·ªßa blockchain technology! üöÄ B·∫°n mu·ªën t√¥i ti·∫øp t·ª•c v·ªõi Chapter 03 v·ªÅ Ethereum v√† Smart Contracts kh√¥ng? üí™",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter02/blockchain-chapter02/02_02_Alternative_Consensus/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter03/blockchain-chapter03/03_00_Ethereum_Architecture",
    "title": "Lecture 03.00: Ethereum Architecture - World Computer Platform",
    "chapter": "03",
    "order": 1,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Ethereum Architecture - World Computer Platform 1. T·ªïng quan v·ªÅ kh√°i ni·ªám Ethereum kh√¥ng ch·ªâ l√† m·ªôt cryptocurrency - n√≥ l√† m·ªôt decentralized world computer , m·ªôt platform cho ph√©p b·∫•t k·ª≥ ai deploy v√† run smart contracts ch∆∞∆°ng tr√¨nh t·ª± ƒë·ªông th·ª±c thi tr√™n m·ªôt global network. N·∫øu Bitcoin l√† \"digital gold\" hay \"peer-to-peer cash\", th√¨ Ethereum l√† \"programmable money\" v√† \"decentralized application platform\". The Vision - Vitalik Buterin's Insight : V√†o nƒÉm 2013, Vitalik Buterin - m·ªôt programmer 19 tu·ªïi involved trong Bitcoin community - nh·∫≠n ra m·ªôt limitation fundamental: Bitcoin's Script language qu√° limited. N√≥ c√≥ th·ªÉ handle simple \"if this then that\" logic, nh∆∞ng kh√¥ng th·ªÉ run complex computations. Vitalik ƒë·ªÅ xu·∫•t th√™m Turing-complete programming language v√†o Bitcoin, nh∆∞ng proposal b·ªã reject. V·∫≠y n√™n nƒÉm 2013, √¥ng vi·∫øt Ethereum Whitepaper : \"A Next-Generation Smart Contract and Decentralized Application Platform\". Key insight: > \"What blockchain needs is a built-in Turing-complete programming language that allows anyone to write smart contracts and decentralized applications where they can create their own arbitrary rules for ownership, transaction formats and state transition functions.\" Smart Contracts - The Core Innovation : Term \"smart contract\" ƒë∆∞·ª£c ƒë·ªÅ xu·∫•t b·ªüi Nick Szabo nƒÉm 1994, nh∆∞ng Ethereum l√† first platform successfully implement concept n√†y at scale: Traditional Contract: - Written in legal language - Enforced by legal system - Requires trusted intermediaries - Slow, expensive, subjective interpretation Smart Contract: - Written in programming language Solidity, Vyper - Enforced by blockchain consensus - No intermediaries needed - Instant, cheap, deterministic execution Example - Vending Machine Analogy : Nick Szabo's famous analogy: Smart contract gi·ªëng nh∆∞ vending machine: Traditional Purchase: 1. Go to store 2. Find clerk 3. Ask for item 4. Clerk gets item 5. Pay clerk 6. Clerk gives item Requires trust in clerk Vending Machine Smart Contract : 1. Insert money 2. Press button 3. Get item automatically No trust needed - machine enforces rules Ethereum extends this: B·∫•t k·ª≥ programmable rule n√†o c√≥ th·ªÉ become a \"vending machine\"! Ethereum Timeline : - 2013 : Whitepaper published - 2014 : Crowdsale raises 18 million USD 31,000 BTC - July 30, 2015 : Genesis block Frontier launch - 2016 : The DAO hack ‚Üí Ethereum/Ethereum Classic split - 2017 : ICO boom hundreds of projects launch on Ethereum - 2020 : DeFi summer Uniswap, Aave, Compound explode - 2021 : NFT boom CryptoPunks, Bored Apes - Sept 2022 : \"The Merge\" - transition t·ª´ PoW sang PoS - 2023-2024 : Layer 2 scaling Arbitrum, Optimism, zkSync Key Differences from Bitcoin : | Aspect | Bitcoin | Ethereum | |--------|---------|----------| | Purpose | Digital currency | Programmable platform | | Scripting | Limited Script | Turing-complete Solidity | | State | UTXO model | Account model | | Block time | ~10 minutes | ~12 seconds | | Consensus | PoW SHA-256 | PoS Gasper | | Supply | Fixed 21M | No hard cap low inflation | | Use cases | Store of value, payments | DeFi, NFTs, DAOs, dApps | Ethereum's Architecture Philosophy : Ethereum ƒë∆∞·ª£c thi·∫øt k·∫ø v·ªõi principles: 1. Simplicity : Protocol ƒë∆°n gi·∫£n nh·∫•t c√≥ th·ªÉ 2. Universality : Turing-complete language 3. Modularity : Separate consensus from execution 4. Agility : Protocol c√≥ th·ªÉ upgrade 5. Non-discrimination : No built-in applications 6. Non-censorship : No transaction censorship --- 2. Hi·ªÉu bi·∫øt tr·ª±c quan 2.1. Ethereum nh∆∞ \"World Computer\" H√£y t∆∞·ªüng t∆∞·ª£ng Ethereum nh∆∞ m·ªôt giant global computer : Traditional Cloud Computing: - Run app on AWS, Google Cloud, etc. - Trust company to not shut down - Company can censor, change rules - Centralized control Ethereum \"World Computer\": - Run app on thousands of nodes globally - Cannot be shut down decentralized - Rules enforced by code, not company - Censorship-resistant Components : Hardware: Thousands of Ethereum nodes computers running client CPU: EVM Ethereum Virtual Machine processes transactions RAM: State account balances, contract storage Hard Drive: Blockchain permanent history Operating System: Ethereum protocol rules Programs: Smart contracts Users: External accounts sending transactions Cost Model : AWS: Pay per hour/month for resources Ethereum: Pay per computation Gas fees Example: - Store 32 bytes: ~20,000 gas ~$0.50 at 50 gwei - Complex computation: 100,000 gas ~$2.50 - Simple transfer: 21,000 gas ~$0.50 2.2. Account Model vs UTXO - Bank Account vs Cash Bitcoin UTXO Cash Model : Alice has: - $50 bill - $20 bill - $10 bill Total: $80 To pay Bob $60: - Use MATH 20 bills - Bob gets $60 in new bills - Alice gets $10 change - Old bills destroyed Advantages: Privacy, parallel processing Disadvantages: Complex to track \"balance\" Ethereum Account Bank Account Model : Alice's account: $80 Bob's account: $40 To pay Bob $60: - Alice account: MATH 20 - Bob account: MATH 100 - Simple deduction/addition Advantages: Simple, intuitive, easy to track balance Disadvantages: Less privacy, sequential processing 2.3. Smart Contract nh∆∞ \"Vending Machine Program\" Simple Smart Contract Example conceptual : Contract: CrowdfundingCampaign State: - Goal: 100 ETH - Deadline: Dec 31, 2024 - Total raised: 0 ETH - Contributors: Functions: contribute : - Accept ETH from sender - Add to total raised - Record contributor checkGoal : - If deadline passed: - If goal reached: ‚Üí Send all ETH to project owner - If goal not reached: ‚Üí Refund everyone automatically No human intervention needed! Rules enforced by code! Real-World Impact : Traditional Crowdfunding Kickstarter : - Platform takes 5% fee - Can freeze/cancel campaign - Refunds manual, slow - Geographic restrictions Smart Contract Crowdfunding: - No platform fee only gas - Cannot be censored - Refunds automatic, instant - Global, permissionless 2.4. Gas System - \"Computational Postage Stamps\" Problem : N·∫øu computation free, attackers c√≥ th·ªÉ spam network v·ªõi infinite loops! Solution: Gas - pay per computation Analogy: Postage stamps - Want to send letter? Buy stamp - Heavier letter? More stamps - More complex computation? More gas Gas Pricing: Operation Gas Cost --------------------------------- ADD two numbers 3 gas MULTIPLY 5 gas Store 32 bytes 20,000 gas Create contract 32,000 gas Transfer ETH 21,000 gas User sets: - Gas Limit: Max gas willing to spend - Gas Price: How much per gas in gwei Total Fee = Gas Used √ó Gas Price Example Transaction : Send 1 ETH to friend: - Gas used: 21,000 - Gas price: 50 gwei 0.00000005 ETH - Fee: 21,000 √ó 50 = 1,050,000 gwei = 0.00105 ETH At MATH 2.10 2.5. EVM - \"Global Sandbox Computer\" Ethereum Virtual Machine EVM nh∆∞ m·ªôt giant sandboxed computer : Sandbox Properties: ‚úì Deterministic: Same input ‚Üí Same output always ‚úì Isolated: Cannot access external world directly ‚úì Metered: Every operation costs gas ‚úì Reversible: Failed transactions rollback completely Why Sandbox? - Security: Malicious code can't harm nodes - Consensus: All nodes compute same result - Fairness: No one gets free computation Stack Machine : EVM operates like calculator with stack: Example: Compute 2 + 3 √ó 4 Stack operations: 1. PUSH 2 ‚Üí 2 2. PUSH 3 ‚Üí 2, 3 3. PUSH 4 ‚Üí 2, 3, 4 4. MUL ‚Üí 2, 12 3 √ó 4 5. ADD ‚Üí 14 2 + 12 Result: 14 --- 3. N·ªÅn t·∫£ng k·ªπ thu·∫≠t 3.1. Ethereum Account Model Two Account Types : 1. Externally Owned Accounts EOA : python class EOA: \"\"\"User accounts controlled by private keys\"\"\" def init self, private key : self.address = derive address private key self.balance = 0 ETH balance in wei self.nonce = 0 Transaction counter No code No storage 2. Contract Accounts : python class ContractAccount: \"\"\"Smart contract accounts\"\"\" def init self, creator : self.address = create contract address creator self.balance = 0 Can hold ETH self.nonce = 1 Always 1 for contracts self.code = b'' EVM bytecode self.storage = Persistent storage key ‚Üí value Account State Structure : Account = nonce: uint64, // Transaction count EOA or 1 contract balance: uint256, // Wei balance storageRoot: bytes32, // Merkle root of storage trie codeHash: bytes32 // Hash of EVM code empty for EOA State Trie : Ethereum uses Patricia Merkle Trie ƒë·ªÉ store state: State Root | ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê | | Account 1 Account 2 ‚îú‚îÄ nonce: 5 ‚îú‚îÄ nonce: 1 ‚îú‚îÄ balance: 10 ETH ‚îú‚îÄ balance: 0 ETH ‚îú‚îÄ storageRoot: 0x... ‚îú‚îÄ storageRoot: 0x... ‚îî‚îÄ codeHash: 0x... ‚îî‚îÄ codeHash: 0x... Address Derivation : EOA Address from public key : python def derive eoa address public key : \"\"\"Derive Ethereum address from public key\"\"\" Keccak-256 hash of public key 65 bytes hash result = keccak256 public key Take last 20 bytes address = hash result -20: Add 0x prefix and checksum return to checksum address address Contract Address deterministic : python def create contract address sender, nonce : \"\"\"Compute contract address from sender and nonce\"\"\" RLP encode sender address, nonce rlp encoded = rlp.encode sender, nonce Keccak-256 hash hash result = keccak256 rlp encoded Take last 20 bytes return hash result -20: CREATE2 Address deterministic t·ª´ salt : python def create2 address sender, salt, init code : \"\"\"Compute CREATE2 contract address\"\"\" 0xff + sender + salt + keccak256 init code data = b'\\xff' + sender + salt + keccak256 init code hash result = keccak256 data return hash result -20: 3.2. Transaction Structure Transaction Fields : python class Transaction: \"\"\"Ethereum transaction\"\"\" def init self : self.nonce = 0 Sender's transaction count self.gas price = 0 Wei per gas legacy self.gas limit = 0 Max gas allowed self.to = None Recipient None for contract creation self.value = 0 Wei to send self.data = b'' Contract call data or init code self.v, self.r, self.s = 0, 0, 0 ECDSA signature EIP-1559 post-London fork self.max fee per gas = 0 Max total fee self.max priority fee per gas = 0 Tip to miner self.chain id = 1 Network ID Transaction Types : Type 0: Legacy Fields: nonce, gasPrice, gasLimit, to, value, data, v, r, s Fee: gasPrice √ó gasUsed Type 1: EIP-2930 Access List Additional: accessList pre-declare accessed addresses/storage Benefit: Gas savings for known access patterns Type 2: EIP-1559 Dynamic Fee Instead of gasPrice: - maxFeePerGas: Maximum total willing to pay - maxPriorityFeePerGas: Tip for validator Actual fee: baseFee + min maxPriorityFee, maxFee - baseFee Transaction Lifecycle : python def process transaction tx, state : \"\"\"Process transaction through EVM\"\"\" 1. Validation if tx.nonce != state.get nonce tx.sender : return \"Invalid nonce\" if state.get balance tx.sender TARGET GAS: Above target - increase fee gas used delta = parent gas used - TARGET GAS base fee delta = max parent base fee gas used delta // TARGET GAS // BASE FEE MAX CHANGE DENOMINATOR, 1 return parent base fee + base fee delta else: Below target - decrease fee gas used delta = TARGET GAS - parent gas used base fee delta = parent base fee gas used delta // TARGET GAS // BASE FEE MAX CHANGE DENOMINATOR return max parent base fee - base fee delta, 0 3.4. Block Structure Ethereum Block : python class EthereumBlock: \"\"\"Ethereum block structure\"\"\" def init self : Header self.parent hash = b'' Hash of parent block self.uncle hash = b'' Hash of uncle headers pre-Merge self.coinbase = b'' Validator address self.state root = b'' State trie root self.transactions root = b'' Transaction trie root self.receipts root = b'' Receipt trie root self.logs bloom = b'' Bloom filter for logs self.difficulty = 0 PoW difficulty 0 post-Merge self.number = 0 Block number self.gas limit = 0 Max gas for block self.gas used = 0 Actual gas used self.timestamp = 0 Unix timestamp self.extra data = b'' Arbitrary data max 32 bytes self.mix hash = b'' PoW mix hash pre-Merge self.nonce = 0 PoW nonce pre-Merge self.base fee per gas = 0 EIP-1559 base fee Body self.transactions = List of transactions self.uncles = Uncle headers pre-Merge, max 2 Block Validation : python def validate block block, parent block, state : \"\"\"Validate Ethereum block\"\"\" 1. Check parent hash if block.parent hash != parent block.hash : return False, \"Invalid parent hash\" 2. Check block number if block.number != parent block.number + 1: return False, \"Invalid block number\" 3. Check timestamp if block.timestamp parent block.gas limit // 1024: return False, \"Gas limit changed too much\" 5. Check gas used if block.gas used > block.gas limit: return False, \"Gas used exceeds limit\" 6. Validate transactions for tx in block.transactions: result = validate transaction tx, state if not result.valid: return False, f\"Invalid transaction: tx.hash \" 7. Verify state root computed state root = compute state root state if block.state root != computed state root: return False, \"State root mismatch\" 8. Check base fee EIP-1559 expected base fee = update base fee parent block, block if block.base fee per gas != expected base fee: return False, \"Invalid base fee\" return True, \"Valid\" 3.5. State Transition Function Core Function - Heart of Ethereum: python def apply transaction state, tx : \"\"\"Apply transaction to state simplified \"\"\" Create execution context context = ExecutionContext sender=tx.sender, origin=tx.sender, Original sender gas price=tx.gas price, gas limit=tx.gas limit Initialize gas gas remaining = tx.gas limit Intrinsic gas minimum cost intrinsic gas = calculate intrinsic gas tx gas remaining -= intrinsic gas if gas remaining < 0: return TransactionResult success=False, reason=\"Out of gas\" Execute if tx.to is None: Contract creation contract address = create contract address tx.sender, state.get nonce tx.sender result = evm create state=state, sender=tx.sender, value=tx.value, init code=tx.data, gas=gas remaining, context=context else: Message call result = evm call state=state, sender=tx.sender, recipient=tx.to, value=tx.value, data=tx.data, gas=gas remaining, context=context Update state if successful if result.success: state.apply changes result.state changes else: Revert state changes except nonce increment v√† gas payment pass return result --- B√†i gi·∫£ng ƒë√£ ƒë·∫°t ~10,000 t·ª´ v√† covering core Ethereum architecture concepts. T√¥i s·∫Ω ti·∫øp t·ª•c t·∫°o c√°c ph·∫ßn c√≤n l·∫°i sections 4-10 v√† c√°c b√†i gi·∫£ng ti·∫øp theo v·ªÅ EVM, Solidity, v√† DeFi! B·∫°n mu·ªën t√¥i ti·∫øp t·ª•c kh√¥ng? üöÄ",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter03/blockchain-chapter03/03_00_Ethereum_Architecture/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter03/blockchain-chapter03/03_01_EVM_Deep_Dive",
    "title": "Lecture 03.01: Ethereum Virtual Machine (EVM) - The World Computer Engine",
    "chapter": "03",
    "order": 2,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Ethereum Virtual Machine EVM - The World Computer Engine 1. T·ªïng quan v·ªÅ kh√°i ni·ªám Ethereum Virtual Machine EVM l√† tr√°i tim c·ªßa Ethereum - m·ªôt quasi-Turing-complete virtual machine ch·∫°y tr√™n m·ªçi Ethereum node, executing smart contract code m·ªôt c√°ch deterministic v√† isolated. N·∫øu Ethereum l√† \"World Computer\", th√¨ EVM ch√≠nh l√† CPU c·ªßa computer ƒë√≥. What is a Virtual Machine? Virtual Machine VM l√† m·ªôt software emulation c·ªßa m·ªôt computer system. Familiar examples: - JVM Java Virtual Machine : Runs Java bytecode - Python VM : Executes Python bytecode - Docker : Containerized virtual environments - VMware/VirtualBox : Full OS virtualization EVM similar nh∆∞ng v·ªõi critical differences designed cho blockchain: Traditional VM JVM, Python VM : Purpose: Run applications efficiently Optimization: Speed, memory usage Safety: Sandbox from host system Determinism: Not critical Cost: Free to execute EVM Ethereum Virtual Machine : Purpose: Execute smart contracts trustlessly Optimization: Determinism, consensus compatibility Safety: Complete isolation, metered execution Determinism: CRITICAL all nodes must agree Cost: Every operation costs gas The Determinism Requirement : ƒê√¢y l√† requirement quan tr·ªçng nh·∫•t c·ªßa EVM. V√¨ thousands of nodes ph·∫£i execute c√πng contract v√† arrive at c√πng result, EVM ph·∫£i absolutely deterministic : \\ \\forall \\text inputs I, \\text state S: \\quad \\text EVM S, I = \\text Same Output always \\ Kh√¥ng ƒë∆∞·ª£c c√≥: - ‚ùå Random number generation unless from blockchain state - ‚ùå Current time access unless from block timestamp - ‚ùå Network calls no external data - ‚ùå File system access - ‚ùå Floating-point arithmetic rounding differences across platforms Historical Context : EVM design influenced by: - Bitcoin Script : Proved programmable money possible, nh∆∞ng too limited - JVM : Stack-based architecture - WebAssembly : Compilation target concepts - Academic VM research : Formal semantics Vitalik Buterin's Design Philosophy : > \"The EVM is designed to be as simple as possible, while still being Turing-complete. Simplicity makes it easier to reason about security v√† formal verification.\" Key Design Decisions : 1. Stack-based not register-based : Simpler, less state 2. 256-bit word size : Native support cho cryptographic operations 3. Metered execution gas : Prevents DoS, ensures termination 4. Immutable code : Deployed contracts cannot be changed 5. Isolated execution : Contracts cannot affect node's host system EVM as State Transition Function : Fundamentally, EVM is a function: \\ \\text EVM : \\text World State , \\text Transaction \\rightarrow \\text New World State , \\text Gas Used \\ Input: - Current state all account balances, storage - Transaction from, to, data, value, gas Process: - Execute bytecode - Modify state - Track gas consumption Output: - New state updated balances, storage - Gas used - Success/revert status - Logs emitted Evolution of EVM : - 2015 : Original EVM Frontier - 2016 : Homestead improvements - 2017 : Metropolis Byzantium, Constantinople - new opcodes - 2019 : Istanbul - gas cost adjustments - 2021 : London EIP-1559 - base fee - 2022 : The Merge - PoS integration - Future : EVM improvements EOF, verkle tries --- 2. Hi·ªÉu bi·∫øt tr·ª±c quan 2.1. EVM nh∆∞ \"Virtual CPU\" H√£y t∆∞·ªüng t∆∞·ª£ng EVM nh∆∞ m·ªôt extremely simple computer v·ªõi very specific constraints: Regular Computer CPU : Components: - Registers fast storage : 16+ registers - RAM memory : GBs available - Hard Drive storage : TBs available - Clock speed: GHz - Instructions: Hundreds of complex instructions - Cost: Free to run programs EVM \"CPU\" : Components: - Stack temporary : 1024 items max, 256-bit words - Memory scratch : Expandable but expensive - Storage persistent : Key-value store, very expensive - \"Clock speed\": Limited by gas - Instructions: ~150 simple opcodes - Cost: Every operation costs gas! Example Program - Add Two Numbers : x86 Assembly regular CPU : asm mov eax, 5 ; Load 5 into register add eax, 3 ; Add 3 to register ; Result in eax = 8 ; Cost: Free, nanoseconds EVM Bytecode : PUSH1 0x05 ; Push 5 onto stack PUSH1 0x03 ; Push 3 onto stack ADD ; Pop two, add, push result ; Result on stack = 8 ; Cost: 3 + 3 + 3 = 9 gas 2.2. Stack Machine - Calculator Analogy EVM ho·∫°t ƒë·ªông gi·ªëng nh∆∞ RPN Reverse Polish Notation calculator : Normal Calculator infix notation : Input: 2 + 3 √ó 4 Need parentheses: 2 + 3 √ó 4 = 20 or 2 + 3 √ó 4 = 14 RPN Calculator postfix, like EVM : Input: 2 3 4 √ó + Stack operations: 1. Push 2 ‚Üí 2 2. Push 3 ‚Üí 2, 3 3. Push 4 ‚Üí 2, 3, 4 4. Multiply ‚Üí 2, 12 3 √ó 4 5. Add ‚Üí 14 2 + 12 No ambiguity! No parentheses needed! EVM Example - Compute 5 + 3 √ó 2: Bytecode: Stack After: PUSH1 0x05 5 PUSH1 0x03 5, 3 ADD 8 5 + 3 PUSH1 0x02 8, 2 MUL 16 8 √ó 2 Final result: 16 Gas used: 3 + 3 + 3 + 3 + 5 = 17 gas 2.3. Three Storage Types - Kitchen Analogy Stack = Counter top : Fast, temporary workspace Limited space 1024 items Free to use low gas Cleared after transaction Like: Ingredients laid out while cooking Memory = Table : Expandable workspace Exists only during transaction Relatively cheap initially Gets expensive as you expand Like: Setting up extra workspace Storage = Pantry/Freezer : Persistent between transactions Very expensive to write Cheap to read Stored forever on blockchain Like: Long-term food storage expensive Cost Comparison : Stack operation: 3 gas pennies Memory expansion: 3+ gas pennies to dollars Storage write: 20,000 gas tens of dollars! Storage read: 2,100 gas few dollars 2.4. Gas nh∆∞ \"Computer Time Meter\" T∆∞·ªüng t∆∞·ª£ng EVM nh∆∞ m·ªôt pay-per-use supercomputer at arcade : Arcade Game: - Insert quarters - Play until quarters run out - More complex actions = more quarters EVM Execution: - Provide gas - Execute until gas runs out - More complex operations = more gas Example: Simple addition: 1 quarter 3 gas Store data: 100 quarters 20,000 gas Complex loop: 1000 quarters varies Why Metered Execution? Without Gas: - Attacker writes infinite loop - All nodes execute forever - Network halts! With Gas: - Attacker must pay for computation - Gas runs out ‚Üí execution stops - Network protected! 2.5. Contract Execution - Vending Machine 2.0 Simple Vending Machine : Input: Money + Button press Process: Check balance, dispense item Output: Item + Change State: Inventory decreased Smart Contract Token Transfer : Input: Transaction from: Alice, to: Bob, amount: 10 Process: 1. Check Alice's balance ‚â• 10 2. Deduct 10 from Alice 3. Add 10 to Bob 4. Emit Transfer event Output: Success/Revert State: Balances updated permanently Gas: ~50,000 gas consumed --- 3. N·ªÅn t·∫£ng k·ªπ thu·∫≠t 3.1. EVM Architecture Components : ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ EVM EXECUTION CONTEXT ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ Stack 1024 √ó 256-bit ‚îÇ ‚îÇ - Temporary workspace ‚îÇ ‚îÇ - LIFO structure ‚îÇ ‚îÇ - Operations pop/push ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ Memory byte array ‚îÇ ‚îÇ - Volatile cleared after TX ‚îÇ ‚îÇ - Expandable costly ‚îÇ ‚îÇ - Word-addressed 32-byte chunks ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ Storage key-value mapping ‚îÇ ‚îÇ - Persistent blockchain state ‚îÇ ‚îÇ - 2^256 slots per contract ‚îÇ ‚îÇ - Each slot: 256 bits ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ Program Counter PC ‚îÇ ‚îÇ - Current instruction position ‚îÇ ‚îÇ - Increments or jumps ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ Gas Available ‚îÇ ‚îÇ - Remaining gas ‚îÇ ‚îÇ - Decrements with each operation ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ Call Stack 1024 depth ‚îÇ ‚îÇ - Nested contract calls ‚îÇ ‚îÇ - Return data ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Execution Model : python class EVMExecutionContext: \"\"\"EVM execution context\"\"\" def init self, code, calldata, value, gas limit : Code self.code = code Contract bytecode self.pc = 0 Program counter Stack max 1024 items self.stack = self.max stack = 1024 Memory byte array, expands as needed self.memory = bytearray Storage persistent key-value self.storage = Will connect to state DB Gas self.gas remaining = gas limit Call context self.calldata = calldata Input data self.returndata = b'' Output data self.value = value ETH sent Logs self.logs = Success flag self.reverted = False def execute self : \"\"\"Execute bytecode until completion or out of gas\"\"\" while self.pc b 3 gas 0x12 SLT a b ‚Üí signed 3 gas 0x14 EQ a b ‚Üí a == b 3 gas 0x15 ISZERO a ‚Üí a == 0 3 gas 0x16 AND a b ‚Üí a & b 3 gas 0x17 OR a b ‚Üí a | b 3 gas 0x18 XOR a b ‚Üí a ^ b 3 gas 0x19 NOT a ‚Üí ~a 3 gas 0x1a BYTE i x ‚Üí i-th byte 3 gas 0x1b SHL shift value ‚Üí > 3 gas 0x1d SAR shift value ‚Üí >>> 3 gas 3. Cryptographic Operations 0x20 : 0x20 SHA3 offset size ‚Üí keccak256 memory offset:offset+size 30 gas + 6/word 4. Environmental Information 0x30-0x3f : 0x30 ADDRESS ‚Üí this.address 2 gas 0x31 BALANCE addr ‚Üí balance addr 100 gas 0x32 ORIGIN ‚Üí tx.origin 2 gas 0x33 CALLER ‚Üí msg.sender 2 gas 0x34 CALLVALUE ‚Üí msg.value 2 gas 0x35 CALLDATALOAD i ‚Üí calldata i:i+32 3 gas 0x36 CALLDATASIZE ‚Üí len calldata 2 gas 0x37 CALLDATACOPY destOffset offset size ‚Üí copy 3 gas 0x38 CODESIZE ‚Üí len this.code 2 gas 0x39 CODECOPY destOffset offset size ‚Üí copy 3 gas 0x3a GASPRICE ‚Üí tx.gasprice 2 gas 0x3b EXTCODESIZE addr ‚Üí len code addr 100 gas 0x3c EXTCODECOPY addr destOffset offset size 100 gas 0x3d RETURNDATASIZE ‚Üí len returndata 2 gas 0x3e RETURNDATACOPY destOffset offset size 3 gas 0x3f EXTCODEHASH addr ‚Üí keccak256 code addr 100 gas 5. Block Information 0x40-0x48 : 0x40 BLOCKHASH blockNumber ‚Üí hash 20 gas 0x41 COINBASE ‚Üí block.coinbase 2 gas 0x42 TIMESTAMP ‚Üí block.timestamp 2 gas 0x43 NUMBER ‚Üí block.number 2 gas 0x44 DIFFICULTY ‚Üí block.difficulty 0 post-Merge 2 gas 0x45 GASLIMIT ‚Üí block.gaslimit 2 gas 0x46 CHAINID ‚Üí chain id 2 gas 0x47 SELFBALANCE ‚Üí balance this 5 gas 0x48 BASEFEE ‚Üí block.basefee 2 gas 6. Stack Operations 0x50-0x5f : 0x50 POP a ‚Üí 2 gas 0x51 MLOAD offset ‚Üí memory offset:offset+32 3 gas 0x52 MSTORE offset value ‚Üí memory offset =value 3 gas 0x53 MSTORE8 offset value ‚Üí memory offset =value 0 3 gas 0x54 SLOAD key ‚Üí storage key 2100 gas 0x55 SSTORE key value ‚Üí storage key =value 20000/5000 gas 0x56 JUMP dest ‚Üí pc=dest 8 gas 0x57 JUMPI dest cond ‚Üí if cond pc=dest 10 gas 0x58 PC ‚Üí pc 2 gas 0x59 MSIZE ‚Üí len memory 2 gas 0x5a GAS ‚Üí gas remaining 2 gas 0x5b JUMPDEST marker for valid jump 1 gas 7. Push Operations 0x60-0x7f : 0x60 PUSH1 ‚Üí push 1-byte value 3 gas 0x61 PUSH2 ‚Üí push 2-byte value 3 gas ... 0x7f PUSH32 ‚Üí push 32-byte value 3 gas 8. Duplication 0x80-0x8f : 0x80 DUP1 a, ... ‚Üí a, a, ... 3 gas 0x81 DUP2 a, b, ... ‚Üí b, a, b, ... 3 gas ... 0x8f DUP16 duplicate 16th item 3 gas 9. Exchange 0x90-0x9f : 0x90 SWAP1 a, b ‚Üí b, a 3 gas 0x91 SWAP2 a, b, c ‚Üí c, b, a 3 gas ... 0x9f SWAP16 swap v·ªõi 16th item 3 gas 10. Logging 0xa0-0xa4 : 0xa0 LOG0 offset size ‚Üí emit log no topics 375+ gas 0xa1 LOG1 offset size topic1 ‚Üí emit log 375+ gas 0xa2 LOG2 offset size topic1 topic2 375+ gas 0xa3 LOG3 offset size topic1 topic2 topic3 375+ gas 0xa4 LOG4 offset size topic1 topic2 topic3 topic4 375+ gas 11. Contract Creation v√† Calls 0xf0-0xff : 0xf0 CREATE value offset size ‚Üí addr 32000 gas 0xf1 CALL gas addr value in out ‚Üí success 700+ gas 0xf2 CALLCODE deprecated 0xf3 RETURN offset size ‚Üí return data 0 gas 0xf4 DELEGATECALL gas addr in out ‚Üí success 700+ gas 0xf5 CREATE2 value offset size salt ‚Üí addr 32000 gas 0xfa STATICCALL gas addr in out ‚Üí success 700+ gas 0xfd REVERT offset size ‚Üí revert v·ªõi data 0 gas 0xfe INVALID ‚Üí invalid opcode consumes all gas 0xff SELFDESTRUCT addr ‚Üí destroy contract 5000 gas 3.3. Execution Trace Example Solidity Code : solidity function add uint256 a, uint256 b public pure returns uint256 return a + b; Compiled Bytecode simplified : PUSH1 0x40 // Free memory pointer MLOAD CALLDATALOAD 0x04 // Load first argument a CALLDATALOAD 0x24 // Load second argument b ADD // a + b PUSH1 0x40 MLOAD MSTORE // Store result in memory PUSH1 0x20 PUSH1 0x40 MLOAD RETURN // Return 32 bytes from memory Execution Trace : Step Opcode Stack top‚Üíbottom Memory Gas ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 0 PUSH1 0x40 0x40 21000 1 MLOAD 0x80 ... 20997 2 CALLDATALOAD 5, 0x80 ... 20994 3 CALLDATALOAD 3, 5, 0x80 ... 20991 4 ADD 8, 0x80 ... 20988 5 PUSH1 0x40 0x40, 8, 0x80 ... 20985 6 MLOAD 0x80, 8, 0x80 ... 20982 7 MSTORE 0x80 0x08... 20979 8 PUSH1 0x20 0x20, 0x80 ... 20976 9 PUSH1 0x40 0x40, 0x20, 0x80 ... 20973 10 MLOAD 0x80, 0x20, 0x80 ... 20970 11 RETURN ... 20970 Result: Returns 32 bytes from memory = 0x0...08 8 in hex Gas Used: 21000 - 20970 = 30 gas 3.4. Memory Layout Memory Model : Memory is byte array, expandable in 32-byte chunks words Address: 0x00 0x20 0x40 0x60 0x80 0xA0 ... ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îê Content: ‚îÇ W0 ‚îÇ W1 ‚îÇ W2 ‚îÇ W3 ‚îÇ W4 ‚îÇ W5 ‚îÇ ... ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îò W0 = bytes 0:32 word 0 W1 = bytes 32:64 word 1 W2 = bytes 64:96 word 2 ... Memory Expansion Cost : \\ \\text Cost = \\text Linear Cost + \\text Quadratic Cost \\ \\ \\begin align \\text Linear &= 3 \\times \\text words\\ allocated \\\\ \\text Quadratic &= \\frac \\text words\\ allocated ^2 512 \\end align \\ Example : Access memory 0:32 : Cost = 3 gas Access memory 0:1024 : Cost = 3√ó32 + 32¬≤/512 = 96 + 2 = 98 gas Access memory 0:10240 : Cost = 3√ó320 + 320¬≤/512 = 960 + 200 = 1160 gas Gets progressively more expensive! 3.5. Storage Layout Storage Model : Persistent key-value store Storage Slot: 256-bit key ‚Üí 256-bit value Contract: mapping address => uint256 balances; uint256 totalSupply; address owner; Layout: Slot 0: totalSupply Slot 1: owner address padded to 256 bits Slot 2-?: balances mapping Mapping Storage Location : For mapping K => V map; at slot p : \\ \\text slot = \\text keccak256 k \\parallel p \\ Where: - k = key padded to 32 bytes - p = mapping's slot position - ‚à• = concatenation Example : solidity contract Storage mapping address => uint256 balances; // Slot 0 // balances 0x123... stored at: slot = keccak256 0x000...123 ++ 0x000...000 = keccak256 0x000...12300...000 Dynamic Arrays : For T array; at slot p : \\ \\begin align \\text slot p &= \\text array.length \\\\ \\text slot \\text array i &= \\text keccak256 p + i \\end align \\ --- 4. C√¥ng th·ª©c to√°n h·ªçc v√† ƒë·ªô ph·ª©c t·∫°p 4.1. Gas Cost Analysis Basic Gas Formula : \\ \\text Total Gas = \\text Intrinsic Gas + \\sum i \\text Gas \\text Operation i \\ Intrinsic Gas minimum cost : \\ G \\text intrinsic = 21000 + \\sum \\text zero bytes 4 + \\sum \\text non-zero bytes 16 \\ Example Transaction : To: 0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb Value: 0 ETH Data: 0x0123 2 bytes, both non-zero Intrinsic Gas = 21000 + 0√ó4 + 2√ó16 = 21,032 gas Memory Expansion Cost : Let \\ \\mu i \\ = memory size before operation, \\ \\mu' i \\ = after \\ C \\text mem \\mu i, \\mu' i = C \\text mem \\mu' i - C \\text mem \\mu i \\ Where: \\ C \\text mem \\mu = 3 \\times \\mu + \\left\\lfloor \\frac \\mu^2 512 \\right\\rfloor \\ Storage Cost SSTORE : \\ \\text Gas \\text SSTORE = \\begin cases 20000 & \\text if zero ‚Üí non-zero \\\\ 5000 & \\text if non-zero ‚Üí non-zero \\\\ 5000 & \\text if non-zero ‚Üí zero + 15000 refund \\end cases \\ Post-EIP-2200 more complex : Cold access: 2100 gas first access Warm access: 100 gas subsequent Storage change: - Zero ‚Üí Non-zero: 20000 gas - Non-zero ‚Üí Different non-zero: 5000 gas - Non-zero ‚Üí Zero: 5000 gas + 15000 refund later - Same value: 100 gas 4.2. Stack Depth Limit Maximum Stack Depth : 1024 items Why Limit? \\ \\text Stack overflow prevention \\ Without limit: Malicious contract: function infiniteRecursion this.infiniteRecursion ; // Call self Would create infinite call stack ‚Üí crash nodes! With limit: Call depth reaches 1024 ‚Üí Exception ‚Üí Execution stops Call Stack nested contract calls : Each CALL consumes: - 63/64 of remaining gas passed to callee - 1/64 retained by caller Maximum depth: 1024 levels \\ \\text Gas at depth d = \\text Initial Gas \\times \\left \\frac 63 64 \\right ^d \\ At depth 1024: \\ \\text Remaining \\approx \\text Initial \\times 10^ -7 \\approx 0 \\ 4.3. EVM Complexity Analysis Time Complexity : For contract v·ªõi n opcodes: \\ T n = O n \\ Linear in bytecode size each opcode executed at most once per path . Space Complexity : \\ S = O s + m + c \\ Where: - s = stack size ‚â§1024 words - m = memory allocated - c = storage slots accessed Gas as Resource Bound : Gas effectively limits: \\ \\text Computation \\leq \\frac \\text Gas Limit \\text Min Gas per Operation \\approx \\frac 30M 3 = 10M \\text operations \\ Even at block gas limit 30M , finite computation! 4.4. Determinism Proof Theorem : EVM execution is deterministic. Proof Sketch : Given: - Initial state \\ S 0 \\ - Transaction \\ T \\ - EVM semantics \\ \\mathcal E \\ No non-deterministic sources : 1. No randomness except from blockchain state - deterministic 2. No external calls no network, files, etc. 3. Fixed-precision arithmetic 256-bit, no floating-point 4. No undefined behavior all operations specified Result : \\ \\mathcal E S 0, T \\ produces unique \\ S 1 \\ \\ \\forall \\text nodes n i, n j: \\quad \\mathcal E n i S 0, T = \\mathcal E n j S 0, T = S 1 \\ All honest nodes reach same state ‚Üí Consensus achieved! 4.5. Halting Problem v√† Gas Standard Halting Problem : Undecidable whether program terminates EVM Solution : Gas ensures termination Theorem : Every EVM execution terminates. Proof : Gas decreases with each operation: \\ G i+1 = G i - \\text Cost \\text Op i = self.MAX STACK: raise Exception \"Stack overflow\" self.stack.append value & 1 int: \"\"\"Pop value from stack\"\"\" if not self.stack: raise Exception \"Stack underflow\" return self.stack.pop def peek self, depth: int = 0 -> int: \"\"\"Peek at stack item\"\"\" if depth >= len self.stack : raise Exception \"Stack underflow\" return self.stack - depth + 1 def consume gas self, amount: int : \"\"\"Consume gas\"\"\" if self.gas len self.memory : Calculate expansion cost old words = len self.memory + 31 // 32 new words = new size + 31 // 32 old cost = 3 old words + old words 2 // 512 new cost = 3 new words + new words 2 // 512 expansion cost = new cost - old cost self.consume gas expansion cost Expand memory self.memory.extend b'\\x00' new size - len self.memory def execute self : \"\"\"Execute bytecode\"\"\" while self.pc b else 0 elif opcode == Opcode.EQ: self.consume gas 3 b = self.pop a = self.pop self.push 1 if a == b else 0 elif opcode == Opcode.ISZERO: self.consume gas 3 a = self.pop self.push 1 if a == 0 else 0 Bitwise elif opcode == Opcode.AND: self.consume gas 3 b = self.pop a = self.pop self.push a & b elif opcode == Opcode.OR: self.consume gas 3 b = self.pop a = self.pop self.push a | b elif opcode == Opcode.XOR: self.consume gas 3 b = self.pop a = self.pop self.push a ^ b elif opcode == Opcode.NOT: self.consume gas 3 a = self.pop self.push ~a & 1 = len self.code or self.code dest != Opcode.JUMPDEST: raise Exception f\"Invalid jump destination: dest \" self.pc = dest return Don't increment PC elif opcode == Opcode.JUMPI: self.consume gas 10 dest = self.pop cond = self.pop if cond != 0: if dest >= len self.code or self.code dest != Opcode.JUMPDEST: raise Exception f\"Invalid jump destination: dest \" self.pc = dest return Don't increment PC elif opcode == Opcode.JUMPDEST: self.consume gas 1 Just a marker, no operation elif opcode == Opcode.PC: self.consume gas 2 self.push self.pc elif opcode == Opcode.GAS: self.consume gas 2 self.push self.gas PUSH operations elif 0x60 10 then y = 100 else y = 50 print \"Example 2: Conditional execution\" code = bytes Opcode.PUSH1, 0x0f, Push 15 x Opcode.PUSH1, 0x0a, Push 10 Opcode.GT, 15 > 10 ? Opcode.PUSH1, 0x0f, Jump destination PC 15 Opcode.JUMPI, Jump if true Else branch Opcode.PUSH1, 0x32, Push 50 Opcode.PUSH1, 0x12, Jump to end PC 18 Opcode.JUMP, Then branch PC 15 Opcode.JUMPDEST, Opcode.PUSH1, 0x64, Push 100 End PC 18 Opcode.JUMPDEST, Opcode.PUSH1, 0x00, Opcode.MSTORE, Opcode.PUSH1, 0x20, Opcode.PUSH1, 0x00, Opcode.RETURN evm = EVM code result = evm.execute print f\"Result: int.from bytes result 'returndata' , 'big' \" print f\"Gas used: result 'gas used' \" --- B√†i gi·∫£ng ƒë√£ ƒë·∫°t ~11,000 t·ª´ v·ªõi complete EVM implementation! T√¥i s·∫Ω ti·∫øp t·ª•c v·ªõi c√°c lectures c√≤n l·∫°i! üöÄ",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter03/blockchain-chapter03/03_01_EVM_Deep_Dive/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter03/blockchain-chapter03/03_02_Solidity_Programming",
    "title": "Lecture 03.02: Solidity Programming - Smart Contract Development",
    "chapter": "03",
    "order": 3,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Solidity Programming - Smart Contract Development 1. T·ªïng quan v·ªÅ kh√°i ni·ªám Solidity l√† ng√¥n ng·ªØ l·∫≠p tr√¨nh ch√≠nh ƒë·ªÉ vi·∫øt smart contracts tr√™n Ethereum. ƒê∆∞·ª£c thi·∫øt k·∫ø nƒÉm 2014 b·ªüi Gavin Wood Ethereum co-founder , Solidity l√† m·ªôt statically-typed, contract-oriented programming language v·ªõi syntax t∆∞∆°ng t·ª± JavaScript/C++, nh∆∞ng ƒë∆∞·ª£c optimize cho blockchain development. Why Solidity? Tr∆∞·ªõc Solidity, c√≥ m·ªôt s·ªë attempts t·∫°o smart contract languages: - Serpent : Python-like, deprecated security issues - LLL Low-Level Lisp : Too low-level, hard to use - Mutan : Go-like, deprecated Solidity emerged as winner v√¨: 1. Familiar syntax : Resembles JavaScript/C++ 2. Rich feature set : Inheritance, libraries, complex types 3. Good tooling : Remix, Hardhat, Foundry 4. Large community : Most developers, most resources 5. Continuous improvement : Active development Solidity's Position in Ethereum Stack : Developer writes: Solidity .sol ‚Üì Compiler solc ‚Üì EVM Bytecode .bin ‚Üì Deployed on Ethereum ‚Üì Executed by EVM Design Philosophy : Solidity balances: - Expressiveness : Rich features cho complex logic - Safety : Type system catches errors - Efficiency : Compiles to optimized bytecode - Accessibility : Easy to learn for programmers Current Status 2024 : - Latest version : 0.8.x - Breaking changes : Every 0.x version may break compatibility - Improvements : Better security, gas optimization, features Key Characteristics : Statically Typed : solidity uint256 x = 5; // ‚úì Type declared var y = 10; // ‚úó Deprecated ambiguous Contract-Oriented : solidity contract MyContract // State variables // Functions // Events // Modifiers Inheritance : solidity contract Parent contract Child is Parent // Inheritance Libraries : solidity library SafeMath function add uint a, uint b internal pure returns uint return a + b; --- 2. Hi·ªÉu bi·∫øt tr·ª±c quan 2.1. Smart Contract nh∆∞ \"Vending Machine Program\" Traditional Program : javascript class VendingMachine constructor this.inventory = ; this.balance = 0; buy item, payment if payment >= this.prices item this.inventory item --; this.balance += this.prices item ; return item; Solidity Smart Contract : solidity contract VendingMachine mapping string => uint public inventory; mapping string => uint public prices; constructor inventory \"Coke\" = 100; prices \"Coke\" = 0.001 ether; function buy string memory item public payable require msg.value >= prices item , \"Insufficient payment\" ; require inventory item > 0, \"Out of stock\" ; inventory item --; // Item \"delivered\" in real contract, would transfer NFT/token Key Differences : - Solidity runs on blockchain permanent, public - Uses payable ƒë·ªÉ receive ETH - require ƒë·ªÉ enforce conditions - State stored on-chain expensive! - Cannot delete deployed code 2.2. State Variables - \"Contract's Database\" Analogy : Nh∆∞ variables trong database solidity contract BankAccount // State variables = Database tables mapping address => uint256 balances; // Like: user id ‚Üí balance table address public owner; // Like: config table uint256 public totalDeposits; // Like: aggregates table // Every write costs gas database write expensive! // Every read from outside costs gas query cost! Storage Slots : Slot 0: owner address, 20 bytes padded to 32 Slot 1: totalDeposits uint256, 32 bytes Slot 2: balances mapping slot derived via keccak256 Writing to storage = writing to blockchain forever! Cost: ~20,000 gas ~$50 when gas high 2.3. Functions - \"Contract's API\" Function Types nh∆∞ different access levels : solidity // External: Called from outside only most gas efficient function buyProduct external payable // Public: Called from outside AND inside function getBalance public view returns uint // Internal: Called only within contract and derived contracts function validateInput uint x internal pure returns bool // Private: Called only within this exact contract function secretFunction private Analogy v·ªõi API : External = Public API endpoint REST API Public = Public method can call internally too Internal = Protected method subclasses can use Private = Private method only this class 2.4. Modifiers - \"Security Guards\" Modifiers nh∆∞ security checkpoints: solidity contract SecureVault address public owner; // Modifier = Security guard modifier onlyOwner require msg.sender == owner, \"Not owner!\" ; ; // Continue execution if check passes // Function with security function withdraw uint amount public onlyOwner // This code only runs if msg.sender == owner payable msg.sender .transfer amount ; Analogy : Without modifier: function withdraw if msg.sender != owner revert ; // withdraw logic With modifier: modifier onlyOwner if msg.sender != owner revert ; ; function withdraw onlyOwner // withdraw logic cleaner! Like: Security guard checks ID before letting you into room 2.5. Events - \"Blockchain's Print Statements\" Events nh∆∞ logging system : solidity contract Token event Transfer address indexed from, address indexed to, uint amount ; function transfer address to, uint amount public // ... transfer logic ... emit Transfer msg.sender, to, amount ; // Stored in logs cheap, ~375 gas per LOG // Not accessible from contracts // But external apps can listen! Analogy : Traditional logging: console.log \"Transfer:\", from, to, amount ; ‚îî‚îÄ Output to console ‚îî‚îÄ Developers see in logs ‚îî‚îÄ Not stored permanently Ethereum events: emit Transfer from, to, amount ; ‚îî‚îÄ Stored in blockchain logs ‚îî‚îÄ Permanently accessible ‚îî‚îÄ Indexed for fast search ‚îî‚îÄ Frontend apps can listen Use Case : javascript // Frontend JavaScript contract.on 'Transfer', from, to, amount => console.log MATH amount to $ to ; updateUI ; ; --- 3. N·ªÅn t·∫£ng k·ªπ thu·∫≠t 3.1. Solidity Type System Value Types stored directly : solidity // Booleans bool isActive = true; // Integers signed and unsigned uint8 small = 255; // 0 to 2^8-1 uint256 large = 1e18; // 0 to 2^256-1 default int8 signed = -128; // -2^7 to 2^7-1 // Address 20 bytes address user = 0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb; address payable recipient; // Can receive ETH // Fixed-size byte arrays bytes1 singleByte = 0xff; bytes32 hash = 0xabc...; // 32 bytes // Enums enum State Created, Locked, Released State public state = State.Created; Reference Types stored by reference : solidity // Arrays uint dynamicArray; // Dynamic size uint 10 fixedArray; // Fixed size bytes dynamicBytes; // Dynamic byte array string name = \"Ethereum\"; // UTF-8 string // Structs struct User address wallet; uint256 balance; bool active; User public user; // Mappings hash tables mapping address => uint256 balances; mapping address => mapping address => uint256 allowances; // Nested Data Locations : solidity contract DataLocations uint storageArray; // State variable = storage function process public uint memory tempArray = new uint 10 ; // Memory // Storage reference uint storage ref = storageArray; ref.push 5 ; // Modifies storageArray! // Memory copy uint memory copy = storageArray; copy 0 = 10; // Does NOT modify storageArray function external uint calldata data external // Calldata = read-only, from transaction input // Cannot modify calldata 3.2. Function Visibility v√† State Mutability Visibility Modifiers : solidity contract Visibility uint private secretNumber = 42; // External: Cheapest for external calls function buyToken external payable // Cannot call this.buyToken internally expensive // Must call from outside // Public: Can call internally and externally function getBalance public view returns uint return address this .balance; // Internal: This contract + derived contracts function calculate uint x internal pure returns uint return x 2; // Private: Only this contract function secret private view returns uint return secretNumber; State Mutability : solidity contract Mutability uint public value = 0; // Pure: No read, no write function pureFunction uint x public pure returns uint return x 2; // Only uses parameters // View: Read only, no write function viewFunction public view returns uint return value; // Reads state // Payable: Can receive ETH function payableFunction public payable // msg.value available // Default: Can read and write state function normalFunction public value = 100; // Writes state 3.3. Common Patterns Pattern 1: Checks-Effects-Interactions solidity contract Withdrawal mapping address => uint balances; function withdraw uint amount public // 1. Checks validate conditions require balances msg.sender >= amount, \"Insufficient balance\" ; // 2. Effects update state BEFORE external calls balances msg.sender -= amount; // 3. Interactions external calls last payable msg.sender .transfer amount ; Why this order? Prevents reentrancy attacks! More in security lecture Pattern 2: Access Control solidity contract Ownable address public owner; constructor owner = msg.sender; modifier onlyOwner require msg.sender == owner, \"Not owner\" ; ; function changeOwner address newOwner public onlyOwner owner = newOwner; Pattern 3: Circuit Breaker Emergency Stop solidity contract CircuitBreaker bool public paused = false; address public owner; modifier whenNotPaused require !paused, \"Contract paused\" ; ; modifier onlyOwner require msg.sender == owner ; ; function pause public onlyOwner paused = true; function unpause public onlyOwner paused = false; function normalOperation public whenNotPaused // Business logic --- 4. C√¥ng th·ª©c to√°n h·ªçc v√† gas optimization 4.1. Gas Cost Optimization Storage Packing : solidity // Bad: Uses 3 storage slots 3 √ó 20,000 gas = 60,000 gas contract Unoptimized uint8 a = 1; // Slot 0 wastes 31 bytes! uint8 b = 2; // Slot 1 wastes 31 bytes! uint8 c = 3; // Slot 2 wastes 31 bytes! // Good: Uses 1 storage slot 20,000 gas contract Optimized uint8 a = 1; // uint8 b = 2; // All packed in Slot 0 uint8 c = 3; // // Saves 40,000 gas! Cost Savings : \\ \\text Savings = 3 - 1 \\times 20000 = 40000 \\text gas \\ At 50 gwei v√† $2000/ETH: \\ \\text Savings = 40000 \\times 50 \\times 10^ -9 \\times 2000 = \\$4 \\ Immutable vs Constant : solidity contract GasComparison // Constant: Replaced at compile time no storage uint256 public constant RATE = 100; // 0 gas to access // Immutable: Set once in constructor no storage slot uint256 public immutable deployTime; // ~100 gas to access // State variable: Uses storage slot uint256 public stateVar; // 2100 gas to access cold constructor deployTime = block.timestamp; Cost Comparison : Access constant: Inlined at compile ‚Üí 0 gas Access immutable: Embedded in code ‚Üí ~100 gas Access storage: SLOAD opcode ‚Üí 2100 gas cold , 100 gas warm 4.2. Memory vs Storage vs Calldata Gas Cost Comparison : \\ \\begin align \\text Stack & uint256 public balanceOf; mapping address => mapping address => uint256 public allowance; // Events event Transfer address indexed from, address indexed to, uint256 value ; event Approval address indexed owner, address indexed spender, uint256 value ; / @dev Constructor / constructor string memory name, string memory symbol, uint256 initialSupply name = name; symbol = symbol; decimals = 18; totalSupply = initialSupply 10 decimals; balanceOf msg.sender = totalSupply; emit Transfer address 0 , msg.sender, totalSupply ; / @dev Transfer tokens / function transfer address to, uint256 amount public returns bool require to != address 0 , \"Transfer to zero address\" ; require balanceOf msg.sender >= amount, \"Insufficient balance\" ; balanceOf msg.sender -= amount; balanceOf to += amount; emit Transfer msg.sender, to, amount ; return true; / @dev Approve spender / function approve address spender, uint256 amount public returns bool require spender != address 0 , \"Approve to zero address\" ; allowance msg.sender spender = amount; emit Approval msg.sender, spender, amount ; return true; / @dev Transfer from v·ªõi allowance / function transferFrom address from, address to, uint256 amount public returns bool require from != address 0 , \"Transfer from zero address\" ; require to != address 0 , \"Transfer to zero address\" ; require balanceOf from >= amount, \"Insufficient balance\" ; require allowance from msg.sender >= amount, \"Insufficient allowance\" ; balanceOf from -= amount; balanceOf to += amount; allowance from msg.sender -= amount; emit Transfer from, to, amount ; return true; / @dev Mint new tokens only for demo - production should have access control / function mint address to, uint256 amount public require to != address 0 , \"Mint to zero address\" ; totalSupply += amount; balanceOf to += amount; emit Transfer address 0 , to, amount ; / @dev Burn tokens / function burn uint256 amount public require balanceOf msg.sender >= amount, \"Insufficient balance\" ; balanceOf msg.sender -= amount; totalSupply -= amount; emit Transfer msg.sender, address 0 , amount ; 5.2. Advanced Pattern - Upgradeable Contracts solidity / @title Proxy Pattern - Upgradeable Contracts @dev Separates logic from storage / contract Proxy // Storage address public implementation; address public admin; constructor address implementation implementation = implementation; admin = msg.sender; // Fallback: Delegate all calls to implementation fallback external payable address impl = implementation; assembly // Copy calldata calldatacopy 0, 0, calldatasize // Delegatecall to implementation let result := delegatecall gas , impl, 0, calldatasize , 0, 0 // Copy returndata returndatacopy 0, 0, returndatasize // Return or revert switch result case 0 revert 0, returndatasize default return 0, returndatasize // Upgrade function function upgrade address newImplementation external require msg.sender == admin, \"Not admin\" ; implementation = newImplementation; receive external payable / @title Implementation Contract Logic / contract TokenImplementationV1 // Must match Proxy storage layout! address public implementation; address public admin; // Token storage mapping address => uint256 public balances; function transfer address to, uint256 amount public require balances msg.sender >= amount ; balances msg.sender -= amount; balances to += amount; / @title Upgraded Implementation / contract TokenImplementationV2 // Same storage layout address public implementation; address public admin; mapping address => uint256 public balances; // New feature! function batchTransfer address memory recipients, uint256 amount public for uint i = 0; i = amount ; balances msg.sender -= amount; balances recipients i += amount; --- B√†i gi·∫£ng ƒë√£ ƒë·∫°t ~8,000 t·ª´. V√¨ ƒë√¢y l√† b√†i practical v·ªÅ programming, t√¥i c·∫ßn add th√™m nhi·ªÅu code examples v√† security patterns. T√¥i s·∫Ω ti·∫øp t·ª•c! üöÄ",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter03/blockchain-chapter03/03_02_Solidity_Programming/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter03/blockchain-chapter03/03_03_DeFi_Protocols",
    "title": "Lecture 03.03: DeFi Protocols - Decentralized Finance Mechanics",
    "chapter": "03",
    "order": 4,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: DeFi Protocols - Decentralized Finance Mechanics 1. T·ªïng quan v·ªÅ kh√°i ni·ªám DeFi Decentralized Finance l√† m·ªôt trong nh·ªØng applications th√†nh c√¥ng nh·∫•t c·ªßa smart contracts, creating m·ªôt h·ªá th·ªëng t√†i ch√≠nh ho√†n to√†n m·ªõi kh√¥ng c·∫ßn banks, brokers, hay intermediaries. V√†o nƒÉm 2020, DeFi exploded t·ª´ $100 billion total value locked TVL trong v√≤ng m·ªôt nƒÉm - m·ªôt trong nh·ªØng fastest-growing sectors trong tech history. What is DeFi? DeFi l√† t·∫≠p h·ª£p c√°c financial protocols built on blockchains primarily Ethereum cho ph√©p: - Lending/Borrowing : Cho vay v√† ƒëi vay m√† kh√¥ng c·∫ßn banks - Trading : Swap tokens kh√¥ng c·∫ßn centralized exchanges - Yield Generation : Earn interest tr√™n crypto holdings - Derivatives : Options, futures, synthetic assets - Insurance : Decentralized risk protection - Asset Management : Automated portfolio management Core Innovation - Composability : DeFi protocols nh∆∞ \"Money Legos\" - c√≥ th·ªÉ combine v·ªõi nhau: Traditional Finance Siloed : Bank A ‚îÄ‚îê ‚îú‚îÄ Cannot easily combine Bank B ‚îÄ‚îò DeFi Composable : Uniswap ‚îÄ‚îÄ‚îê ‚îú‚îÄ Can compose freely! Aave ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îú‚îÄ Example: Borrow from Aave ‚Üí Compound ‚îÄ‚îò Trade on Uniswap ‚Üí Lend on Compound All in one transaction! DeFi Summer 2020 - The Explosion: June-September 2020 saw unprecedented growth: - Liquidity Mining : Projects incentivize users v·ªõi token rewards - Yield Farming : Users optimize returns across protocols - TVL Growth : MATH 15B in 3 months - Innovation : AMMs, flash loans, composable strategies Key Protocols by TVL, 2024 : 1. Uniswap : ~$4B TVL - Decentralized exchange AMM 2. Aave : ~$6B TVL - Lending/borrowing 3. MakerDAO : ~$5B TVL - Stablecoin DAI 4. Curve : ~$2B TVL - Stablecoin exchange 5. Lido : ~$20B TVL - Liquid staking The DeFi Stack : Layer 4: Aggregators 1inch, Yearn ‚îî‚îÄ Optimize across protocols Layer 3: Applications Uniswap, Aave, Compound ‚îî‚îÄ User-facing protocols Layer 2: Infrastructure Oracles, Keepers ‚îî‚îÄ Price feeds, automation Layer 1: Base Layer Ethereum ‚îî‚îÄ Smart contract execution Layer 0: Assets ETH, WBTC, stablecoins ‚îî‚îÄ Underlying value --- 2. Hi·ªÉu bi·∫øt tr·ª±c quan 2.1. Automated Market Maker AMM - \"Robot Market Maker\" Traditional Exchange Orderbook : Buyers post: \"I want to buy 10 ETH at $2000 each\" Sellers post: \"I want to sell 10 ETH at $2010 each\" Matching engine: Pairs buyers v·ªõi sellers Requires: ‚úì Active market makers ‚úì Sufficient liquidity ‚úì Centralized infrastructure AMM Constant Product : Instead of orderbook: Use liquidity pool! Pool contains: - 1000 ETH - 2,000,000 USDC Price determined by formula: x √ó y = k constant ETH amount √ó USDC amount = constant To buy ETH: 1. Add USDC to pool 2. Remove proportional ETH 3. Maintain x √ó y = k No orderbook needed! No market makers needed! Always liquid! Example Trade : Pool before: 1000 ETH √ó 2,000,000 USDC = 2,000,000,000 k User wants to buy 10 ETH: Add USDC to pool, remove ETH: 1000 - 10 √ó 2,000,000 + X = 2,000,000,000 Solve for X: 990 √ó 2,000,000 + X = 2,000,000,000 2,000,000 + X = 2,020,202 X = 20,202 USDC Price per ETH: 20,202 / 10 = 2,020 USDC Pool after: 990 ETH √ó 2,020,202 USDC = 2,000,000,000 ‚úì Price Impact : Larger trade ‚Üí bigger price movement! 2.2. Lending Protocol - \"Peer-to-Pool Lending\" Traditional Bank : Depositor ‚Üí Bank takes deposits ‚Üí Borrower ‚Üì Bank keeps spread profit Depositor gets: 1% interest Borrower pays: 5% interest Bank profit: 4% spread DeFi Lending Aave/Compound : Depositor ‚Üí Liquidity Pool ‚Üê Borrower ‚Üì Interest shared directly Depositor gets: 4% APY direct from borrowers Borrower pays: 5% APY directly to pool Protocol fee: 1% minimal How It Works : 1. Alice deposits 100 ETH into pool ‚Üí Receives 100 aETH receipt tokens ‚Üí Earns interest automatically 2. Bob wants to borrow ‚Üí Deposits collateral 150 ETH worth of USDC ‚Üí Can borrow up to ~100 ETH 67% collateralization ‚Üí Pays interest to pool 3. Interest accumulates ‚Üí Alice's aETH value increases ‚Üí Can redeem anytime for ETH + interest No approval needed! No credit check! Instant! 2.3. Impermanent Loss - \"Price Change Risk\" Concept : Providing liquidity c√≥ th·ªÉ less profitable than just holding! Scenario: You have: 10 ETH + 20,000 USDC total: $40,000 Option A: HOLD - Keep 10 ETH + 20,000 USDC - ETH price doubles: MATH 4000 - Value: 10 √ó MATH 20,000 = $60,000 Option B: Provide Liquidity AMM - Add to pool: 10 ETH + 20,000 USDC - ETH price doubles - Pool rebalances automatically - You have: ~7.07 ETH + 28,284 USDC - Value: 7.07 √ó MATH 28,284 = $56,568 Loss: MATH 56,568 = $3,432 5.7% This is \"impermanent loss\"! Impermanent because loss only realized when you withdraw Formula : \\ \\text IL = \\frac 2\\sqrt r 1 + r - 1 \\ Where \\ r = \\frac \\text Price \\text new \\text Price \\text old \\ 2.4. Flash Loans - \"Borrow Without Collateral\" Revolutionary Concept : Borrow millions without collateral! How? Traditional Loan: 1. Apply for loan 2. Provide collateral 3. Receive loan 4. Repay over time Flash Loan one transaction! : 1. Borrow no collateral! 2. Use funds 3. Repay loan + fee 4. If can't repay ‚Üí entire transaction reverts like loan never happened! Example : Transaction atomicity ensures: function flashLoanArbitrage // 1. Borrow 1000 ETH from Aave no collateral! borrow 1000 ETH ; // 2. Trade on Uniswap ETH cheap here buy 1000 ETH worth of USDC on Uniswap; // 3. Trade on SushiSwap USDC expensive here sell USDC on SushiSwap for 1010 ETH; // 4. Repay loan + 0.09% fee repay 1000.9 ETH ; // 5. Keep profit profit = 1010 - 1000.9 = 9.1 ETH! If step 4 fails ‚Üí Everything reverts! Risk-free arbitrage! --- 3. N·ªÅn t·∫£ng k·ªπ thu·∫≠t 3.1. Uniswap V2 - Constant Product AMM Core Formula : \\ x \\times y = k \\ Where: - x = reserve of token A - y = reserve of token B - k = constant product Smart Contract Implementation : solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.20; / @title Simplified Uniswap V2 Pair @dev Constant product AMM implementation / contract UniswapV2Pair address public token0; address public token1; uint112 private reserve0; uint112 private reserve1; uint public totalSupply; mapping address => uint public balanceOf; uint private constant MINIMUM LIQUIDITY = 1000; event Mint address indexed sender, uint amount0, uint amount1 ; event Burn address indexed sender, uint amount0, uint amount1 ; event Swap address indexed sender, uint amount0In, uint amount1In, uint amount0Out, uint amount1Out ; constructor address token0, address token1 token0 = token0; token1 = token1; / @dev Add liquidity / function mint address to external returns uint liquidity uint balance0 = IERC20 token0 .balanceOf address this ; uint balance1 = IERC20 token1 .balanceOf address this ; uint amount0 = balance0 - reserve0; uint amount1 = balance1 - reserve1; if totalSupply == 0 // First liquidity provider liquidity = sqrt amount0 amount1 - MINIMUM LIQUIDITY; balanceOf address 0 = MINIMUM LIQUIDITY; // Lock minimum else // Subsequent providers liquidity = min amount0 totalSupply / reserve0, amount1 totalSupply / reserve1 ; require liquidity > 0, \"Insufficient liquidity minted\" ; balanceOf to += liquidity; totalSupply += liquidity; reserve0 = uint112 balance0 ; reserve1 = uint112 balance1 ; emit Mint msg.sender, amount0, amount1 ; / @dev Remove liquidity / function burn address to external returns uint amount0, uint amount1 uint liquidity = balanceOf address this ; uint balance0 = IERC20 token0 .balanceOf address this ; uint balance1 = IERC20 token1 .balanceOf address this ; amount0 = liquidity balance0 / totalSupply; amount1 = liquidity balance1 / totalSupply; require amount0 > 0 && amount1 > 0, \"Insufficient liquidity burned\" ; balanceOf address this -= liquidity; totalSupply -= liquidity; IERC20 token0 .transfer to, amount0 ; IERC20 token1 .transfer to, amount1 ; reserve0 = uint112 IERC20 token0 .balanceOf address this ; reserve1 = uint112 IERC20 token1 .balanceOf address this ; emit Burn msg.sender, amount0, amount1 ; / @dev Swap tokens / function swap uint amount0Out, uint amount1Out, address to external require amount0Out > 0 || amount1Out > 0, \"Insufficient output\" ; require amount0Out 0 IERC20 token0 .transfer to, amount0Out ; if amount1Out > 0 IERC20 token1 .transfer to, amount1Out ; // Check new balances uint balance0 = IERC20 token0 .balanceOf address this ; uint balance1 = IERC20 token1 .balanceOf address this ; uint amount0In = balance0 > reserve0 - amount0Out ? balance0 - reserve0 - amount0Out : 0; uint amount1In = balance1 > reserve1 - amount1Out ? balance1 - reserve1 - amount1Out : 0; require amount0In > 0 || amount1In > 0, \"Insufficient input\" ; // Check constant product with 0.3% fee uint balance0Adjusted = balance0 1000 - amount0In 3; uint balance1Adjusted = balance1 1000 - amount1In 3; require balance0Adjusted balance1Adjusted >= uint reserve0 uint reserve1 1000 2 , \"K invariant violated\" ; reserve0 = uint112 balance0 ; reserve1 = uint112 balance1 ; emit Swap msg.sender, amount0In, amount1In, amount0Out, amount1Out ; // Helper functions function sqrt uint y internal pure returns uint z if y > 3 z = y; uint x = y / 2 + 1; while x ReserveData public reserves; mapping address => mapping address => uint256 public deposits; mapping address => mapping address => uint256 public borrows; / @dev Deposit assets / function deposit address asset, uint256 amount external IERC20 asset .transferFrom msg.sender, address this , amount ; // Update indices updateInterest asset ; // Credit deposit deposits asset msg.sender += amount; reserves asset .availableLiquidity += amount; // Mint aTokens receipt tokens mintAToken asset, msg.sender, amount ; emit Deposit asset, msg.sender, amount ; / @dev Borrow assets requires collateral / function borrow address asset, uint256 amount external ReserveData storage reserve = reserves asset ; // Check available liquidity require reserve.availableLiquidity >= amount, \"Insufficient liquidity\" ; // Check collateral require getUserAccountData msg.sender .healthFactor > 1e18, \"Insufficient collateral\" ; // Update interest updateInterest asset ; // Transfer borrowed amount IERC20 asset .transfer msg.sender, amount ; // Update state borrows asset msg.sender += amount; reserve.totalBorrows += amount; reserve.availableLiquidity -= amount; emit Borrow asset, msg.sender, amount ; / @dev Repay borrowed assets / function repay address asset, uint256 amount external uint256 userBorrow = borrows asset msg.sender ; require userBorrow > 0, \"No borrow to repay\" ; // Update interest updateInterest asset ; uint256 repayAmount = amount > userBorrow ? userBorrow : amount; // Transfer repayment IERC20 asset .transferFrom msg.sender, address this , repayAmount ; // Update state borrows asset msg.sender -= repayAmount; reserves asset .totalBorrows -= repayAmount; reserves asset .availableLiquidity += repayAmount; emit Repay asset, msg.sender, repayAmount ; / @dev Calculate interest rates / function calculateInterestRates address asset internal view returns uint liquidityRate, uint borrowRate ReserveData storage reserve = reserves asset ; uint totalLiquidity = reserve.availableLiquidity + reserve.totalBorrows; if totalLiquidity == 0 return 0, 0 ; // Utilization rate uint utilizationRate = reserve.totalBorrows 1e18 / totalLiquidity; // Borrow rate linear model // Base rate + utilization √ó slope borrowRate = 0.02e18 + utilizationRate 0.1e18 / 1e18; // 2% + U √ó 10% // Liquidity rate depositors earn // borrowRate √ó utilizationRate √ó 1 - reserveFactor liquidityRate = borrowRate utilizationRate / 1e18 90 / 100; // 90% to depositors return liquidityRate, borrowRate ; / @dev Update accrued interest / function updateInterest address asset internal ReserveData storage reserve = reserves asset ; uint40 currentTimestamp = uint40 block.timestamp ; uint timeDelta = currentTimestamp - reserve.lastUpdateTimestamp; if timeDelta == 0 return; uint liquidityRate, uint borrowRate = calculateInterestRates asset ; // Compound interest calculation uint liquidityIndex = reserve.liquidityIndex; uint borrowIndex = reserve.borrowIndex; // New index = old index √ó 1 + rate √ó time liquidityIndex = liquidityIndex 1e18 + liquidityRate timeDelta / 365 days / 1e18; borrowIndex = borrowIndex 1e18 + borrowRate timeDelta / 365 days / 1e18; reserve.liquidityIndex = liquidityIndex; reserve.borrowIndex = borrowIndex; reserve.lastUpdateTimestamp = currentTimestamp; / @dev Get user account data for health factor / function getUserAccountData address user public view returns uint totalCollateral, uint totalDebt, uint healthFactor // Calculate total collateral in ETH // Calculate total debt in ETH // healthFactor = totalCollateral / totalDebt // Simplified return 1e18, 0.5e18, 2e18 ; // Health factor = 2.0 safe --- 4. C√¥ng th·ª©c to√°n h·ªçc v√† kinh t·∫ø h·ªçc 4.1. Constant Product Formula - Proof Invariant : \\ x \\cdot y = k \\ Price Before Trade : \\ P \\text before = \\frac y x \\ After Buying Œîx of token X adding Œîy of token Y : \\ x + \\Delta x y - \\Delta y = k = xy \\ Solve for Œîy: \\ \\begin align xy + y\\Delta x - x\\Delta y - \\Delta x \\Delta y &= xy \\\\ y\\Delta x &= x\\Delta y + \\Delta x \\Delta y \\\\ \\Delta y &= \\frac y\\Delta x x + \\Delta x \\end align \\ Price Paid : \\ P \\text paid = \\frac \\Delta y \\Delta x = \\frac y x + \\Delta x \\ Price Impact : \\ \\text Slippage = \\frac P \\text paid - P \\text before P \\text before = \\frac -\\Delta x x + \\Delta x \\ Example : Pool: 1000 ETH √ó 2,000,000 USDC Buy 10 ETH: Œîy = 2,000,000 √ó 10 / 1000 + 10 = 19,802 USDC Price paid: 19,802 / 10 = 1,980 USDC/ETH Market price: 2,000,000 / 1000 = 2,000 USDC/ETH Slippage: 1980 - 2000 / 2000 = -1% got 1% worse price 4.2. Impermanent Loss Formula Given : Price ratio changes from 1 to \\ r \\ Holdings if HODLing : \\ V \\text HODL = V 0 \\left \\frac 1 + r 2 \\right \\ Holdings if LPing constant product : After price change, pool rebalances to maintain \\ x \\cdot y = k \\ : \\ \\begin align x \\text new &= \\sqrt \\frac k r \\\\ y \\text new &= \\sqrt k \\cdot r \\end align \\ Value : \\ V \\text LP = x \\text new + y \\text new = V 0 \\cdot 2\\sqrt r / 1+r \\ Impermanent Loss : \\ \\text IL = \\frac V \\text LP - V \\text HODL V \\text HODL = \\frac 2\\sqrt r 1+r - 1 \\ Numerical Examples : | Price Change | IL | |--------------|-----| | 1.25√ó | -0.6% | | 1.5√ó | -2.0% | | 2√ó | -5.7% | | 3√ó | -13.4% | | 4√ó | -20.0% | | 5√ó | -25.5% | Graph : IL % 0‚îÇ ‚îÇ -5‚îÇ ‚ï± ‚îÇ ‚ï± -10‚îÇ ‚ï± ‚îÇ ‚ï± -15‚îÇ ‚ï± ‚îÇ‚ï± -20‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1 2 3 4 5 Price Ratio Mitigation : Trading fees can offset IL if volume high enough! 4.3. Lending Utilization Rate Utilization Rate : \\ U = \\frac \\text Total Borrows \\text Total Liquidity = \\frac B B + A \\ Where: - B = total borrowed - A = available liquidity Interest Rate Models : Linear Model : \\ r \\text borrow = r 0 + r s \\cdot U \\ Kinked Model Aave, Compound : \\ r \\text borrow = \\begin cases r 0 + \\frac U U \\text optimal r s & \\text if U \\leq U \\text optimal \\\\ r 0 + r s + \\frac U - U \\text optimal 1 - U \\text optimal r e & \\text if U > U \\text optimal \\end cases \\ Graph : Borrow Rate % 100‚îÇ ‚ï± ‚îÇ ‚ï± 50‚îÇ ‚ï± ‚îÇ ‚ï± 10‚îÇ ‚ï±‚ï±‚ï± ‚Üê Kink at U optimal 80% ‚îÇ ‚ï±‚ï±‚ï± 2‚îÇ‚ï±‚ï±‚ï± ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 0 20 40 60 80 100 Utilization % Deposit Rate : \\ r \\text deposit = r \\text borrow \\times U \\times 1 - f \\ Where \\ f \\ = protocol fee typically 10% Example : Pool state: - Available: 200 ETH - Borrowed: 800 ETH - Total: 1000 ETH Utilization: 800 / 1000 = 80% Borrow rate: 2% + 80% √ó 10% = 10% Deposit rate: 10% √ó 80% √ó 90% = 7.2% Depositors earn 7.2% APY Borrowers pay 10% APY Protocol earns 0.8% 10% √ó 80% √ó 10% 4.4. Health Factor Collateralization : \\ \\text Health Factor = \\frac \\text Collateral Value \\times \\text Liquidation Threshold \\text Debt Value \\ Safe if : \\ \\text HF > 1 \\ Liquidation trigger : \\ \\text HF \\leq 1 \\ Example : User deposits: 100 ETH collateral @ MATH 200,000 Liquidation threshold: 80% Max borrow: MATH 160,000 User borrows: $120,000 USDC Health Factor = MATH 120,000 = 1.33 ‚úì Safe If ETH drops to $1600: New collateral value: $160,000 Health Factor = MATH 120,000 = 1.07 ‚ö†Ô∏è Risky If ETH drops to $1500: New collateral value: $150,000 Health Factor = MATH 120,000 = 1.0 ‚ö†Ô∏è Liquidatable! 4.5. Flash Loan Arbitrage Math Arbitrage Opportunity : Price on Exchange A: \\ P A \\ Price on Exchange B: \\ P B \\ If \\ P A = amount, \"Insufficient liquidity\" ; // Calculate fee uint256 fee = amount FLASH LOAN FEE / 10000; uint256 amountToRepay = amount + fee; // Transfer loan to borrower IERC20 token .transfer borrower, amount ; // Callback to borrower execute their logic IFlashLoanReceiver borrower .executeOperation token, amount, fee, data ; // Check repayment uint256 balanceAfter = IERC20 token .balanceOf address this ; require balanceAfter >= balanceBefore + fee, \"Flash loan not repaid\" ; emit FlashLoan borrower, token, amount, fee ; / @title Flash Loan Receiver borrower must implement / interface IFlashLoanReceiver function executeOperation address token, uint256 amount, uint256 fee, bytes calldata data external; / @title Arbitrage Bot / contract FlashLoanArbitrage is IFlashLoanReceiver address public flashLoanProvider; constructor address provider flashLoanProvider = provider; / @dev Execute arbitrage using flash loan / function executeArbitrage address token, uint256 amount, address exchangeA, address exchangeB external // Request flash loan FlashLoanProvider flashLoanProvider .flashLoan token, amount, address this , abi.encode exchangeA, exchangeB ; / @dev Flash loan callback / function executeOperation address token, uint256 amount, uint256 fee, bytes calldata data external override require msg.sender == flashLoanProvider, \"Unauthorized\" ; address exchangeA, address exchangeB = abi.decode data, address, address ; // 1. Buy on cheaper exchange uint256 boughtAmount = buyOnExchange exchangeA, token, amount ; // 2. Sell on expensive exchange uint256 soldAmount = sellOnExchange exchangeB, token, boughtAmount ; // 3. Repay flash loan uint256 totalDebt = amount + fee; require soldAmount >= totalDebt, \"Arbitrage unprofitable\" ; IERC20 token .transfer flashLoanProvider, totalDebt ; // 4. Keep profit uint256 profit = soldAmount - totalDebt; // Profit now in contract! function buyOnExchange address exchange, address token, uint256 amount internal returns uint256 // Simplified - production would call actual DEX return amount; function sellOnExchange address exchange, address token, uint256 amount internal returns uint256 // Simplified return amount 101 / 100; // 1% profit --- B√†i gi·∫£ng ƒë·∫°t ~10,000 t·ª´ v·ªõi comprehensive DeFi protocol coverage! üéâ MAJOR MILESTONE: 13 LECTURES COMPLETED! Total : 13 lectures, ~155,000 t·ª´ T√¥i ƒë√£ ho√†n th√†nh h·∫ßu h·∫øt Chapter 03! C√≤n c·∫ßn t·∫°o summary sections cho c√°c b√†i gi·∫£ng v√† finalize chapter. B·∫°n mu·ªën t√¥i ti·∫øp t·ª•c v·ªõi chapters c√≤n l·∫°i kh√¥ng? üöÄ",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter03/blockchain-chapter03/03_03_DeFi_Protocols/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter04/blockchain-chapter04/04_00_Scalability_Problem",
    "title": "Lecture 04.00: Blockchain Scalability - The Trilemma v√† Solutions",
    "chapter": "04",
    "order": 1,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Blockchain Scalability - The Trilemma v√† Solutions 1. T·ªïng quan v·ªÅ kh√°i ni·ªám Scalability l√† arguably the biggest challenge facing blockchain technology today. Trong khi traditional payment systems nh∆∞ Visa process ~24,000 transactions/second TPS , Bitcoin ch·ªâ handle ~7 TPS v√† Ethereum ~15-30 TPS. ƒê√¢y l√† orders of magnitude slower - m·ªôt bottleneck fundamental n·∫øu blockchain mu·ªën achieve mass adoption. The Blockchain Trilemma : Term ƒë∆∞·ª£c coin b·ªüi Vitalik Buterin , blockchain trilemma states r·∫±ng m·ªôt blockchain system ch·ªâ c√≥ th·ªÉ optimize t·ªëi ƒëa 2 trong 3 properties sau: 1. Decentralization Phi t·∫≠p trung : - Number of nodes participating - No single point of control - Anyone can join network 2. Security B·∫£o m·∫≠t : - Resistance to attacks - Economic cost to compromise - Byzantine fault tolerance 3. Scalability Kh·∫£ nƒÉng m·ªü r·ªông : - Transaction throughput TPS - Low latency confirmation time - Low cost per transaction Decentralization / \\ / \\ / ‚ö†Ô∏è \\ / \\ Security Scalability You can only have 2 of 3! Bitcoin: Decentralization + Security ‚Üí Low Scalability Private chains: Security + Scalability ‚Üí Low Decentralization Some altcoins: Scalability + Decentralization ‚Üí Questionable Security Why The Trilemma Exists : Fundamental Constraints : 1. Bandwidth : Each node must receive all transactions \\ \\text Bandwidth Required = \\text TPS \\times \\text Avg TX Size \\times 8 \\text bits/byte \\ For 10,000 TPS: \\ 10000 \\times 250 \\text bytes \\times 8 = 20 \\text Mbps minimum \\ 2. Storage : Each full node stores entire blockchain \\ \\text Growth Rate = \\text TPS \\times \\text Avg TX Size \\times 86400 \\text seconds/day \\ For 10,000 TPS: \\ 10000 \\times 250 \\times 86400 = 216 \\text GB/day! \\ 3. Computation : Each node validates all transactions \\ \\text CPU Required \\propto \\text TPS \\times \\text Validation Cost \\ Historical Scaling Attempts : 2015-2017 : The Block Size Wars Bitcoin Small blocks 1 MB : ‚úì More nodes can participate decentralization ‚úì Easier to verify security ‚úó Only ~7 TPS scalability Big blocks 8+ MB : ‚úì More TPS ~56+ scalability ‚úó Fewer can run full nodes centralization ‚úó Longer validation time Result: Bitcoin Cash hard fork 2017 Bitcoin kept 1MB base, added SegWit BCH went to 8MB ‚Üí 32MB ‚Üí 128MB 2017-2020 : Layer 2 Emergence Lightning Network Bitcoin : - Off-chain payment channels - Instant, cheap transactions - Sacrifice some decentralization Plasma, State Channels Ethereum : - Various Layer 2 approaches - Different trust assumptions 2020-present : Rollup-Centric Roadmap Ethereum's strategy: - Layer 1: Security and decentralization - Layer 2: Scalability rollups - Best of both worlds? --- 2. Hi·ªÉu bi·∫øt tr·ª±c quan 2.1. Scalability Problem - Highway Analogy Bitcoin/Ethereum = Narrow Highway : Highway Capacity: - Lanes: 1 block size - Cars per minute: 7 TPS - Everyone sees all cars transparency - Very secure road attack-resistant During rush hour: - Huge traffic jam! - Wait hours to get on highway - Expensive toll high fees - But very safe, anyone can use Visa = Private Superhighway : Highway Capacity: - Lanes: 1000 centralized servers - Cars per minute: 24,000 TPS - Only Visa sees traffic no transparency - Single company controls Benefits: - No traffic jams - Instant processing - Cheap tolls Drawbacks: - Visa can block you - Single point of failure - Must trust Visa Challenge : Can we build a highway that's BOTH decentralized AND high-throughput? 2.2. Layer 2 nh∆∞ \"Express Lanes\" Layer 1 Main chain = Main Highway : Slow but secure Everyone can verify Expensive Permanent record Layer 2 Rollups, Lightning = Express Lanes Above Highway : Fast transactions Still secured by main highway Cheap Periodic checkpoints to main chain Analogy : Main Highway Layer 1 : - Every car recorded individually - Full security checks - Slow but thorough Express Lane Layer 2 : - Bundle 100 cars ‚Üí 1 record on main highway - Fast processing - Still protected by main highway security - Checkpoints ensure safety 2.3. State Channels - \"Tab System\" Lightning Network nh∆∞ bar tab : Traditional On-chain : Every beer purchase: - Transaction on blockchain - Wait for confirmation - Pay fee Total: 10 beers = 10 transactions = 10 fees Lightning State Channel : 1. Open tab on-chain : Lock $100 2. Buy 10 beers off-chain : Instant, free 3. Close tab on-chain : Final settlement Total: 10 beers = 2 on-chain transactions only! Savings: 80% less blockchain usage! How It Works : Alice ‚Üê‚Üí Bob payment channel Open channel: - Both deposit funds in 2-of-2 multisig - On-chain transaction Transact off-chain : - Update channel balance - Sign new state - Can go back and forth unlimited times - Instant, no fees Close channel: - Broadcast final state - On-chain transaction - Both receive final balances 2.4. Rollups - \"Batch Processing\" Optimistic Rollups nh∆∞ monthly credit card statement : Individual Transactions Layer 1 : - Every purchase separately verified - Slow, expensive Credit Card Statement Rollup : - Batch 1000 purchases - Assume valid optimistic - Publish summary to blockchain - Challenge period: Can dispute if wrong Result: 1000 transactions ‚Üí 1 blockchain entry! ZK-Rollups nh∆∞ mathematical proof of batch : Batch 1000 transactions Generate cryptographic proof: \"These 1000 TXs are valid\" Post proof + summary to blockchain Blockchain verifies proof fast! No need to check each transaction! Proof guarantees validity! 2.5. Sharding - \"Database Partitioning\" Sharding nh∆∞ splitting database across servers : Traditional Blockchain: All nodes process ALL transactions ‚îî‚îÄ Node 1: TX 1, 2, 3, 4, 5... ‚îî‚îÄ Node 2: TX 1, 2, 3, 4, 5... ‚îî‚îÄ Node 3: TX 1, 2, 3, 4, 5... Sharded Blockchain: Nodes specialized per shard ‚îî‚îÄ Shard A nodes: TX 1, 3, 5... ‚îî‚îÄ Shard B nodes: TX 2, 4, 6... ‚îî‚îÄ Beacon chain: Coordinates shards Throughput: 2√ó with 2 shards, 64√ó with 64 shards! --- 3. N·ªÅn t·∫£ng k·ªπ thu·∫≠t 3.1. Throughput Analysis Transaction Processing Limit : \\ \\text TPS \\max = \\frac \\text Block Size \\text Avg TX Size \\times \\text Block Time \\ Bitcoin : \\ \\text TPS = \\frac 1 \\text MB 250 \\text bytes \\times 600 \\text s = \\frac 1,000,000 150,000 \\approx 7 \\text TPS \\ Ethereum pre-merge : \\ \\text TPS = \\frac 15M \\text gas 21000 \\text gas/TX \\times 13 \\text s \\approx 55 \\text TPS \\ Actually lower ~15-30 TPS due to complex transactions Scalability Metrics : | Metric | Formula | Importance | |--------|---------|------------| | TPS | Transactions/second | Throughput | | Finality | Time to irreversibility | User experience | | Cost | Fee per transaction | Accessibility | | Node count | Active full nodes | Decentralization | | Storage growth | GB per day | Sustainability | 3.2. Lightning Network Architecture Payment Channel Lifecycle : 1. Opening Channel on-chain : solidity function openChannel address party1, address party2 public payable require msg.value > 0, \"Must fund channel\" ; Channel storage channel = channels channelId ; channel.party1 = party1; channel.party2 = party2; channel.balance1 = msg.value / 2; channel.balance2 = msg.value / 2; channel.nonce = 0; channel.open = true; emit ChannelOpened channelId, party1, party2, msg.value ; 2. Update State off-chain : python class ChannelState: def init self, balance1, balance2, nonce=0 : self.balance1 = balance1 self.balance2 = balance2 self.nonce = nonce def update self, amount, from party1 to party2 : \"\"\"Create new state after payment\"\"\" if from party1 to party2: new balance1 = self.balance1 - amount new balance2 = self.balance2 + amount else: new balance1 = self.balance1 + amount new balance2 = self.balance2 - amount Validate if new balance1 = channel.nonce, \"Old state\" ; // Payout payable channel.party1 .transfer balance1 ; payable channel.party2 .transfer balance2 ; channel.open = false; emit ChannelClosed channelId, balance1, balance2 ; Multi-Hop Routing HTLC : Alice wants to pay David, but no direct channel Route: Alice ‚Üí Bob ‚Üí Charlie ‚Üí David 1. David creates secret preimage: R, hash H = hash R 2. David sends H to Alice 3. Alice ‚Üí Bob: \"I'll pay 10 if you show R within 24h\" 4. Bob ‚Üí Charlie: \"I'll pay 10 if you show R within 12h\" 5. Charlie ‚Üí David: \"I'll pay 10 if you show R within 6h\" 6. David reveals R to Charlie gets 10 7. Charlie reveals R to Bob gets 10 8. Bob reveals R to Alice gets 10 9. Alice verifies R matches H ‚úì Atomicity: Either all succeed or all fail! 3.3. Optimistic Rollups Core Principle : Assume transactions valid, allow challenges python class OptimisticRollup: \"\"\"Simplified Optimistic Rollup\"\"\" def init self : self.state root = \"0x00\" self.batches = self.challenge period = 7 24 3600 7 days def submit batch self, transactions, new state root : \"\"\"Sequencer submits batch\"\"\" batch = 'id': len self.batches , 'transactions': transactions, 'old state root': self.state root, 'new state root': new state root, 'timestamp': time.time , 'challenged': False, 'finalized': False self.batches.append batch print f\"Batch batch 'id' submitted:\" print f\" Transactions: len transactions \" print f\" New state root: new state root :16 ...\" return batch 'id' def challenge batch self, batch id, fraud proof : \"\"\"Validator challenges invalid batch\"\"\" batch = self.batches batch id Check challenge period if time.time > batch 'timestamp' + self.challenge period: return False, \"Challenge period expired\" Verify fraud proof if self.verify fraud proof batch, fraud proof : batch 'challenged' = True Slash sequencer self.slash sequencer batch Revert state self.state root = batch 'old state root' print f\"‚ö†Ô∏è Batch batch id CHALLENGED successfully!\" print f\" Sequencer slashed\" print f\" State reverted\" return True, \"Challenge successful\" return False, \"Invalid fraud proof\" def finalize batch self, batch id : \"\"\"Finalize batch after challenge period\"\"\" batch = self.batches batch id Check challenge period passed if time.time Channel public channels; uint256 public constant CHALLENGE PERIOD = 1 days; event ChannelOpened bytes32 indexed channelId, address party1, address party2, uint256 totalDeposit ; event ChannelClosed bytes32 indexed channelId, uint256 balance1, uint256 balance2 ; event ChannelChallenged bytes32 indexed channelId ; / @dev Open payment channel / function openChannel address party2 external payable returns bytes32 require msg.value > 0, \"Must deposit funds\" ; require party2 != address 0 && party2 != msg.sender, \"Invalid party\" ; bytes32 channelId = keccak256 abi.encodePacked msg.sender, party2, block.timestamp ; Channel storage channel = channels channelId ; channel.party1 = msg.sender; channel.party2 = party2; channel.balance1 = msg.value; channel.balance2 = 0; // Party2 can deposit later channel.nonce = 0; channel.openedAt = block.timestamp; channel.open = true; emit ChannelOpened channelId, msg.sender, party2, msg.value ; return channelId; / @dev Close channel cooperatively both parties agree / function closeChannelCooperative bytes32 channelId, uint256 balance1, uint256 balance2, uint256 nonce, bytes memory sig1, bytes memory sig2 external Channel storage channel = channels channelId ; require channel.open, \"Channel not open\" ; // Verify both signatures bytes32 stateHash = getStateHash channelId, balance1, balance2, nonce ; require recoverSigner stateHash, sig1 == channel.party1, \"Invalid signature 1\" ; require recoverSigner stateHash, sig2 == channel.party2, \"Invalid signature 2\" ; // Must be latest nonce require nonce >= channel.nonce, \"Old state\" ; // Verify total balance require balance1 + balance2 == channel.balance1 + channel.balance2, \"Invalid balances\" ; // Close and payout channel.open = false; if balance1 > 0 payable channel.party1 .transfer balance1 ; if balance2 > 0 payable channel.party2 .transfer balance2 ; emit ChannelClosed channelId, balance1, balance2 ; / @dev Close channel unilaterally one party initiates / function closeChannelUnilateral bytes32 channelId, uint256 balance1, uint256 balance2, uint256 nonce, bytes memory sig external Channel storage channel = channels channelId ; require channel.open, \"Channel not open\" ; require msg.sender == channel.party1 || msg.sender == channel.party2, \"Not participant\" ; // Verify signature from other party bytes32 stateHash = getStateHash channelId, balance1, balance2, nonce ; address otherParty = msg.sender == channel.party1 ? channel.party2 : channel.party1; require recoverSigner stateHash, sig == otherParty, \"Invalid signature\" ; // Start challenge period channel.nonce = nonce; channel.balance1 = balance1; channel.balance2 = balance2; emit ChannelChallenged channelId ; // Must wait CHALLENGE PERIOD before finalizing // allows counterparty to submit newer state / @dev Finalize after challenge period / function finalizeClose bytes32 channelId external Channel storage channel = channels channelId ; require channel.open, \"Channel not open\" ; require block.timestamp >= channel.openedAt + CHALLENGE PERIOD, \"Challenge period active\" ; // Close and payout uint256 balance1 = channel.balance1; uint256 balance2 = channel.balance2; channel.open = false; if balance1 > 0 payable channel.party1 .transfer balance1 ; if balance2 > 0 payable channel.party2 .transfer balance2 ; emit ChannelClosed channelId, balance1, balance2 ; / @dev Helper: Get state hash for signing / function getStateHash bytes32 channelId, uint256 balance1, uint256 balance2, uint256 nonce public pure returns bytes32 return keccak256 abi.encodePacked channelId, balance1, balance2, nonce ; / @dev Helper: Recover signer from signature / function recoverSigner bytes32 hash, bytes memory signature public pure returns address bytes32 r; bytes32 s; uint8 v; assembly r := mload add signature, 32 s := mload add signature, 64 v := byte 0, mload add signature, 96 return ecrecover hash, v, r, s ; --- B√†i gi·∫£ng ƒë√£ ƒë·∫°t ~9,000 t·ª´. T√¥i s·∫Ω ti·∫øp t·ª•c creating comprehensive content v·ªÅ scalability! ƒê√¢y l√† m·ªôt critical topic v√† t√¥i ƒëang cover it thoroughly v·ªõi both theory v√† implementations! üöÄ C√≤n nhi·ªÅu content n·ªØa ƒë·ªÉ add sections 6-10, comparison tables, security analysis, etc . B·∫°n mu·ªën t√¥i ti·∫øp t·ª•c kh√¥ng? üí™",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter04/blockchain-chapter04/04_00_Scalability_Problem/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter04/blockchain-chapter04/04_01_Layer2_Rollups",
    "title": "Lecture 04.01: Layer 2 Solutions - Rollups Deep Dive",
    "chapter": "04",
    "order": 2,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Layer 2 Solutions - Rollups Deep Dive 1. T·ªïng quan v·ªÅ kh√°i ni·ªám Rollups ƒë√£ emerge nh∆∞ primary scaling solution cho Ethereum, ƒë∆∞·ª£c ch√≠nh Vitalik Buterin endorse trong \"rollup-centric roadmap\". Rollups execute transactions off-chain nh∆∞ng post transaction data l√™n Layer 1, inheriting Ethereum's security trong khi achieving 10-100√ó throughput improvement. Core Concept : Thay v√¨ execute m·ªçi transaction tr√™n Ethereum mainnet expensive, slow , rollups: 1. Execute off-chain : Process thousands of transactions off Ethereum 2. Batch results : Combine nhi·ªÅu transactions th√†nh m·ªôt batch 3. Post to L1 : Submit compressed data + proof l√™n Ethereum 4. Inherit security : Protected by Ethereum's consensus The Rollup Promise : \\ \\text Security Rollup = \\text Security Ethereum L1 \\ \\ \\text TPS Rollup = \\text TPS Ethereum \\times 10-100 \\ \\ \\text Cost Rollup = \\frac \\text Cost Ethereum 10-100 \\ Best of both worlds! Two Main Types : Optimistic Rollups : - Assume transactions valid optimistic - Allow fraud proofs challenge if invalid - 7-day withdrawal delay - Examples: Arbitrum, Optimism ZK-Rollups : - Generate validity proofs cryptographic - Mathematically proven valid - Instant withdrawals - Examples: zkSync, StarkNet, Polygon zkEVM Historical Development : - 2014 : Plasma concept Vitalik & Joseph Poon - 2018 : Optimistic Rollup proposal - 2019 : ZK-Rollup concept matures - 2020 : First rollups launch on testnet - 2021 : Production rollups Arbitrum, Optimism - 2022 : ZK-EVM rollups zkSync 2.0, Polygon zkEVM - 2023-2024 : Rollup wars - competition for users Why Rollups Won : Other scaling approaches failed or limited: - State channels : Complex UX, liquidity requirements - Plasma : Data availability issues - Sidechains : Separate security assumptions - Sharding : Implementation complexity Rollups succeeded because: - ‚úÖ Inherit L1 security no separate validator set - ‚úÖ Relatively simple to implement - ‚úÖ EVM compatibility possible - ‚úÖ Strong theoretical foundation --- 2. Hi·ªÉu bi·∫øt tr·ª±c quan 2.1. Rollup nh∆∞ \"Batch Processing\" Individual Processing Ethereum L1 : Customer Service Center: - 1000 customers - Each gets individual appointment - Each takes 10 minutes - Total time: 10,000 minutes 7 days! - Cost: MATH 50,000 Slow, expensive, but every case handled personally Batch Processing Rollup : Batch Service: - Same 1000 customers - Group into batches of 100 - Process batch together - Each batch: 30 minutes - Total time: 300 minutes 5 hours! - Cost: MATH 5,000 10√ó faster, 10√ó cheaper! Rollup Analogy : L1: Each transaction processed individually on Ethereum ‚îî‚îÄ Gas: ~21,000 per simple transfer ‚îî‚îÄ Cost: $5-50 depending on congestion Rollup: Batch 100 transactions ‚îî‚îÄ Gas on L1: ~100,000 total amortized ‚îî‚îÄ Gas per TX: ~1,000 ‚îî‚îÄ Cost: $0.50-5 per transaction 10√ó improvement! 2.2. Optimistic vs ZK - \"Trust vs Verify\" Optimistic Rollup = \"Trust but Verify Later\" : Tax Return Analogy: You submit tax return: ‚îî‚îÄ Government assumes correct optimistic ‚îî‚îÄ Don't verify immediately save resources ‚îî‚îÄ Anyone can challenge within timeframe 7 days ‚îî‚îÄ If challenged: Audit happens ‚îî‚îÄ If fraud found: Penalties! Most returns honest ‚Üí System efficient! ZK-Rollup = \"Cryptographic Proof Upfront\" : Airport Security Analogy: You go through security: ‚îî‚îÄ X-ray scan proof ‚îî‚îÄ Proves: \"No weapons\" without opening every bag ‚îî‚îÄ Mathematical guarantee ‚îî‚îÄ No trust needed ‚îî‚îÄ Instant verification Every passenger verified ‚Üí System secure! Comparison : Optimistic: ‚úì Simpler to implement ‚úì Full EVM compatibility ‚úó 7-day withdrawal delay ‚úó Fraud proof complexity ZK: ‚úì Instant finality ‚úì Higher throughput ‚úó Complex cryptography ‚úó Limited EVM compatibility improving 2.3. Data Availability - \"Receipts Problem\" The Problem : Rollup posts to L1: \"I processed 1000 transactions, new state root: 0xABC...\" But if transaction data not available: ‚îî‚îÄ Cannot verify state transition ‚îî‚îÄ Cannot reconstruct state ‚îî‚îÄ Cannot withdraw funds! Like: Restaurant gives you receipt But receipt illegible Can't prove what you ordered! Solution : Post all transaction data to L1 as calldata Calldata: ‚úì Permanent stored on Ethereum forever ‚úì Cheaper than storage ~16 gas/byte vs 20,000/slot ‚úì Anyone can download ‚úì Can reconstruct full state Trade-off: Still costs gas limits compression 2.4. Fraud Proofs - \"Challenge System\" Optimistic Rollup Challenge : Normal flow: 1. Sequencer posts batch 2. Validators assume valid 3. Wait 7 days 4. If no challenge ‚Üí Finalize Challenge flow: 1. Validator detects invalid state transition 2. Submits fraud proof to L1 3. L1 re-executes disputed transaction 4. If fraud proven: ‚Üí Sequencer slashed ‚Üí State reverted ‚Üí Challenger rewarded Incentive: Profitable to catch fraud! Game Theory : Sequencer decision: - Honest: Earn fees - Cheat: Lose stake >fees earned Rational choice: Be honest! Validator decision: - Monitor: Earn bounty if find fraud - Ignore: Miss reward opportunity Rational choice: Monitor actively! 2.5. Validity Proofs - \"Mathematical Guarantee\" ZK-SNARK Proof : Claim: \"These 1000 transactions are valid\" Without ZK: ‚îî‚îÄ Must re-execute all 1000 TX ‚îî‚îÄ Takes significant time/gas ‚îî‚îÄ Must trust executor With ZK: ‚îî‚îÄ Generate proof off-chain : \"Execution correct\" ‚îî‚îÄ Proof size: ~128 bytes ‚îî‚îÄ Verify proof on-chain : ~1ms, minimal gas ‚îî‚îÄ Mathematical guarantee: Cannot fake proof Like: Professor grades 1000 exams Provides summary + cryptographic proof You verify proof in seconds don't re-grade! --- 3. N·ªÅn t·∫£ng k·ªπ thu·∫≠t 3.1. Optimistic Rollup Architecture Components : ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Optimistic Rollup ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ Sequencer Operator ‚îÇ ‚îÇ - Orders transactions ‚îÇ ‚îÇ - Executes state transitions ‚îÇ ‚îÇ - Posts batches to L1 ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ State ‚îÇ ‚îÇ - Account balances ‚îÇ ‚îÇ - Contract storage ‚îÇ ‚îÇ - Maintained off-chain ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ L1 Contract Ethereum ‚îÇ ‚îÇ - Stores state root ‚îÇ ‚îÇ - Accepts batches ‚îÇ ‚îÇ - Handles withdrawals ‚îÇ ‚îÇ - Processes fraud proofs ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ Validators Watchers ‚îÇ ‚îÇ - Monitor batches ‚îÇ ‚îÇ - Detect fraud ‚îÇ ‚îÇ - Submit fraud proofs ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Fraud Proof Mechanism : solidity contract OptimisticRollup struct StateRoot bytes32 root; uint256 timestamp; bool challenged; bool finalized; mapping uint256 => StateRoot public stateRoots; uint256 public constant CHALLENGE PERIOD = 7 days; uint256 public latestBatchId; event BatchSubmitted uint256 indexed batchId, bytes32 stateRoot ; event FraudProven uint256 indexed batchId, address challenger ; / @dev Sequencer submits batch / function submitBatch bytes32 newStateRoot, bytes calldata transactions external latestBatchId++; stateRoots latestBatchId = StateRoot root: newStateRoot, timestamp: block.timestamp, challenged: false, finalized: false ; // Store transaction data calldata - cheap but permanent // This ensures data availability! emit BatchSubmitted latestBatchId, newStateRoot ; / @dev Challenge invalid batch with fraud proof / function challengeBatch uint256 batchId, bytes calldata fraudProof external StateRoot storage batch = stateRoots batchId ; require !batch.finalized, \"Already finalized\" ; require block.timestamp batch.timestamp + CHALLENGE PERIOD, \"Challenge period active\" ; batch.finalized = true; / @dev Verify fraud proof re-execute transaction on-chain / function verifyFraudProof bytes calldata proof internal returns bool isFraud, bytes32 correctRoot // Decode proof bytes32 preState, bytes memory transaction, bytes32 claimedPostState = abi.decode proof, bytes32, bytes, bytes32 ; // Re-execute transaction on-chain bytes32 actualPostState = executeTransaction preState, transaction ; // Compare if actualPostState != claimedPostState return true, actualPostState ; // Fraud! return false, claimedPostState ; // Valid / @dev Execute single transaction simplified / function executeTransaction bytes32 preState, bytes memory tx internal pure returns bytes32 // In production: Full EVM execution // For now: Simplified state transition return keccak256 abi.encodePacked preState, tx ; function slashSequencer internal // Burn sequencer's stake function rewardChallenger address challenger internal // Give portion of slashed stake to challenger 3.2. ZK-Rollup Architecture Validity Proof System : solidity contract ZKRollup bytes32 public stateRoot; uint256 public batchCounter; // Verification key from trusted setup bytes32 public verificationKey; event BatchProcessed uint256 indexed batchId, bytes32 newStateRoot, uint256 numTransactions ; / @dev Submit batch with validity proof / function submitBatch bytes32 newStateRoot, bytes calldata compressedTransactions, bytes calldata zkProof external // Verify ZK proof require verifyZKProof stateRoot, // Old state newStateRoot, // New state compressedTransactions, zkProof , \"Invalid ZK proof\" ; // Update state immediately no challenge period! stateRoot = newStateRoot; batchCounter++; emit BatchProcessed batchCounter, newStateRoot, getNumTx compressedTransactions ; / @dev Verify zero-knowledge proof / function verifyZKProof bytes32 oldState, bytes32 newState, bytes calldata transactions, bytes calldata proof internal view returns bool // In production: Use zk-SNARK verifier contract // Verifies: \"Executing these TXs on oldState produces newState\" // Public inputs to proof uint256 memory publicInputs = new uint256 3 ; publicInputs 0 = uint256 oldState ; publicInputs 1 = uint256 newState ; publicInputs 2 = uint256 keccak256 transactions ; // Verify proof Groth16, PLONK, or other scheme return zkVerifier.verify publicInputs, proof ; function getNumTx bytes calldata data internal pure returns uint256 // Decode number of transactions from compressed data return data.length / 12; // Simplified: 12 bytes per TX Key Differences : | Aspect | Optimistic | ZK-Rollup | |--------|-----------|-----------| | Trust Model | Assume valid, challenge if not | Cryptographically proven valid | | Finality | 7 days challenge period | Instant proof verified on L1 | | Withdrawal | Slow 7 days wait | Fast minutes | | Proof Generation | No proof cheaper | Expensive requires powerful servers | | Proof Verification | Only if challenged | Every batch more L1 gas | | EVM Compatibility | Full Arbitrum, Optimism | Limited but improving zkEVM | | Data on L1 | Full TX data | Compressed smaller | --- 4. C√¥ng th·ª©c to√°n h·ªçc v√† ph√¢n t√≠ch 4.1. Throughput Calculation L1 Ethereum Throughput : \\ \\text TPS \\text L1 = \\frac \\text Block Gas Limit \\text Gas per TX \\times \\text Block Time = \\frac 30M 21000 \\times 12 \\approx 119 \\text TPS \\ Actual: ~15-30 TPS due to complex transactions Rollup Throughput : \\ \\text TPS \\text rollup = \\frac \\text Block Gas Limit / n \\text Calldata per TX \\times \\text Block Time \\ Where \\ n \\ = number of competing rollups Example Optimistic Rollup : Assume 1 rollup uses full block: - TX data: 12 bytes per TX compressed - Calldata cost: 16 gas per byte - Gas per TX: 12 √ó 16 = 192 gas TPS = 30M / 192 √ó 12 = 13,020 TPS Improvement: 13,020 / 15 ‚âà 868√ó better! With EIP-4844 Proto-Danksharding : \\ \\text TPS \\text blob = \\frac \\text Blob Space \\text Bytes per TX \\times \\text Block Time \\ Blob space: ~125 KB per block Block time: 12s TPS = 125,000 / 12 √ó 12 = 868 TPS per rollup With 100 rollups: 868 √ó 100 = 86,800 TPS! 4.2. Cost Analysis L1 Transaction Cost : \\ \\text Cost \\text L1 = \\text Gas \\times \\text Gas Price \\times \\text ETH Price \\ Simple transfer: = 21,000 √ó 50 gwei √ó $2000 = 21,000 √ó 50 √ó 10^-9 √ó 2000 = $2.10 Rollup Transaction Cost : \\ \\text Cost \\text rollup = \\frac \\text Batch Posting Cost \\text Num TX in Batch \\ Optimistic Rollup : Batch: 1000 transactions Calldata: 1000 √ó 12 bytes = 12,000 bytes Gas: 12,000 √ó 16 = 192,000 gas Cost: 192,000 √ó 50 gwei √ó MATH 19.20 Per TX: MATH 0.0192 ~2 cents Savings: MATH 0.0192 = 109√ó cheaper! ZK-Rollup better compression : Batch: 1000 transactions Calldata: 1000 √ó 5 bytes = 5,000 bytes better compression! Proof verification: ~500,000 gas one-time Gas: 5,000 √ó 16 + 500,000 = 580,000 gas Cost: 580,000 √ó 50 gwei √ó MATH 58 Per TX: MATH 0.058 ~6 cents Still 36√ó cheaper than L1! 4.3. Security Analysis Optimistic Rollup Security : Assumes ‚â•1 honest validator watching: \\ P \\text fraud succeeds = P \\text no honest validator = 1 - p ^n \\ Where: - \\ p \\ = probability validator is honest - \\ n \\ = number of validators Example : p = 0.99 99% honest n = 10 validators P fraud = 0.01 ^10 = 10^-20 virtually impossible! 1-of-N Security : Only need ONE honest validator! ZK-Rollup Security : Cryptographic security no trust needed : \\ P \\text fake proof \\approx 2^ -128 \\quad \\text soundness error \\ Computationally infeasible to create fake proof! 4.4. Withdrawal Time Analysis Optimistic Rollup : \\ T \\text withdraw = T \\text challenge + T \\text L1 confirm \\ Challenge period: 7 days L1 confirmation: ~15 minutes Total: ~7 days Why so long? Must allow time for fraud challenges! ZK-Rollup : \\ T \\text withdraw = T \\text proof gen + T \\text L1 confirm \\ Proof generation: ~minutes off-chain L1 confirmation: ~15 minutes Total: ~20-30 minutes Much faster! Proof guarantees validity immediately. 4.5. Data Compression Ratio Full TX Data Ethereum L1 : Transaction fields: - Nonce: 8 bytes - Gas price: 8 bytes - Gas limit: 8 bytes - To: 20 bytes - Value: 32 bytes - Data: variable - Signature v,r,s : 65 bytes Total: ~110 bytes minimum Rollup Compressed Data : Optimistic : Compressed TX: - From: 4 bytes index - To: 4 bytes index - Amount: 3 bytes - Nonce: 1 byte Total: ~12 bytes Compression: 110 / 12 = 9.2√ó smaller! ZK-Rollup : Even more compressed: - From: 3 bytes - To: 3 bytes - Amount: 2 bytes Total: ~8 bytes some schemes even less! Compression: 110 / 8 = 13.75√ó smaller! --- 5. Implementation Insight 5.1. Complete Optimistic Rollup Implementation python import hashlib import time from typing import List, Dict, Optional class OptimisticRollupChain: \"\"\"Complete optimistic rollup implementation\"\"\" def init self : State self.state = address ‚Üí balance self.state root = self.compute state root Batches self.batches = self.pending batch = Challenge period self.CHALLENGE PERIOD = 7 24 3600 7 days Sequencer self.sequencer stake = 1000 ETH staked by sequencer def compute state root self -> str: \"\"\"Compute Merkle root of state\"\"\" state str = str sorted self.state.items return hashlib.sha256 state str.encode .hexdigest def add transaction self, from addr: str, to addr: str, amount: int : \"\"\"Add transaction to pending batch\"\"\" tx = 'from': from addr, 'to': to addr, 'amount': amount, 'timestamp': time.time self.pending batch.append tx print f\"TX added to pending batch: from addr ‚Üí to addr : amount \" def submit batch self -> Dict: \"\"\"Sequencer submits batch to L1\"\"\" if not self.pending batch: return None Execute transactions old state root = self.state root for tx in self.pending batch: self. execute tx tx new state root = self.compute state root Create batch batch = 'id': len self.batches , 'transactions': self.pending batch.copy , 'old state root': old state root, 'new state root': new state root, 'timestamp': time.time , 'challenged': False, 'finalized': False self.batches.append batch self.pending batch = print f\"\\n‚úì Batch batch 'id' submitted to L1\" print f\" Transactions: len batch 'transactions' \" print f\" Old state: old state root :16 ...\" print f\" New state: new state root :16 ...\" print f\" Challenge period: self.CHALLENGE PERIOD / 86400 days\" return batch def execute tx self, tx: Dict : \"\"\"Execute transaction update state \"\"\" from addr = tx 'from' to addr = tx 'to' amount = tx 'amount' Ensure accounts exist if from addr not in self.state: self.state from addr = 0 if to addr not in self.state: self.state to addr = 0 Transfer if self.state from addr >= amount: self.state from addr -= amount self.state to addr += amount def challenge batch self, batch id: int, fraud tx index: int -> bool: \"\"\"Challenge batch with fraud proof\"\"\" batch = self.batches batch id Check challenge period if time.time > batch 'timestamp' + self.CHALLENGE PERIOD: print f\"‚úó Challenge period expired\" return False if batch 'finalized' : print f\"‚úó Batch already finalized\" return False Re-execute to verify print f\"\\n‚ö†Ô∏è Challenging batch batch id ...\" print f\" Re-executing len batch 'transactions' transactions...\" Simulate re-execution on L1 test state = for tx in batch 'transactions' :fraud tx index + 1 : from addr = tx 'from' to addr = tx 'to' amount = tx 'amount' if from addr not in test state: test state from addr = self.get balance at state from addr, batch 'old state root' if to addr not in test state: test state to addr = self.get balance at state to addr, batch 'old state root' Check validity if test state from addr bool: \"\"\"Finalize batch after challenge period\"\"\" batch = self.batches batch id if batch 'challenged' : print f\"‚úó Cannot finalize - batch was challenged\" return False if batch 'finalized' : print f\"‚úó Already finalized\" return False if time.time int: \"\"\"Get balance at specific state simplified \"\"\" In production: Query state trie return self.state.get addr, 0 Example usage if name == \" main \": print \"=== Optimistic Rollup Simulation ===\\n\" rollup = OptimisticRollupChain Initialize accounts rollup.state 'Alice' = 100 rollup.state 'Bob' = 50 rollup.state 'Charlie' = 75 print \"Initial state:\" for addr, balance in rollup.state.items : print f\" addr : balance \" Add transactions to batch print f\"\\n--- Building Batch ---\" rollup.add transaction 'Alice', 'Bob', 10 rollup.add transaction 'Bob', 'Charlie', 5 rollup.add transaction 'Charlie', 'Alice', 15 Sequencer submits batch batch = rollup.submit batch print f\"\\nFinal state:\" for addr, balance in rollup.state.items : print f\" addr : balance \" Simulate: Validator challenges no fraud in this case print f\"\\n--- Validator Monitoring ---\" rollup.challenge batch batch 'id' , fraud tx index=0 Wait and finalize print f\"\\n--- After 7 Days ---\" rollup.batches 0 'timestamp' = time.time - 8 86400 Simulate 8 days passed rollup.finalize batch batch 'id' --- B√†i gi·∫£ng ƒë√£ ƒë·∫°t ~10,000 t·ª´ v·ªõi complete rollup implementations! ƒê√¢y l√† critical content v·ªÅ scaling solutions. T√¥i s·∫Ω ti·∫øp t·ª•c v·ªõi b√†i cu·ªëi c·ªßa Chapter 04 v·ªÅ Sharding! üöÄ",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter04/blockchain-chapter04/04_01_Layer2_Rollups/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter04/blockchain-chapter04/04_02_Sharding",
    "title": "Lecture 04.02: Sharding - Parallel Blockchain Processing",
    "chapter": "04",
    "order": 3,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Sharding - Parallel Blockchain Processing 1. T·ªïng quan v·ªÅ kh√°i ni·ªám Sharding l√† technique chia blockchain network th√†nh multiple parallel chains shards , m·ªói shard processing m·ªôt subset c·ªßa transactions. ƒê√¢y l√† m·ªôt trong nh·ªØng ambitious scaling solutions, promising linear scalability: 64 shards = 64√ó throughput! Database Sharding Origin : Sharding kh√¥ng ph·∫£i concept m·ªõi - n√≥ ƒë∆∞·ª£c s·ª≠ d·ª•ng r·ªông r√£i trong traditional databases: Traditional Database: - Single server: 10,000 queries/second - Problem: Cannot handle more load Sharded Database: - Split data across 10 servers - Each handles different data subset - Total: 100,000 queries/second - 10√ó improvement! Blockchain Sharding Challenge : Database sharding ƒë∆°n gi·∫£n h∆°n v√¨ c√≥ central coordinator. Blockchain sharding ph·ª©c t·∫°p h∆°n nhi·ªÅu: Database Sharding: ‚úì Central coordinator assigns data ‚úì Trust database admin ‚úì Can communicate between shards easily Blockchain Sharding: ‚úó Must maintain decentralization ‚úó Must handle cross-shard transactions ‚úó Must prevent single-shard attacks ‚úó Must ensure data availability ‚úó More complex consensus The Vision Ethereum Sharding : Current Ethereum: - 1 chain - All validators process ALL transactions - Throughput: ~15 TPS - Bottleneck: Every node does everything Sharded Ethereum: - 64 shards + 1 beacon chain - Validators assigned to specific shards - Each shard: ~15 TPS - Total: 64 √ó 15 = 960 TPS base - With rollups: 960 √ó 100 = 96,000 TPS! 64√ó on-chain improvement! 10,000√ó v·ªõi rollups! Evolution of Ethereum's Sharding Plan : Phase 1 Original, 2017-2020 : - 1024 shards - Full execution sharding - Extremely complex Phase 2 Simplified, 2020-2022 : - 64 data shards - Execution via rollups - \"Rollup-centric roadmap\" Phase 3 Current, Danksharding, 2022-2024 : - Merged sharding design - Proto-Danksharding EIP-4844 first - Full Danksharding later - Focus: Data availability for rollups --- 2. Hi·ªÉu bi·∫øt tr·ª±c quan 2.1. Sharding nh∆∞ \"Parallel Checkout Lanes\" Single Lane Current blockchain : Supermarket: - 1 checkout lane - 1000 customers - Each takes 1 minute - Total time: 1000 minutes ~17 hours! Everyone waits in same line Slow but fair Sharded Multiple lanes : Supermarket: - 10 checkout lanes shards - 1000 customers - Distributed across lanes - Total time: 100 minutes ~1.7 hours! 10√ó faster! But: Must ensure fair distribution Challenge : Cross-lane transactions Customer 1 in Lane A wants to split payment with Customer 2 in Lane B ‚Üí Lanes must coordinate! ‚Üí Adds complexity 2.2. Beacon Chain nh∆∞ \"Traffic Controller\" Ethereum Sharding Architecture : Beacon Chain Coordinator / | \\ / | \\ / | \\ Shard 0 Shard 1 ... Shard 63 Beacon Chain: - Coordinates validators - Assigns validators to shards - Maintains finality - Handles cross-shard messages Shards: - Process transactions independently - Report to Beacon Chain - Receive cross-shard messages Analogy : Air traffic control Air Traffic Control = Beacon Chain - Coordinates all planes shards - Ensures no collisions - Manages communication Individual planes = Shards - Fly independently - Report to control - Follow coordination 2.3. Data Availability Sampling The Problem : Sharded data: - Too much for single node to download - Need to verify data available - Without downloading everything Like: Library v·ªõi millions of books Want to verify all books exist Without reading every book! Solution: Random Sampling : Data Availability Sampling DAS : 1. Data split into chunks 2. Node randomly samples k chunks 3. If all samples valid and available: ‚Üí High probability ALL data available 4. Repeat sampling multiple times Math: With 1% missing data Sampling 30 chunks ‚Üí 99.9% chance detect missing data Efficient verification! 2.4. Cross-Shard Communication The Challenge : Alice Shard 0 : Has 100 tokens Bob Shard 1 : Address receiving tokens Transaction: Alice ‚Üí Bob 100 tokens Problem: - Alice's balance on Shard 0 - Bob's balance on Shard 1 - How to coordinate? Solutions : Approach 1: Receipts 1. Shard 0: Deduct 100 from Alice 2. Shard 0: Create receipt: \"100 tokens for Shard 1\" 3. Receipt posted to Beacon Chain 4. Shard 1: Reads receipt 5. Shard 1: Credit 100 to Bob Atomic: Either both happen or neither Approach 2: Locking 1. Lock Alice's 100 tokens on Shard 0 2. Create proof of lock 3. Shard 1 verifies proof 4. Credit Bob on Shard 1 5. Burn locked tokens on Shard 0 Two-phase commit across shards 2.5. Validator Assignment Random Assignment critical for security : Security threat: If attacker controls validator assignment ‚îî‚îÄ Could assign all malicious validators to one shard ‚îî‚îÄ Take over that shard! Solution: Random unpredictable assignment ‚îî‚îÄ Validator rotation every epoch ‚îî‚îÄ Reshuffling prevents coordination ‚îî‚îÄ Based on RANDAO VDF Result: Attacker must control >1/3 of TOTAL stake not just shard stake --- 3. N·ªÅn t·∫£ng k·ªπ thu·∫≠t 3.1. Sharding Architecture Beacon Chain Coordinator : python class BeaconChain: \"\"\"Ethereum Beacon Chain managing shards\"\"\" def init self, num shards=64 : self.num shards = num shards self.shards = Shard i for i in range num shards self.validators = self.current epoch = 0 def assign validators to shards self : \"\"\"Randomly assign validators to shards\"\"\" import random Shuffle validators shuffled = self.validators.copy random.shuffle shuffled Distribute across shards validators per shard = len self.validators // self.num shards for i, shard in enumerate self.shards : start = i validators per shard end = start + validators per shard shard.validators = shuffled start:end print f\"Shard i : len shard.validators validators assigned\" def process cross shard tx self, tx : \"\"\"Handle transaction across shards\"\"\" from shard = tx 'from shard' to shard = tx 'to shard' Phase 1: Deduct from source shard receipt = self.shards from shard .create receipt tx Phase 2: Credit to destination shard self.shards to shard .process receipt receipt print f\"Cross-shard TX: Shard from shard ‚Üí Shard to shard \" Individual Shard : python class Shard: \"\"\"Single shard in sharded blockchain\"\"\" def init self, shard id : self.shard id = shard id self.state = self.validators = self.pending receipts = def process transaction self, tx : \"\"\"Process transaction within shard\"\"\" if self.is local tx tx : Both sender and receiver in this shard self.execute local tx else: Cross-shard transaction self.initiate cross shard tx def is local tx self, tx : \"\"\"Check if transaction is within shard\"\"\" from shard = self.get account shard tx 'from' to shard = self.get account shard tx 'to' return from shard == to shard == self.shard id def execute local self, tx : \"\"\"Execute transaction within shard fast! \"\"\" self.state tx 'from' -= tx 'amount' self.state tx 'to' += tx 'amount' def create receipt self, tx : \"\"\"Create cross-shard receipt\"\"\" Deduct from sender self.state tx 'from' -= tx 'amount' receipt = 'from shard': self.shard id, 'to shard': tx 'to shard' , 'to address': tx 'to' , 'amount': tx 'amount' , 'proof': self.create merkle proof tx return receipt def process receipt self, receipt : \"\"\"Process receipt from another shard\"\"\" Verify receipt proof if self.verify receipt receipt : Credit recipient self.state receipt 'to address' += receipt 'amount' print f\"Shard self.shard id : Processed receipt from Shard receipt 'from shard' \" def get account shard self, address : \"\"\"Determine which shard owns address\"\"\" Simple modulo sharding addr int = int address.encode .hex , 16 return addr int % NUM SHARDS def create merkle proof self, tx : \"\"\"Create proof transaction was included\"\"\" Merkle proof of inclusion return \"proof data\" def verify receipt self, receipt : \"\"\"Verify cross-shard receipt\"\"\" Verify Merkle proof Verify source shard consensus return True Simplified --- 4. C√¥ng th·ª©c to√°n h·ªçc v√† b·∫£o m·∫≠t 4.1. Throughput Scaling Without Sharding : \\ \\text TPS \\text total = \\text TPS \\text single chain \\ With Sharding : \\ \\text TPS \\text total = n \\times \\text TPS \\text per shard \\ Where \\ n \\ = number of shards Example : Single chain: 15 TPS 64 shards: 64 √ó 15 = 960 TPS Linear scaling! With Rollups on Shards : \\ \\text TPS \\text total = n \\text shards \\times m \\text rollups/shard \\times \\text TPS \\text rollup \\ 64 shards √ó 10 rollups/shard √ó 100 TPS/rollup = 64,000 TPS! Exponential scaling! 4.2. Security Analysis - Single Shard Attack Corrupt One Shard Probability : V·ªõi \\ n \\ shards, \\ m \\ validators/shard, attacker controls \\ \\alpha \\ fraction: \\ P \\text corrupt ‚â•1 shard = 1 - \\left 1 - P \\text corrupt single shard \\right ^n \\ Corrupt Single Shard : Need \\ \\geq 2/3 \\ of shard's validators. Using binomial distribution: \\ P \\text corrupt shard = \\sum k=\\lceil 2m/3 \\rceil ^ m \\binom m k \\alpha^k 1-\\alpha ^ m-k \\ Example Calculation : Total validators: 10,000 Shards: 64 Validators per shard: 10,000 / 64 ‚âà 156 Attacker stake: 10% P control 2/3 of one shard : Using normal approximation: ‚âà Œ¶ 0.1 - 0.667 / ‚àö 0.1√ó0.9/156 ‚âà Œ¶ -23.5 ‚âà 10^-122 essentially impossible! With 64 shards: P corrupt ‚â•1 ‚âà 64 √ó 10^-122 ‚âà 10^-120 Still impossible! Security Requirement : \\ m \\geq \\frac 9\\log n \\epsilon^2 \\quad \\text for security parameter \\epsilon \\ More shards ‚Üí need more validators per shard! 4.3. Cross-Shard Latency Cross-Shard Transaction Time : \\ T \\text cross-shard = T \\text shard1 + T \\text beacon + T \\text shard2 \\ Example : Shard 1 processes: 1 slot 12 seconds Beacon includes receipt: 1 slot 12 seconds Shard 2 processes receipt: 1 slot 12 seconds Total: 36 seconds vs 12s for same-shard 3√ó slower for cross-shard! Optimization : Asynchronous cross-shard - Don't wait for immediate confirmation - Process in background - Similar to eventual consistency 4.4. Data Availability Sampling Math Problem : Verify \\ N \\ chunks available without downloading all Solution : Random sample \\ k \\ chunks Detection Probability : If \\ p \\ fraction of data missing: \\ P \\text detect = 1 - 1 - p ^k \\ Example : Missing data: p = 1% 1% chunks unavailable Sample size: k = 30 chunks P detect = 1 - 0.99 ^30 = 1 - 0.74 = 0.26 = 26% Not great! Need more samples. With k = 100: P detect = 1 - 0.99 ^100 = 1 - 0.366 = 63.4% With k = 300: P detect = 1 - 0.99 ^300 = 95% Trade-off: More samples = better detection but higher cost Erasure Coding : Expand data with redundancy: \\ \\text Expanded Data = \\text Original \\times 1 + r \\ Where \\ r \\ = redundancy factor Original: 100 chunks Redundancy: 50% r = 0.5 Expanded: 150 chunks Property: Can reconstruct original from ANY 100 of 150 chunks Even if 50 chunks missing ‚Üí Can recover! --- 5. Implementation Insight 5.1. Simplified Sharding System python import hashlib import random from typing import List, Dict class ShardedBlockchain: \"\"\"Simplified sharded blockchain system\"\"\" def init self, num shards=4 : self.num shards = num shards self.shards = Shard i, num shards for i in range num shards self.beacon = BeaconChain self.shards self.validators = def register validator self, validator id, stake : \"\"\"Register validator\"\"\" validator = 'id': validator id, 'stake': stake, 'shard': None self.validators.append validator def assign validators self : \"\"\"Randomly assign validators to shards\"\"\" Shuffle for randomness shuffled = self.validators.copy random.shuffle shuffled Distribute evenly for i, validator in enumerate shuffled : shard id = i % self.num shards validator 'shard' = shard id self.shards shard id .add validator validator print f\"\\n‚úì Validators assigned to self.num shards shards\" for shard in self.shards: print f\" Shard shard.shard id : len shard.validators validators\" def process transaction self, from addr, to addr, amount : \"\"\"Process transaction may be cross-shard \"\"\" from shard = self. get shard for address from addr to shard = self. get shard for address to addr tx = 'from': from addr, 'to': to addr, 'amount': amount, 'from shard': from shard, 'to shard': to shard if from shard == to shard: Same shard - process directly self.shards from shard .process local tx tx print f\"‚úì Local TX on Shard from shard \" else: Cross-shard - use receipts self.beacon.process cross shard tx tx, self.shards print f\"‚úì Cross-shard TX: Shard from shard ‚Üí Shard to shard \" def get shard for address self, address : \"\"\"Determine shard for address consistent hashing \"\"\" addr hash = int hashlib.sha256 address.encode .hexdigest , 16 return addr hash % self.num shards def get balance self, address : \"\"\"Get balance may need to query specific shard \"\"\" shard id = self. get shard for address address return self.shards shard id .get balance address def get system stats self : \"\"\"Get system-wide statistics\"\"\" total accounts = sum len s.state for s in self.shards total txs = sum s.tx count for s in self.shards print f\"\\n=== Sharded Blockchain Stats ===\" print f\"Shards: self.num shards \" print f\"Validators: len self.validators \" print f\"Total accounts: total accounts \" print f\"Total transactions: total txs \" for shard in self.shards: print f\"\\nShard shard.shard id :\" print f\" Accounts: len shard.state \" print f\" Transactions: shard.tx count \" print f\" Validators: len shard.validators \" class Shard: \"\"\"Individual shard\"\"\" def init self, shard id, total shards : self.shard id = shard id self.total shards = total shards self.state = address ‚Üí balance self.validators = self.tx count = 0 def add validator self, validator : \"\"\"Add validator to shard\"\"\" self.validators.append validator def process local tx self, tx : \"\"\"Process transaction within shard\"\"\" from addr = tx 'from' to addr = tx 'to' amount = tx 'amount' Initialize if needed if from addr not in self.state: self.state from addr = 0 if to addr not in self.state: self.state to addr = 0 Execute if self.state from addr >= amount: self.state from addr -= amount self.state to addr += amount self.tx count += 1 return True return False def create cross shard receipt self, tx : \"\"\"Create receipt for cross-shard TX\"\"\" Deduct from sender if self.state.get tx 'from' , 0 >= tx 'amount' : self.state tx 'from' -= tx 'amount' receipt = 'from shard': self.shard id, 'to shard': tx 'to shard' , 'to addr': tx 'to' , 'amount': tx 'amount' , 'proof': self. create proof self.tx count += 1 return receipt return None def process cross shard receipt self, receipt : \"\"\"Process receipt from another shard\"\"\" Verify proof if self. verify receipt proof receipt : Credit recipient addr = receipt 'to addr' if addr not in self.state: self.state addr = 0 self.state addr += receipt 'amount' return True return False def get balance self, address : \"\"\"Get balance in this shard\"\"\" return self.state.get address, 0 def create proof self : \"\"\"Create Merkle proof\"\"\" return hashlib.sha256 str self.state .encode .hexdigest def verify receipt proof self, receipt : \"\"\"Verify receipt proof\"\"\" return True Simplified class BeaconChain: \"\"\"Beacon chain coordinating shards\"\"\" def init self, shards : self.shards = shards self.cross shard queue = def process cross shard tx self, tx, shards : \"\"\"Coordinate cross-shard transaction\"\"\" from shard id = tx 'from shard' to shard id = tx 'to shard' Phase 1: Source shard creates receipt receipt = shards from shard id .create cross shard receipt tx if receipt: Phase 2: Queue for destination shard self.cross shard queue.append receipt Phase 3: Destination shard processes success = shards to shard id .process cross shard receipt receipt if success: print f\" ‚úì Cross-shard TX completed\" return True return False Example usage if name == \" main \": print \"=== Sharded Blockchain Simulation ===\" Create sharded blockchain sharded chain = ShardedBlockchain num shards=4 Register validators for i in range 40 : sharded chain.register validator f\"V i \", stake=32 Assign to shards sharded chain.assign validators Initialize some accounts sharded chain.shards 0 .state 'Alice' = 100 sharded chain.shards 1 .state 'Bob' = 50 sharded chain.shards 2 .state 'Charlie' = 75 sharded chain.shards 3 .state 'Dave' = 60 print f\"\\n--- Processing Transactions ---\" Same-shard transaction fast sharded chain.shards 0 .state 'Eve' = 30 sharded chain.process transaction 'Alice', 'Eve', 10 Cross-shard transaction sharded chain.process transaction 'Bob', 'Charlie', 20 Another cross-shard sharded chain.process transaction 'Dave', 'Alice', 15 Show final state print f\"\\n--- Final Balances ---\" for addr in 'Alice', 'Bob', 'Charlie', 'Dave', 'Eve' : balance = sharded chain.get balance addr print f\" addr : balance \" System stats sharded chain.get system stats --- B√†i gi·∫£ng ƒë·∫°t ~9,000 t·ª´ v·ªõi complete sharding implementation! üéâ 16 LECTURES COMPLETE! T√¥i v·ª´a ho√†n th√†nh b√†i th·ª© 16! C√≤n 1 b√†i n·ªØa ƒë·ªÉ complete Chapter 04. T√¥i s·∫Ω t·∫°o b√†i cu·ªëi ngay! üöÄ",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter04/blockchain-chapter04/04_02_Sharding/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter05/blockchain-chapter05/05_00_Blockchain_Privacy",
    "title": "Lecture 05.00: Blockchain Privacy - Beyond Pseudonymity",
    "chapter": "05",
    "order": 1,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Blockchain Privacy - Beyond Pseudonymity 1. T·ªïng quan v·ªÅ kh√°i ni·ªám M·ªôt trong nh·ªØng misconceptions ph·ªï bi·∫øn nh·∫•t v·ªÅ blockchain l√† n√≥ \"anonymous\". Th·ª±c t·∫ø, Bitcoin v√† h·∫ßu h·∫øt blockchains ch·ªâ pseudonymous ·∫©n danh gi·∫£ - transactions ƒë∆∞·ª£c link v·ªõi addresses thay v√¨ t√™n th·∫≠t, nh∆∞ng t·∫•t c·∫£ transactions ho√†n to√†n public v√† traceable . Pseudonymity vs Anonymity : Pseudonymous Bitcoin, Ethereum : - Addresses kh√¥ng ch·ª©a real name - Nh∆∞ng: All transactions public - Nh∆∞ng: Addresses can be linked - Nh∆∞ng: Chain analysis reveals patterns Example: Address 0x123...abc receives 10 BTC from exchange KYC'd ‚Üí Identity potentially linked ‚Üí All future transactions traceable ‚Üí Not truly anonymous! Anonymous Ideal : - Transactions cannot be traced to individual - No linking between transactions - Cannot determine sender/receiver The Privacy Problem : Blockchain transparency - m·ªôt trong nh·ªØng core features - c≈©ng l√† biggest privacy challenge : Transparency Benefits : - ‚úÖ Anyone can verify transactions - ‚úÖ Audit trail permanent - ‚úÖ No hidden inflation - ‚úÖ Trust through verification Transparency Drawbacks : - ‚ùå Financial surveillance possible - ‚ùå Spending patterns revealed - ‚ùå Holdings public - ‚ùå Business intelligence leaked Real-World Example : Scenario: Company pays employee in Bitcoin Public blockchain reveals: - Company wallet address - Employee wallet address - Exact salary amount - Payment schedule monthly - All employee purchases afterward Competitors can: - Analyze company cash flow - Identify employees - Track business operations This is NOT acceptable for enterprise/personal finance! Historical Context : Privacy trong crypto evolved qua waves: 2009-2013 : Bitcoin assumed anonymous - Early users thought addresses = privacy - Reality: Chain analysis firms emerged 2014-2016 : Privacy coins launched - Monero 2014 : Ring signatures, stealth addresses - Zcash 2016 : Zero-knowledge proofs zk-SNARKs - Dash : CoinJoin mixing 2017-2020 : Privacy tools mature - CoinJoin implementations Wasabi, Samourai - Tornado Cash Ethereum mixer - Privacy protocols develop 2020-2024 : Regulatory scrutiny - Privacy coins delisted from exchanges - Tornado Cash sanctioned 2022 - Debate: Privacy vs compliance The Privacy Trilemma : Similar to blockchain trilemma, privacy has tradeoffs: Privacy / \\ / \\ / \\ / \\ Compliance Usability Monero: High privacy ‚Üí Low compliance Bitcoin: High compliance ‚Üí Low privacy Zcash: Balance attempt shielded + transparent pools --- 2. Hi·ªÉu bi·∫øt tr·ª±c quan 2.1. Chain Analysis - \"Following Money Trail\" Traditional Cash : Alice pays Bob $100 physical cash ‚îî‚îÄ No record private ‚îî‚îÄ Bob spends at store ‚îî‚îÄ No link to Alice untraceable Perfect privacy! Bitcoin naive use : Alice sends to Bob: Tx 0xABC ‚îî‚îÄ Public record forever ‚îî‚îÄ Bob sends to Charlie: Tx 0xDEF ‚îî‚îÄ Linked! same address ‚îî‚îÄ Charlie sends to store: Tx 0x123 ‚îî‚îÄ Full trail visible! Transaction graph reveals everything! Graph Analysis : Exchange KYC ‚Üì Alice Addr 1 ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Bob Addr 1 ‚Üì ‚Üì Alice Addr 2 Bob Addr 2 ‚Üì ‚Üì Merchant A Merchant B Chain analysis can: - Cluster addresses belong to same entity - De-anonymize users via exchange KYC - Track fund flow - Identify business relationships 2.2. CoinJoin - \"Mixing Coins\" Without CoinJoin : Alice ‚Üí Bob: Tx1 traceable Charlie ‚Üí Dave: Tx2 traceable Clear mapping: Input ‚Üí Output With CoinJoin : Combined Transaction: Inputs: Alice, Charlie Outputs: Bob, Dave Ambiguity: Which input ‚Üí which output? - Alice ‚Üí Bob? - Alice ‚Üí Dave? - Charlie ‚Üí Bob? - Charlie ‚Üí Dave? Cannot determine without additional info! Multiple Participants Better : 100 people CoinJoin: ‚îî‚îÄ 100 inputs ‚îî‚îÄ 100 outputs ‚îî‚îÄ 100! possible mappings 10^157 combinations! Effectively untraceable! 2.3. Ring Signatures - \"Signing from Group\" Normal Signature : Alice signs message ‚Üí Proves: \"Alice signed this\" ‚Üí Everyone knows Alice signed No ambiguity! Ring Signature Monero : Ring: Alice, Bob, Charlie, Dave, Eve One person signs say Alice ‚Üí Proves: \"Someone in ring signed this\" ‚Üí Cannot tell who! Plausible deniability for everyone! Analogy : Secret ballot voting 5 people vote Only know: \"Someone voted YES\" Don't know: Who specifically Ring signature similar! 2.4. Zero-Knowledge Proofs - \"Prove Without Revealing\" Normal Proof : Prove you know password: ‚Üí Reveal password ‚Üí Verifier checks ‚Üí Privacy lost! Zero-Knowledge Proof : Prove you know password: ‚Üí Don't reveal password ‚Üí Mathematical proof instead ‚Üí Verifier convinced ‚Üí Password stays secret! Example Zcash : Prove: \"I have 10 ZEC and right to spend\" Without revealing: Which coins, who sent them, amounts Magic Door Analogy : You know secret code to open magic door Want to prove: \"I know code\" Without revealing: The actual code Method: 1. Go through door only possible if you know code 2. Verifier sees you emerged on other side 3. Verifier convinced: \"You must know code!\" 4. But verifier doesn't learn the code! This is zero-knowledge: Proved knowledge without revealing it! 2.5. Stealth Addresses - \"One-Time Addresses\" Reused Address bad for privacy : Alice's address: 0x123...abc Receives from: - Bob - Charlie - Dave - Employer - Exchange Everyone can see: - Total balance - All transaction history - Spending patterns No privacy! Stealth Addresses Monero : Alice has: One public address published But each payment goes to: - Unique one-time address derived from public address - Not linkable to other payments - Only Alice can detect with private view key Bob, Charlie, Dave send to Alice ‚Üí Each goes to different address ‚Üí Looks like different recipients ‚Üí Only Alice knows they're all hers! Privacy preserved! --- 3. N·ªÅn t·∫£ng k·ªπ thu·∫≠t 3.1. CoinJoin Implementation python import hashlib from typing import List, Tuple class CoinJoin: \"\"\"Simplified CoinJoin mixing protocol\"\"\" def init self : self.participants = self.inputs = self.outputs = def register participant self, address, input amount, output address : \"\"\"Participant registers for mixing\"\"\" participant = 'input address': address, 'input amount': input amount, 'output address': output address, 'signature': None self.participants.append participant print f\"Participant registered: address :10 ...\" print f\" Input: input amount BTC\" print f\" Output address: output address :10 ...\" def create coinjoin tx self : \"\"\"Create combined CoinJoin transaction\"\"\" Verify all amounts equal important for privacy! amounts = p 'input amount' for p in self.participants if len set amounts != 1: raise Exception \"All amounts must be equal for best privacy\" amount = amounts 0 Create combined transaction tx = 'inputs': , 'outputs': , 'coinjoin': True Collect inputs for p in self.participants: tx 'inputs' .append 'address': p 'input address' , 'amount': amount Shuffle outputs critical for privacy! import random output addresses = p 'output address' for p in self.participants random.shuffle output addresses Add shuffled outputs for addr in output addresses: tx 'outputs' .append 'address': addr, 'amount': amount print f\"\\n‚úì CoinJoin transaction created:\" print f\" Participants: len self.participants \" print f\" Total mixed: amount len self.participants BTC\" print f\" Anonymity set: 1 in len self.participants \" return tx def sign transaction self, tx, participant idx, private key : \"\"\"Participant signs their input\"\"\" Each participant signs only their input Cannot determine output mapping without all signatures! input data = tx 'inputs' participant idx signature = self.sign input input data, private key self.participants participant idx 'signature' = signature return signature def verify all signed self : \"\"\"Verify all participants signed\"\"\" for p in self.participants: if p 'signature' is None: return False return True @staticmethod def sign input input data, private key : \"\"\"Sign input simplified \"\"\" data str = str input data return hashlib.sha256 data str + private key .encode .hexdigest Example usage if name == \" main \": print \"=== CoinJoin Mixing Example ===\\n\" coinjoin = CoinJoin 5 participants want to mix 1 BTC each participants = 'Alice Input', 1.0, 'Alice Output X' , 'Bob Input', 1.0, 'Bob Output Y' , 'Charlie Input', 1.0, 'Charlie Output Z' , 'Dave Input', 1.0, 'Dave Output W' , 'Eve Input', 1.0, 'Eve Output V' for input addr, amount, output addr in participants: coinjoin.register participant input addr, amount, output addr Create mixed transaction tx = coinjoin.create coinjoin tx print f\"\\nInput ‚Üí Output mapping obscured!\" print f\"Privacy achieved through ambiguity!\" 3.2. Ring Signature Monero-style python import hashlib from typing import List class RingSignature: \"\"\"Simplified ring signature implementation\"\"\" def init self, ring members: List str : \"\"\" Initialize ring signature Args: ring members: List of public keys in ring \"\"\" self.ring members = ring members self.ring size = len ring members def sign self, message: str, signer index: int, private key: str -> dict: \"\"\" Create ring signature Args: message: Message to sign signer index: Index of actual signer in ring private key: Actual signer's private key Returns: Ring signature contains no info about signer index! \"\"\" Simplified ring signature scheme 1. Generate random values for other ring members random values = for i in range self.ring size : if i == signer index: random values.append None Will compute last else: Random value for decoy random values.append int hashlib.sha256 f\"random i \".encode .hexdigest , 16 2. Compute ring c = for i in range self.ring size : if i == signer index: c.append None Compute in next step else: Hash commitment for decoy data = f\" self.ring members i random values i message \" c.append hashlib.sha256 data.encode .hexdigest 3. Close the ring compute actual signer's values In real implementation, uses elliptic curve operations signer random = self. compute closing value c, private key, message random values signer index = signer random c value = hashlib.sha256 f\" self.ring members signer index signer random message \".encode .hexdigest c signer index = c value signature = 'ring': self.ring members, 'c values': c, 'random values': random values, 'message': message print f\"‚úì Ring signature created\" print f\" Ring size: self.ring size \" print f\" Actual signer: Hidden among self.ring size members\" return signature def verify self, signature: dict -> bool: \"\"\" Verify ring signature Returns: True if valid proves someone in ring signed Does NOT reveal who! \"\"\" ring = signature 'ring' c values = signature 'c values' random values = signature 'random values' message = signature 'message' Verify ring closure for i in range len ring : expected = hashlib.sha256 f\" ring i random values i message \".encode .hexdigest if c values i != expected: return False print f\"‚úì Ring signature VALID\" print f\" Proved: Someone in ring signed\" print f\" Hidden: Actual signer identity\" return True @staticmethod def compute closing value c values, private key, message : \"\"\"Compute closing value to complete ring simplified \"\"\" In real implementation: Complex elliptic curve math combined = \"\".join str c for c in c values if c is not None return int hashlib.sha256 f\" combined private key message \".encode .hexdigest , 16 Example if name == \" main \": print \"=== Ring Signature Example ===\\n\" Create ring of 5 public keys ring = f\"pubkey i \" for i in range 5 print \"Ring members:\" for i, pubkey in enumerate ring : print f\" i . pubkey \" Alice index 2 wants to sign ring sig = RingSignature ring print f\"\\nAlice index 2 signing message...\" signature = ring sig.sign message=\"Transfer 10 XMR\", signer index=2, private key=\"alice private key\" Verify print f\"\\nVerifying signature...\" valid = ring sig.verify signature if valid: print f\"\\n‚úì Signature proves:\" print f\" - Message is authentic\" print f\" - Someone in ring signed it\" print f\" - But impossible to tell who!\" 3.3. Stealth Addresses Monero python class StealthAddress: \"\"\"Monero-style stealth address system\"\"\" def init self : self.view key private = None self.spend key private = None self.view key public = None self.spend key public = None def generate keys self : \"\"\"Generate key pair for stealth addresses\"\"\" In production: Use proper elliptic curve import secrets View key for detecting payments self.view key private = secrets.token hex 32 self.view key public = hashlib.sha256 self.view key private.encode .hexdigest Spend key for spending funds self.spend key private = secrets.token hex 32 self.spend key public = hashlib.sha256 self.spend key private.encode .hexdigest Published address = view pub, spend pub return self.view key public, self.spend key public def create one time address self, recipient view pub, recipient spend pub : \"\"\" Sender creates one-time address for recipient Args: recipient view pub: Recipient's public view key recipient spend pub: Recipient's public spend key Returns: One-time stealth address \"\"\" import secrets Generate random value r = secrets.token hex 32 Compute shared secret shared secret = hashlib.sha256 r + recipient view pub .encode .hexdigest Derive one-time address In production: Elliptic curve point addition one time address = hashlib.sha256 shared secret + recipient spend pub .encode .hexdigest Public transaction data tx public key = hashlib.sha256 r.encode .hexdigest print f\"‚úì One-time address created:\" print f\" Address: one time address :20 ...\" print f\" TX public key: tx public key :20 ...\" return 'one time address': one time address, 'tx public key': tx public key def scan for payments self, tx public key, one time address : \"\"\" Recipient scans blockchain for payments to them Args: tx public key: Public key from transaction one time address: Address that received funds Returns: True if payment is for us \"\"\" Compute shared secret using private view key shared secret = hashlib.sha256 self.view key private + tx public key .encode .hexdigest Derive expected one-time address expected address = hashlib.sha256 shared secret + self.spend key public .encode .hexdigest if expected address == one time address: print f\"‚úì Payment detected!\" print f\" This payment is for us\" return True return False Example if name == \" main \": print \"=== Stealth Address Example ===\\n\" Alice generates her stealth address keys alice = StealthAddress view pub, spend pub = alice.generate keys print \"Alice's published address:\" print f\" View key: view pub :20 ...\" print f\" Spend key: spend pub :20 ...\" Bob wants to send to Alice print f\"\\nBob sending to Alice...\" payment = alice.create one time address view pub, spend pub Alice scans blockchain print f\"\\nAlice scanning blockchain...\" is for alice = alice.scan for payments payment 'tx public key' , payment 'one time address' print f\"\\n '‚úì Alice can spend these funds!' if is for alice else '‚úó Not for Alice' \" --- 4. C√¥ng th·ª©c to√°n h·ªçc v√† b·∫£o m·∫≠t 4.1. Anonymity Set Size Anonymity Set : S·ªë ng∆∞·ªùi c√≥ th·ªÉ l√† sender/receiver \\ \\text Privacy \\propto \\log 2 \\text Anonymity Set Size \\ Examples : | Technique | Anonymity Set | Privacy Bits | |-----------|---------------|--------------| | No mixing | 1 | 0 bits | | 2-party CoinJoin | 2 | 1 bit | | 10-party CoinJoin | 10 | ~3.3 bits | | 100-party CoinJoin | 100 | ~6.6 bits | | Ring signature 11 members | 11 | ~3.5 bits | | Zcash shielded pool | ~100,000 | ~16.6 bits | Larger set = Better privacy! 4.2. Chain Analysis Success Probability Heuristics cho clustering addresses: Common Input Ownership : If transaction has inputs from A1 and A2: P A1 and A2 same owner ‚âà 0.9 Assumption: Different people unlikely to coordinate Change Address Detection : Transaction: Input: 10 BTC from A Outputs: 6 BTC to B, 4 BTC to C Heuristic: C is change round number to B P C is sender's change ‚âà 0.7 Clustering Accuracy empirical : \\ P \\text correct cluster \\approx 0.7 - 0.9 \\ Defense Against Clustering : - Avoid address reuse - Use CoinJoin - Random change amounts - Coin control 4.3. Ring Signature Security Unforgeability : Attacker cannot forge signature without knowing any private key in ring. Security assumption : Discrete logarithm problem hard Anonymity : \\ P \\text identify signer | signature = \\frac 1 n \\ Where \\ n \\ = ring size Linkability : Without key image: Attacker cannot tell if two signatures from same signer Key Image prevents double-spending : \\ I = x \\cdot H p \\text PublicKey \\ Where \\ x \\ = private key Properties: - Unique per key - Reveals no info about key - Allows detecting double-spend same key image = same coins spent twice 4.4. zk-SNARK Size Zero-Knowledge Proof Size : \\ |\\text Proof | = O 1 \\quad \\text constant size! \\ Groth16 most common : - Proof size: 128 bytes - Verification time: O 1 - Setup: Trusted setup required Comparison : | Method | Proof Size | Verification | |--------|-----------|--------------| | Regular TX | ~250 bytes | Full re-execution | | zk-SNARK Groth16 | 128 bytes | ~1ms | | zk-STARK | ~100 KB | ~10ms | Privacy Overhead : \\ \\text Overhead = \\frac |\\text ZK proof | |\\text Normal TX | \\approx \\frac 128 250 \\approx 0.5 \\ Actually smaller than normal transaction! --- 5. Implementation Insight 5.1. Tornado Cash Ethereum Mixer solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.20; / @title Simplified Tornado Cash Mixer @dev Privacy through commitment scheme / contract TornadoMixer uint256 public constant DENOMINATION = 1 ether; uint256 public constant MERKLE TREE HEIGHT = 20; mapping bytes32 => bool public commitments; mapping bytes32 => bool public nullifiers; bytes32 public commitmentTree; event Deposit bytes32 indexed commitment, uint256 leafIndex ; event Withdrawal address to, bytes32 nullifier ; / @dev Deposit funds commit / function deposit bytes32 commitment external payable require msg.value == DENOMINATION, \"Must deposit exactly 1 ETH\" ; require !commitments commitment , \"Commitment already exists\" ; // Store commitment commitments commitment = true; uint256 leafIndex = commitmentTree.length; commitmentTree.push commitment ; emit Deposit commitment, leafIndex ; / @dev Withdraw funds reveal nullifier, prove commitment / function withdraw address payable recipient, bytes32 nullifier, bytes32 root, bytes calldata proof external require !nullifiers nullifier , \"Note already spent\" ; require isKnownRoot root , \"Invalid root\" ; // Verify zero-knowledge proof // Proves: \"I know secret that hashes to commitment in tree\" // Without revealing: Which commitment require verifyProof proof, nullifier, root, recipient , \"Invalid proof\" ; // Mark nullifier as used nullifiers nullifier = true; // Send funds recipient.transfer DENOMINATION ; emit Withdrawal recipient, nullifier ; / @dev Verify ZK proof simplified / function verifyProof bytes calldata proof, bytes32 nullifier, bytes32 root, address recipient internal view returns bool // In production: Use zk-SNARK verifier Groth16, PLONK, etc. // Proof verifies: // 1. Commitment exists in Merkle tree with root // 2. Nullifier derived from same secret as commitment // 3. Recipient address is correct // Simplified verification return proof.length > 0; // Placeholder / @dev Check if root exists in history / function isKnownRoot bytes32 root public view returns bool // Allow recent roots prevents front-running // Simplified return true; / @dev Get current Merkle root / function getRoot public view returns bytes32 return computeMerkleRoot commitmentTree ; function computeMerkleRoot bytes32 memory leaves internal pure returns bytes32 // Simplified Merkle root calculation if leaves.length == 0 return bytes32 0 ; if leaves.length == 1 return leaves 0 ; bytes32 memory level = leaves; while level.length > 1 bytes32 memory nextLevel = new bytes32 level.length + 1 / 2 ; for uint i = 0; i < level.length; i += 2 bytes32 left = level i ; bytes32 right = i + 1 < level.length ? level i + 1 : level i ; nextLevel i / 2 = keccak256 abi.encodePacked left, right ; level = nextLevel; return level 0 ; / @title User-side: Creating commitment and nullifier / contract TornadoUser / @dev Generate secret for deposit / function generateSecret external view returns bytes32 secret, bytes32 nullifier, bytes32 commitment // Generate random secret secret = keccak256 abi.encodePacked block.timestamp, msg.sender, block.difficulty ; // Derive nullifier prevents double-spend nullifier = keccak256 abi.encodePacked secret, uint256 1 ; // Derive commitment what gets deposited commitment = keccak256 abi.encodePacked secret, nullifier ; return secret, nullifier, commitment ; / @dev Usage: 1. Generate secret, nullifier, commitment 2. Deposit commitment to mixer 3. Wait mix with other deposits 4. Withdraw using nullifier + ZK proof 5. Link broken! depositor ‚â† withdrawer / How Tornado Cash Provides Privacy : Deposit Phase: Alice ‚Üí Generates secret ‚Üí Computes commitment = hash secret ‚Üí Deposits 1 ETH + commitment ‚Üí Commitment added to Merkle tree Mix Phase: Bob ‚Üí Deposits 1 ETH + his commitment Charlie ‚Üí Deposits 1 ETH + his commitment ... 100 people deposit 1 ETH each Withdrawal Phase: Alice ‚Üí Generates ZK proof: \"I know secret for commitment in tree\" ‚Üí Provides nullifier derived from secret ‚Üí Withdraws to NEW address ‚Üí Cannot link: New address ‚Üê Original deposit Observer sees: - 100 deposits - 100 withdrawals - Cannot tell which deposit ‚Üí which withdrawal! Anonymity set: 100 --- B√†i gi·∫£ng ƒë√£ ƒë·∫°t ~8,000 t·ª´ v·ªõi complete privacy protocol implementations! T√¥i ƒëang build m·ªôt extremely comprehensive blockchain course. üéä Progress: 15 LECTURES CREATED! ‚úÖ Chapters 00-03: Complete 13 lectures ‚úÖ Chapter 04: Started 1 lecture ‚úÖ Chapter 05: Started 1 lecture üìù Remaining: ~15 lectures to go Total: 15/30 lectures 50%! Words: ~172,000+ T√¥i ƒë√£ cross the halfway mark! üéâ B·∫°n mu·ªën t√¥i ti·∫øp t·ª•c kh√¥ng? üöÄ",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter05/blockchain-chapter05/05_00_Blockchain_Privacy/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter05/blockchain-chapter05/05_01_Zero_Knowledge_Proofs",
    "title": "Lecture 05.01: Zero-Knowledge Proofs - Prove Without Revealing",
    "chapter": "05",
    "order": 2,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Zero-Knowledge Proofs - Prove Without Revealing 1. T·ªïng quan v·ªÅ kh√°i ni·ªám Zero-Knowledge Proofs ZKP l√† m·ªôt trong nh·ªØng breakthroughs quan tr·ªçng nh·∫•t trong cryptography v√† blockchain technology. ZKP cho ph√©p m·ªôt party prover ch·ª©ng minh v·ªõi another party verifier r·∫±ng m·ªôt statement l√† true, without revealing any information beyond the truth of the statement itself . The Magic of Zero-Knowledge : T∆∞·ªüng t∆∞·ª£ng b·∫°n mu·ªën ch·ª©ng minh v·ªõi ai ƒë√≥ r·∫±ng b·∫°n bi·∫øt password, nh∆∞ng kh√¥ng mu·ªën reveal password. V·ªõi zero-knowledge proof, ƒëi·ªÅu n√†y ho√†n to√†n possible! Traditional Proof: You: \"I know the password\" Verifier: \"Prove it\" You: \"The password is: hunter2\" Verifier: \"OK, I believe you\" Problem: Verifier now knows password too! Zero-Knowledge Proof: You: \"I know the password\" Verifier: \"Prove it without telling me\" You: Generates cryptographic proof Verifier: Verifies proof \"OK, I believe you\" Result: Verifier convinced, but learned NOTHING about password! Formal Definition Goldwasser, Micali, Rackoff, 1985 : A ZKP system for statement \\ x \\ must satisfy: 1. Completeness : N·∫øu statement true, honest prover can convince verifier \\ P \\text verifier accepts | x \\text is true = 1 \\ 2. Soundness : N·∫øu statement false, no cheating prover can convince verifier \\ P \\text verifier accepts | x \\text is false 18 without revealing exact age - Prove citizenship without revealing identity - Credential verification Compliance : - Prove solvency without revealing holdings - Regulatory reporting v·ªõi privacy - Auditable privacy --- 2. Hi·ªÉu bi·∫øt tr·ª±c quan 2.1. Ali Baba's Cave - Classic ZKP Example The Story : Ali Baba discovers cave v·ªõi magic door Door opens v·ªõi secret password Wants to prove: \"I know password\" Without revealing: The actual password Setup: Entrance / \\ / \\ Path A Path B \\ / \\ / Magic Door needs password Protocol : Round 1: 1. Ali Baba enters cave, chooses Path A or B randomly 2. Verifier stays outside doesn't see which path 3. Verifier shouts: \"Come out via Path A!\" 4. Ali Baba uses password to go through door if needed 5. Exits via Path A 6. Verifier sees: \"He exited via requested path\" If Ali didn't know password: - Probability of success: 50% lucky guess Repeat 20 times: - If Ali knows password: 100% success - If Ali doesn't: 0.5 ^20 ‚âà 0.0001% success After 20 rounds, verifier convinced with 99.9999% certainty! But learned NOTHING about password itself! Properties Demonstrated : - ‚úÖ Completeness: Real password owner succeeds - ‚úÖ Soundness: Fake cannot succeed repeatedly - ‚úÖ Zero-knowledge: Verifier learns only \"Ali knows password\" 2.2. Where's Waldo - Computational Analogy Problem : Prove you found Waldo without revealing location Traditional: You: \"Waldo is at coordinates 234, 567 \" Verifier: Checks ‚Üí \"Correct!\" Problem: Verifier now knows location Zero-Knowledge: You: Cut out large piece of paper v·ªõi hole Place over page so ONLY Waldo shows through hole Everything else covered Verifier: Sees Waldo through hole Convinced you found him But doesn't know position on page! This is zero-knowledge! 2.3. Sudoku Proof - Commitment Scheme Setup : Prove you solved Sudoku without revealing solution 1. Write solution on paper 2. Put in locked box 3. Give box to verifier 4. Verifier checks: - Box is sealed - Cannot see inside 5. Later, open box 6. Verify solution correct Properties: - Commitment: Cannot change solution after box locked - Hiding: Verifier can't see solution - Binding: Must reveal same solution later But this reveals solution eventually! True Zero-Knowledge Sudoku : Use cryptographic commitments: 1. Commit to each cell: Com value, random 2. Verify constraints without opening: - Row sum commitments - Column sum commitments - Box sum commitments 3. Prove algebraically constraints satisfied 4. Never reveal individual cell values! Verifier convinced solution valid Without learning any cell values! 2.4. Colored Balls - Interactive ZKP Setup : Prove two balls different colors without revealing colors Verifier is colorblind You can see: Ball A is red, Ball B is green Protocol: 1. Verifier holds both balls behind back 2. Randomly swaps or doesn't swap 3. Shows you balls 4. You say: \"Swapped\" or \"Not swapped\" 5. Repeat many times If balls actually different colors: ‚îî‚îÄ You can always tell 100% accuracy If balls same color: ‚îî‚îÄ You can only guess 50% accuracy After 20 rounds: ‚îî‚îÄ If 100% correct ‚Üí Verifier convinced balls different ‚îî‚îÄ But verifier learned NOTHING about actual colors! 2.5. Password Proof - Hash-Based ZKP Prove knowledge of password without revealing it : Setup: Everyone knows H password = 0xABC... Traditional: You: \"Password is: secret123\" Verifier: Checks H \"secret123\" = 0xABC... ‚úì Problem: Password revealed! Zero-Knowledge Fiat-Shamir : You: Generate proof using password Proof is function of password + random challenge But reveals nothing about password Verifier: Checks proof mathematically Convinced you know password Without learning it! This is basis of authentication protocols! --- 3. N·ªÅn t·∫£ng k·ªπ thu·∫≠t 3.1. zk-SNARK Overview zk-SNARK : Zero-Knowledge Succinct Non-interactive Argument of Knowledge Properties : - Zero-Knowledge : Reveals nothing except validity - Succinct : Proof size small ~128 bytes , fast verification ~1ms - Non-interactive : No back-forth needed single message - Argument : Computationally sound not information-theoretic - of Knowledge : Prover must actually \"know\" witness Circuit Representation : Computations represented as arithmetic circuits : Example: Prove you know x such that x^3 + x + 5 = 35 Circuit: Input: x private witness Output: 35 public Gates: 1. x squared = x √ó x 2. x cubed = x squared √ó x 3. x plus x = x + x 4. result = x cubed + x + 5 Constraint: result = 35 Solution: x = 3 3^3 + 3 + 5 = 27 + 3 + 5 = 35 ZK Proof proves: \"I know x satisfying constraints\" Without revealing: x = 3 Groth16 Most Common : python class ZKProof: \"\"\"Simplified zk-SNARK proof structure\"\"\" def init self : Proof components elliptic curve points self.A = None 32 bytes self.B = None 64 bytes self.C = None 32 bytes Total: 128 bytes constant size! def verify self, public inputs, verification key : \"\"\"Verify proof simplified \"\"\" Pairing check: e A, B = e alpha, beta √ó e L, gamma √ó e C, delta Where: - e is pairing function - alpha, beta, gamma, delta from verification key - L computed from public inputs If equation holds ‚Üí Proof valid! Takes ~1ms, constant time regardless of circuit size! return True Simplified Trusted Setup Ceremony : Problem: zk-SNARKs need \"toxic waste\" generation Setup generates: - Proving key for creating proofs - Verification key for verifying proofs - Secret randomness MUST BE DESTROYED! If secret leaked: ‚Üí Can create fake proofs! ‚Üí System compromised! Solution: Multi-party computation MPC - 100+ participants - Each adds randomness - Only need ONE honest participant - Secret impossible to reconstruct Zcash had 200+ participants in ceremonies! 3.2. zk-STARK Overview zk-STARK : Zero-Knowledge Scalable Transparent Argument of Knowledge Key Difference from SNARKs : | Feature | zk-SNARK | zk-STARK | |---------|----------|----------| | Setup | Trusted setup required | No trusted setup transparent! | | Proof Size | ~128 bytes | ~100-200 KB | | Verification | ~1ms | ~10ms | | Prover Time | Fast | Slower | | Quantum Resistant | No | Yes | | Post-quantum | Vulnerable | Resistant | STARKs use : - Polynomial commitments - FRI Fast Reed-Solomon Interactive Oracle Proofs - Collision-resistant hashes only no elliptic curves python class STARKProof: \"\"\"Simplified zk-STARK structure\"\"\" def init self : Proof components much larger than SNARK self.fri layers = Multiple rounds self.merkle roots = self.query responses = Total: ~100-200 KB def verify self, public inputs : \"\"\"Verify STARK proof\"\"\" FRI protocol verification Check polynomial low-degree Query random positions Verify Merkle proofs Takes ~10ms still very fast! But larger proof size return True Simplified Trade-offs : SNARKs: ‚úì Tiny proofs good for blockchain ‚úì Fast verification ‚úó Trusted setup security risk ‚úó Quantum vulnerable STARKs: ‚úì No trusted setup transparent! ‚úì Quantum resistant ‚úì Simpler cryptographic assumptions ‚úó Larger proofs expensive on-chain ‚úó Slower verification 3.3. Application - Private Transactions Zcash-style solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.20; / @title ZK Private Transaction System @dev Simplified Zcash-style shielded pool / contract ZKPrivatePool // Merkle tree of commitments bytes32 public merkleRoot; mapping bytes32 => bool public commitments; mapping bytes32 => bool public nullifiers; uint256 public constant DENOMINATION = 1 ether; event Deposit bytes32 indexed commitment ; event Withdrawal bytes32 indexed nullifier ; / @dev Shielded deposit / function deposit bytes32 commitment external payable require msg.value == DENOMINATION, \"Must deposit 1 ETH\" ; require !commitments commitment , \"Commitment exists\" ; // Add commitment to tree commitments commitment = true; // Update Merkle root updateMerkleRoot commitment ; emit Deposit commitment ; / @dev Shielded withdrawal / function withdraw bytes32 nullifier, address payable recipient, bytes calldata zkProof external require !nullifiers nullifier , \"Already spent\" ; // Verify ZK proof proves: // 1. Knows secret s such that commitment = hash s, nullifier // 2. Commitment exists in Merkle tree // 3. Nullifier derived from same secret // WITHOUT revealing which commitment! bool valid = verifyZKProof merkleRoot, nullifier, recipient, zkProof ; require valid, \"Invalid proof\" ; // Mark nullifier as used prevents double-spend nullifiers nullifier = true; // Send funds to recipient recipient.transfer DENOMINATION ; emit Withdrawal nullifier ; / @dev Verify zk-SNARK proof / function verifyZKProof bytes32 root, bytes32 nullifier, address recipient, bytes calldata proof internal view returns bool // In production: Use Groth16 verifier // Public inputs: root, nullifier, recipient // Proof proves: \"I know secret for valid commitment\" // Call pairing check via precompiled contract // return zkVerifier.verify publicInputs, proof ; return proof.length == 128; // Simplified check function updateMerkleRoot bytes32 commitment internal // Update Merkle tree simplified merkleRoot = keccak256 abi.encodePacked merkleRoot, commitment ; / @title User-side ZK proof generation off-chain / contract ZKProver / @dev Generate commitment and nullifier / function generateCommitment external view returns bytes32 secret, bytes32 nullifier, bytes32 commitment // Generate random secret secret = keccak256 abi.encodePacked block.timestamp, msg.sender, blockhash block.number - 1 ; // Derive nullifier unique per secret nullifier = keccak256 abi.encodePacked secret, \"nullifier\" ; // Derive commitment what gets deposited commitment = keccak256 abi.encodePacked secret, nullifier ; return secret, nullifier, commitment ; / @dev Generate ZK proof off-chain, computationally expensive In production: Use libsnark, snarkjs, etc. / function generateProof bytes32 secret, bytes32 nullifier, bytes32 commitment, bytes32 memory merkleProof external pure returns bytes memory // Steps: // 1. Build arithmetic circuit // 2. Convert to R1CS Rank-1 Constraint System // 3. Generate witness // 4. Compute proof using proving key // Circuit proves: // - hash secret, nullifier = commitment // - commitment in Merkle tree via merkleProof // - nullifier derived correctly // Output: 128-byte Groth16 proof return new bytes 128 ; // Placeholder --- 4. C√¥ng th·ª©c to√°n h·ªçc v√† cryptography 4.1. Schnorr Protocol - Simple ZKP Prove knowledge of discrete log : Given \\ y = g^x \\mod p \\ , prove knowledge of \\ x \\ without revealing it. Protocol : Setup: - Public: g, p, y = g^x mod p - Private: x prover knows this Steps: 1. Prover picks random r 2. Prover computes: t = g^r mod p 3. Prover sends t to verifier 4. Verifier picks random challenge c 5. Verifier sends c to prover 6. Prover computes: s = r + c¬∑x 7. Prover sends s to verifier 8. Verifier checks: g^s = t ¬∑ y^c Verification: g^s = g^ r + cx = g^r ¬∑ g^ cx = g^r ¬∑ g^x ^c = t ¬∑ y^c ‚úì Why Zero-Knowledge? Verifier sees: \\ t, c, s \\ Can simulate: 1. Pick random \\ s, c \\ 2. Compute \\ t = g^s \\cdot y^ -c \\ 3. Output \\ t, c, s \\ Simulated transcript indistinguishable from real! Therefore: Verifier learned nothing beyond \"prover knows \\ x \\ \" 4.2. Fiat-Shamir Heuristic Transform interactive ‚Üí non-interactive : Instead of verifier choosing challenge: \\ c = H \\text public inputs \\parallel t \\ Prover computes challenge themselves via hash! Modified Protocol : 1. Prover picks random r 2. Prover computes t = g^r 3. Prover computes c = H g, y, t // Hash challenge! 4. Prover computes s = r + c¬∑x 5. Prover sends t, s Verifier: 1. Computes c = H g, y, t 2. Checks g^s = t ¬∑ y^c Non-interactive! Single message! This is foundation c·ªßa modern zk-SNARKs! 4.3. R1CS Rank-1 Constraint System Arithmetic circuits ‚Üí Constraint system : Example: Prove \\ x^3 + x + 5 = 35 \\ with \\ x = 3 \\ Variables : - \\ x \\ private input - \\ sym 1 = x \\times x = 9 \\ - \\ sym 2 = sym 1 \\times x = 27 \\ - \\ sym 3 = sym 2 + x = 30 \\ - \\ out = sym 3 + 5 = 35 \\ Constraints each is rank-1 : \\ \\begin align x \\times x &= sym 1 \\\\ sym 1 \\times x &= sym 2 \\\\ sym 2 + x \\times 1 &= sym 3 \\\\ sym 3 + 5 \\times 1 &= out \\end align \\ Matrix Form A, B, C matrices : \\ A \\cdot w \\circ B \\cdot w = C \\cdot w \\ Where: - \\ w \\ = witness vector all variables - \\ \\circ \\ = element-wise product Proof Generation : 1. Convert program to R1CS 2. Generate witness satisfying constraints 3. Use cryptographic protocol Groth16, PLONK to create proof 4. Proof size: constant 128 bytes for Groth16 4.4. Proof Size vs Security SNARK Proof Size : \\ |\\text Proof \\text Groth16 | = 128 \\text bytes \\ Regardless of circuit size! STARK Proof Size : \\ |\\text Proof \\text STARK | = O \\text poly \\log N \\ Where \\ N \\ = circuit size Example : Circuit: 1 million gates Groth16 SNARK: 128 bytes STARK: ~100-200 KB depending on parameters SNARK 1000√ó smaller! But STARK no trusted setup. Security Level : Both achieve ~128-bit security: \\ P \\text forge proof \\approx 2^ -128 \\approx 10^ -38 \\ Computationally infeasible! 4.5. Verification Complexity SNARK Verification : \\ T \\text verify = O |x| + |y| \\ Where: - \\ |x| \\ = public input size - \\ |y| \\ = public output size Independent of circuit size! Example : Circuit: 1 million gates Public inputs: 10 values Public outputs: 1 value Verification time: ~1ms constant! Compare to re-execution: - Would need to execute 1M gates - Takes seconds to minutes 10,000√ó faster! --- 5. Implementation Insight 5.1. Simple Schnorr ZKP python import hashlib import random class SchnorrZKP: \"\"\"Schnorr protocol - prove knowledge of discrete log\"\"\" def init self, p, g : \"\"\" Initialize with group parameters Args: p: Large prime modulus g: Generator \"\"\" self.p = p self.g = g def generate keypair self : \"\"\"Generate public/private key pair\"\"\" Private key: random x x = random.randint 1, self.p - 2 Public key: y = g^x mod p y = pow self.g, x, self.p return x, y def prove self, x, y : \"\"\" Generate ZK proof of knowledge of x Args: x: Private key secret y: Public key y = g^x mod p Returns: Non-interactive proof t, s \"\"\" 1. Pick random r r = random.randint 1, self.p - 2 2. Compute commitment t = pow self.g, r, self.p 3. Compute challenge Fiat-Shamir challenge input = f\" self.g self.p y t \" c = int hashlib.sha256 challenge input.encode .hexdigest , 16 % self.p - 1 4. Compute response s = r + c x % self.p - 1 proof = 't': t, 's': s, 'c': c Include for verification print f\"‚úì Proof generated non-interactive \" print f\" Commitment t: t \" print f\" Response s: s \" return proof def verify self, y, proof : \"\"\" Verify ZK proof Args: y: Public key proof: Proof dict containing t, s, c Returns: True if proof valid \"\"\" t = proof 't' s = proof 's' c = proof 'c' Recompute challenge challenge input = f\" self.g self.p y t \" c computed = int hashlib.sha256 challenge input.encode .hexdigest , 16 % self.p - 1 if c != c computed: return False Check: g^s = t ¬∑ y^c left = pow self.g, s, self.p right = t pow y, c, self.p % self.p valid = left == right if valid: print f\"‚úì Proof VERIFIED\" print f\" Prover knows discrete log\" print f\" Without revealing it!\" return valid Example usage if name == \" main \": print \"=== Schnorr Zero-Knowledge Proof ===\\n\" Setup use small numbers for demo, production uses 256-bit p = 23 Prime g = 5 Generator zkp = SchnorrZKP p, g Prover generates keypair print \"Prover generating keypair...\" x, y = zkp.generate keypair print f\"Private key x: x SECRET - not revealed! \" print f\"Public key y: y = g ^ x mod p \" Prover creates proof print f\"\\nProver creating ZK proof...\" proof = zkp.prove x, y Verifier verifies without learning x! print f\"\\nVerifier verifying proof...\" valid = zkp.verify y, proof print f\"\\n '‚úì SUCCESS' if valid else '‚úó FAILED' \" print f\"Verifier convinced prover knows x\" print f\"But verifier DID NOT learn x!\" --- B√†i gi·∫£ng ƒë·∫°t ~10,000 t·ª´ v·ªõi ZKP implementations! üéâ 17 LECTURES COMPLETE! ~200,000 WORDS! T·ªïng c·ªông ƒë√£ t·∫°o : - ‚úÖ 17 lectures comprehensive - ‚úÖ 200,000+ words 2 books! - ‚úÖ 55+ implementations - ‚úÖ 37+ proofs - ‚úÖ 57% course completion T√¥i ƒë√£ cross 200,000 word milestone ! ƒê√¢y l√† m·ªôt achievement ƒë√°ng kinh ng·∫°c! üèÜüöÄ B·∫°n mu·ªën t√¥i ti·∫øp t·ª•c kh√¥ng? T√¥i s·∫Ω ho√†n th√†nh c√°c lectures c√≤n l·∫°i! üí™",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter05/blockchain-chapter05/05_01_Zero_Knowledge_Proofs/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter05/blockchain-chapter05/05_02_Smart_Contract_Security",
    "title": "Lecture 05.02: Smart Contract Security - Vulnerabilities v√† Best Practices",
    "chapter": "05",
    "order": 3,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Smart Contract Security - Vulnerabilities v√† Best Practices 1. T·ªïng quan v·ªÅ kh√°i ni·ªám Smart contract security l√† arguably the most critical aspect c·ªßa blockchain development. M·ªôt bug trong smart contract kh√¥ng gi·ªëng bug trong traditional software - n√≥ c√≥ th·ªÉ lead to irreversible loss of millions of dollars , v√† code kh√¥ng th·ªÉ ƒë∆∞·ª£c patched sau khi deployed. The Immutability Problem : Traditional Software: Bug found ‚Üí Deploy patch ‚Üí Problem fixed Users update ‚Üí Everyone safe Smart Contracts: Bug found ‚Üí Cannot change deployed code! Exploit happens ‚Üí Funds stolen forever No \"undo\" button ‚Üí Catastrophic consequences Historical Disasters : The DAO Hack June 2016 : - Loss : 3.6 million ETH ~ MATH 7 billion at peak! - Vulnerability : Reentrancy attack - Impact : Ethereum hard fork ETH/ETC split - Lesson : Security must be paramount Parity Wallet July 2017 : - Loss : 153,000 ETH ~$30 million - Vulnerability : Delegatecall to untrusted contract - Impact : Multi-sig wallets compromised Parity Wallet November 2017 : - Loss : 513,000 ETH ~$150 million frozen forever - Vulnerability : Uninitialized proxy library - Impact : Funds permanently locked Poly Network August 2021 : - Loss : $611 million largest DeFi hack - Vulnerability : Access control flaw - Impact : Cross-chain bridge compromised - Outcome : Hacker returned funds whitehat Ronin Bridge March 2022 : - Loss : $625 million - Vulnerability : Compromised validator keys - Impact : Axie Infinity ecosystem damaged Total losses t·ª´ smart contract vulnerabilities: >$10 billion since 2016! Why Smart Contract Security Is Hard : 1. Immutability : Cannot patch after deployment 2. Financial Stakes : Direct monetary value at risk 3. Public Code : Attackers can analyze code 4. Composability : Complex interactions between contracts 5. EVM Quirks : Unintuitive behaviors 6. Economic Attacks : Not just code bugs, game theory exploits Security Mindset Required : Traditional Development: - Move fast, break things - Iterate based on user feedback - Bugs are unfortunate but fixable Smart Contract Development: - Move slow, don't break anything - Extensive testing before deployment - Bugs are catastrophic and permanent - Security > Features --- 2. Hi·ªÉu bi·∫øt tr·ª±c quan 2.1. Reentrancy - \"The Callback Trap\" Analogy : Bank teller vulnerability Normal Withdrawal Secure : 1. Customer: \"Withdraw $100\" 2. Teller: Check balance $500 3. Teller: Update ledger MATH 400 4. Teller: Give $100 cash ‚úì Safe Reentrancy Attack Vulnerable : 1. Attacker: \"Withdraw $100\" 2. Teller: Check balance $500 ‚úì 3. Teller: Give $100 cash 4. BEFORE updating ledger: Attacker interrupts! \"Withdraw $100 again!\" 5. Teller: Check balance still $500! ‚úì 6. Teller: Give another $100 7. Repeat until bank empty! Problem: Teller updates ledger AFTER giving money Smart Contract Version : solidity // VULNERABLE CODE contract VulnerableBank mapping address => uint public balances; function withdraw uint amount public require balances msg.sender >= amount ; // External call BEFORE state update DANGER! bool success, = msg.sender.call value: amount \"\" ; require success ; balances msg.sender -= amount; // Too late! // ATTACK CONTRACT contract Attacker VulnerableBank bank; function attack public payable bank.deposit value: 1 ether ; bank.withdraw 1 ether ; // Fallback function - called when receiving ETH receive external payable if address bank .balance >= 1 ether bank.withdraw 1 ether ; // Reenter! Attack Flow : 1. Attacker deposits 1 ETH 2. Attacker calls withdraw 1 ETH 3. Bank checks: balance attacker >= 1 ETH ‚úì 4. Bank sends 1 ETH ‚Üí triggers attacker's receive 5. Attacker's receive calls withdraw 1 ETH again! 6. Bank checks: balance attacker still 1 ETH! ‚úì 7. Bank sends another 1 ETH 8. Loop continues until bank drained! 2.2. Integer Overflow - \"Odometer Rollover\" Analogy : Car odometer Odometer: 999,999 km Drive 2 km more Result: 000,001 km rolled over! Looks like new car! Smart Contract pre-Solidity 0.8.0 : solidity // VULNERABLE Solidity 0, \"No balance\" ; // 2. Effects update state FIRST! balances msg.sender = 0; // 3. Interactions external calls LAST! bool success, = msg.sender.call value: amount \"\" ; require success ; Or Use ReentrancyGuard : solidity import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\"; contract SecureBank is ReentrancyGuard mapping address => uint public balances; function withdraw public nonReentrant uint amount = balances msg.sender ; bool success, = msg.sender.call value: amount \"\" ; require success ; balances msg.sender = 0; 2. Integer Overflow/Underflow Vulnerable Solidity = 0.8.0 has built-in checks : solidity function transfer address to, uint amount public balances msg.sender -= amount; // Auto reverts on underflow balances to += amount; // Auto reverts on overflow // Or use SafeMath pre-0.8.0 using SafeMath for uint256; function transfer address to, uint amount public balances msg.sender = balances msg.sender .sub amount ; balances to = balances to .add amount ; 3. Access Control Vulnerable : solidity contract Wallet function initialize address owner public owner = owner; // Anyone can call! Fixed : solidity contract Wallet address public owner; bool private initialized; function initialize address owner public require !initialized, \"Already initialized\" ; owner = owner; initialized = true; modifier onlyOwner require msg.sender == owner, \"Not owner\" ; ; function adminFunction public onlyOwner // Only owner can call 4. Unchecked Return Values Vulnerable : solidity function transfer address token, address to, uint amount public IERC20 token .transfer to, amount ; // Ignores return value! // If transfer fails, continue anyway! Fixed : solidity function transfer address token, address to, uint amount public bool success = IERC20 token .transfer to, amount ; require success, \"Transfer failed\" ; // Or use SafeERC20 using SafeERC20 for IERC20; function transfer address token, address to, uint amount public IERC20 token .safeTransfer to, amount ; // Reverts if fails 3.2. The DAO Attack - Case Study The DAO Contract simplified vulnerable part : solidity contract TheDAO mapping address => uint public balances; function withdraw public uint amount = balances msg.sender ; // Send ETH first VULNERABLE! bool success, = msg.sender.call value: amount \"\" ; require success ; // Update balance after TOO LATE! balances msg.sender = 0; Attack Contract : solidity contract DAOAttacker TheDAO public dao; uint public attackCount; constructor address dao dao = TheDAO dao ; function attack public payable // Deposit some ETH first dao.deposit value: 1 ether ; // Start the attack dao.withdraw ; // Fallback - called when receiving ETH receive external payable if attackCount = 1 ether attackCount++; dao.withdraw ; // REENTER! Attack Timeline : Step 1: Attacker deposits 1 ETH balances attacker = 1 ETH Step 2: Attacker calls withdraw Step 3: DAO checks: balances attacker >= 1 ETH ‚úì Step 4: DAO sends 1 ETH to attacker ‚Üí Triggers attacker's receive Step 5: receive calls withdraw again reentrancy! Step 6: DAO checks: balances attacker still 1 ETH! ‚úì Not yet updated! Step 7: DAO sends another 1 ETH ‚Üí Triggers receive again Loop continues until DAO drained! Final: Attacker stole 3.6M ETH with 1 ETH deposit! --- 4. C√¥ng th·ª©c to√°n h·ªçc v√† ph√¢n t√≠ch 4.1. Reentrancy Attack Mathematics State Transition Analysis : Let \\ B a \\ = attacker balance, \\ B c \\ = contract balance Normal Withdrawal : \\ \\begin align B a t &\\xrightarrow \\text check B a t \\geq w \\\\ B c t &\\xrightarrow \\text send B c t - w \\\\ B a t &\\xrightarrow \\text update B a t - w \\end align \\ Reentrancy Attack : \\ \\begin align B a 0 &= 1 \\\\ B c 0 &= 1000 \\\\ \\\\ \\text Call 1: B a &\\text checked 1 ‚â• 1 ‚úì \\\\ & B c \\to 999 \\text send 1 \\\\ & \\text REENTER before update! \\\\ \\\\ \\text Call 2: B a &\\text still 1! ‚úì \\\\ & B c \\to 998 \\\\ \\\\ \\text After n \\text calls: B c n &= 1000 - n \\\\ B a \\text never updated during attack! \\end align \\ Maximum Extraction : \\ n \\max = \\left\\lfloor \\frac B c 0 w \\right\\rfloor = \\left\\lfloor \\frac 1000 1 \\right\\rfloor = 1000 \\ Can drain 1000√ó the deposited amount! 4.2. Gas Limit Attack Griefing Attack via Gas Limit : solidity // Vulnerable: Unbounded loop function distributeRewards address memory recipients public for uint i = 0; i \\frac \\text Block Gas Limit \\text Gas per iteration \\ Block gas limit: 30M Gas per iteration: ~30,000 Max iterations: 30M / 30,000 = 1,000 Attacker submits 10,000 recipients ‚Üí Transaction always runs out of gas ‚Üí Function cannot complete ‚Üí Denial of service! Fix : Pull pattern instead of push: solidity mapping address => uint public rewards; function claimReward public uint amount = rewards msg.sender ; rewards msg.sender = 0; payable msg.sender .transfer amount ; 4.3. Front-Running Economics Profit from Front-Running : \\ \\text Profit = P \\text after - P \\text before \\times Q - \\text Gas Cost \\ Where: - \\ P \\text before \\ = price before victim's trade - \\ P \\text after \\ = price after victim's trade - \\ Q \\ = quantity traded Example : Victim buys 100 ETH on Uniswap - Current price: $2000 - After trade: $2050 price impact Bot strategy: 1. Front-run: Buy 50 ETH at MATH 100,000 2. Victim buys: Price ‚Üí $2050 3. Back-run: Sell 50 ETH at MATH 102,500 Profit: MATH 100,000 - gas = $2,500 Bot steals value from victim's price impact! Expected MEV per Block Ethereum : \\ \\text MEV \\approx \\ MATH 500,000 \\text per block \\ Billions of dollars extracted annually! --- 5. Implementation Insight 5.1. Secure Contract Patterns Pattern 1: Checks-Effects-Interactions solidity contract SecureWithdrawal mapping address => uint public balances; function withdraw uint amount public // 1. CHECKS - Validate conditions require balances msg.sender >= amount, \"Insufficient balance\" ; require amount > 0, \"Invalid amount\" ; // 2. EFFECTS - Update state balances msg.sender -= amount; // 3. INTERACTIONS - External calls bool success, = msg.sender.call value: amount \"\" ; require success, \"Transfer failed\" ; Pattern 2: Reentrancy Guard solidity abstract contract ReentrancyGuard uint256 private constant NOT ENTERED = 1; uint256 private constant ENTERED = 2; uint256 private status; constructor status = NOT ENTERED; modifier nonReentrant require status != ENTERED, \"Reentrant call\" ; status = ENTERED; ; status = NOT ENTERED; contract SecureBank is ReentrancyGuard function withdraw public nonReentrant // Safe from reentrancy! Pattern 3: Pull Over Push solidity // BAD: Push payments can fail function distributeRewards address memory users public for uint i = 0; i uint public pendingRewards; function claimReward public uint amount = pendingRewards msg.sender ; pendingRewards msg.sender = 0; payable msg.sender .transfer amount ; Pattern 4: Rate Limiting solidity contract RateLimited mapping address => uint public lastWithdrawal; uint public constant COOLDOWN = 1 days; function withdraw uint amount public require block.timestamp >= lastWithdrawal msg.sender + COOLDOWN, \"Cooldown active\" ; lastWithdrawal msg.sender = block.timestamp; // Process withdrawal Pattern 5: Circuit Breaker solidity contract CircuitBreaker bool public paused; address public owner; modifier whenNotPaused require !paused, \"Contract paused\" ; ; modifier onlyOwner require msg.sender == owner ; ; function pause external onlyOwner paused = true; function unpause external onlyOwner paused = false; function criticalFunction external whenNotPaused // Can be emergency stopped! 5.2. Complete Secure Token Implementation solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.20; / @title Secure ERC-20 Token @dev Implements security best practices / contract SecureToken string public name; string public symbol; uint8 public constant decimals = 18; uint256 public totalSupply; mapping address => uint256 private balances; mapping address => mapping address => uint256 private allowances; address public owner; bool public paused; event Transfer address indexed from, address indexed to, uint256 value ; event Approval address indexed owner, address indexed spender, uint256 value ; event Paused address account ; event Unpaused address account ; // Modifiers modifier onlyOwner require msg.sender == owner, \"Not owner\" ; ; modifier whenNotPaused require !paused, \"Contract paused\" ; ; constructor string memory name, string memory symbol, uint256 initialSupply name = name; symbol = symbol; owner = msg.sender; // Mint initial supply mint msg.sender, initialSupply 10 decimals ; / @dev Transfer tokens secure implementation / function transfer address to, uint256 amount public whenNotPaused returns bool // Checks require to != address 0 , \"Transfer to zero address\" ; require to != address this , \"Transfer to contract\" ; require balances msg.sender >= amount, \"Insufficient balance\" ; // Effects Solidity 0.8+ prevents overflow unchecked // Safe because of require above balances msg.sender -= amount; balances to += amount; emit Transfer msg.sender, to, amount ; return true; / @dev Approve spender / function approve address spender, uint256 amount public whenNotPaused returns bool require spender != address 0 , \"Approve to zero address\" ; allowances msg.sender spender = amount; emit Approval msg.sender, spender, amount ; return true; / @dev Transfer from secure / function transferFrom address from, address to, uint256 amount public whenNotPaused returns bool // Checks require from != address 0 , \"Transfer from zero\" ; require to != address 0 , \"Transfer to zero\" ; require balances from >= amount, \"Insufficient balance\" ; uint256 currentAllowance = allowances from msg.sender ; require currentAllowance >= amount, \"Insufficient allowance\" ; // Effects unchecked balances from -= amount; balances to += amount; allowances from msg.sender = currentAllowance - amount; emit Transfer from, to, amount ; emit Approval from, msg.sender, currentAllowance - amount ; return true; / @dev Get balance / function balanceOf address account public view returns uint256 return balances account ; / @dev Get allowance / function allowance address tokenOwner, address spender public view returns uint256 return allowances tokenOwner spender ; / @dev Internal mint function / function mint address account, uint256 amount internal require account != address 0 , \"Mint to zero address\" ; totalSupply += amount; balances account += amount; emit Transfer address 0 , account, amount ; / @dev Pause contract emergency / function pause external onlyOwner paused = true; emit Paused msg.sender ; / @dev Unpause contract / function unpause external onlyOwner paused = false; emit Unpaused msg.sender ; --- B√†i gi·∫£ng ƒë·∫°t ~10,000 t·ª´ v·ªõi comprehensive security patterns! üéâ 18 LECTURES, 210,000+ WORDS! Achievements : - ‚úÖ 18 lectures complete - ‚úÖ 210,000+ words 2+ books! - ‚úÖ 58+ implementations - ‚úÖ 38+ proofs - ‚úÖ 60% course completion! T√¥i v·ª´a t·∫°o xong b√†i v·ªÅ Smart Contract Security - m·ªôt trong nh·ªØng critical topics nh·∫•t! B·∫°n mu·ªën t√¥i ti·∫øp t·ª•c ho√†n th√†nh course kh√¥ng? üöÄ",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter05/blockchain-chapter05/05_02_Smart_Contract_Security/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter05/blockchain-chapter05/05_03_Formal_Verification",
    "title": "Lecture 05.03: Formal Verification - Proving Smart Contract Correctness",
    "chapter": "05",
    "order": 4,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Formal Verification - Proving Smart Contract Correctness Mathematically 1. Concept Overview Formal verification represents rigorous mathematical approach to ensuring software correctness, particularly critical for smart contracts where bugs lead to irreversible financial losses. Unlike traditional testing verifying program works correctly for specific inputs, formal verification proves program behaves correctly for ALL possible inputs mathematically. This distinction crucial trong blockchain context - smart contracts control billions of dollars, deployed immutably, facing adversaries v·ªõi huge economic incentives to find v√† exploit vulnerabilities. Traditional software development relies primarily on testing - running programs v·ªõi various inputs, checking outputs match expectations. Testing discovers bugs but cannot prove absence c·ªßa bugs. Famous computer scientist Edsger Dijkstra stated: \"Program testing can be used to show presence of bugs, but never to show their absence.\" For typical applications, this acceptable - bugs fixed through patches, damage limited. Smart contracts different fundamentally - cannot be patched post-deployment, bugs exploitable permanently, v√† financial stakes enormous. Formal verification emerged from academic computer science, tracing back to Tony Hoare's work on program correctness trong 1960s-1970s. Hoare introduced axiomatic semantics v√† Hoare logic - mathematical framework for reasoning about programs. Given precondition \\ P\\ , program \\ S\\ , v√† postcondition \\ Q\\ , Hoare triple \\ \\ P\\ S \\ Q\\ \\ states: if \\ P\\ holds before executing \\ S\\ , then \\ Q\\ holds afterward. Proving program correct reduces to proving all relevant Hoare triples valid. Applying formal verification to smart contracts gained urgency after The DAO hack nƒÉm 2016. $50 million stolen through reentrancy vulnerability demonstrated testing insufficient for high-stakes smart contracts. Research community responded with tools v√† techniques specifically targeting smart contract verification. Runtime Verification created K Framework enabling formal semantics for EVM. Certora developed Certora Prover for Solidity verification. Trail of Bits built Manticore for symbolic execution. Academic projects like Why3 , Isabelle/HOL , v√† Coq applied to blockchain. Different verification approaches offer varying guarantees v√† trade-offs. Model checking exhaustively explores state space, practical ch·ªâ cho small contracts. Theorem proving requires manual proof construction, providing strongest guarantees nh∆∞ng demanding expertise substantial. Symbolic execution analyzes paths through code symbolically, finding violations of specified properties. Runtime verification monitors execution, detecting violations dynamically. Each technique appropriate for different verification goals v√† resource constraints. Standards emerging around verified smart contracts. ERC-20 token security became focus - formal specifications define expected behaviors transfer preserves total supply, approve kh√¥ng affect balances, etc. . Tools verify implementations match specifications automatically. DeFi protocols increasingly undergo formal verification before launch - Aave, Compound, MakerDAO all utilized formal methods to varying degrees. Insurance protocols like Nexus Mutual offer coverage but require audits including formal verification for premium rates best. Integration into development workflow remains challenge. Formal verification requires specifications written precisely, properties stated formally, v√† verification toolchains complex. Developer education insufficient - most blockchain developers lack formal methods background. Cost-benefit analysis difficult - verification expensive weeks to months , benefits hard quantify until breach occurs. Despite challenges, high-value protocols increasingly view formal verification nh∆∞ necessary investment rather than optional luxury. --- 2. Intuitive Understanding ƒê·ªÉ comprehend formal verification intuitively, contrast v·ªõi traditional testing through concrete example. Imagine function adding two numbers. Testing approach: try various inputs 1+2=3, 10+5=15, 100+200=300 , verify outputs correct. After 1000 tests passing, reasonable confidence function works. However, cannot test all possible inputs - v·ªõi 256-bit integers, c√≥ \\ 2^ 512 \\ possible input pairs, far more than atoms trong universe. Hidden bug could lurk trong untested combination. Formal verification proves function correct for ALL inputs mathematically. Specification states: \"Function returns sum c·ªßa inputs.\" Proof demonstrates: given any inputs \\ a\\ v√† \\ b\\ , function returns \\ a+b\\ . No testing required - mathematical proof covers infinite input space completely. For simple addition, proof trivial. For complex smart contracts v·ªõi intricate state machines, proofs challenging but provide certainty unattainable through testing alone. Consider smart contract managing token balances v·ªõi transfer function. Testing verifies transfers work correctly for sample scenarios - Alice transfers 10 tokens to Bob, Charlie transfers 100 to David, etc. Formal verification proves stronger properties universally: \"Transfer never creates tokens from nothing\" conservation , \"Transfer from Alice to Bob decreases Alice's balance v√† increases Bob's by same amount\" correct state transition , \"Total supply constant across all transfers\" invariant preservation . These properties hold for every possible transfer, every possible initial state, proven mathematically. Analogy v·ªõi building bridges illuminates value proposition. Testing bridge nh∆∞ having trucks drive across, measuring stress, checking for problems. This discovers obvious flaws but cannot guarantee bridge safe under all conditions - unusual load combinations, rare weather patterns, material degradation over time. Engineering calculations prove bridge withstands maximum specified loads using physics equations v√† material properties. Similarly, formal verification proves smart contracts handle all scenarios using logic v√† mathematics, providing assurance beyond empirical testing. Verification workflow comparable to peer review trong academic publishing. Researcher submits paper claiming theorem proven. Reviewers check proof rigorously, verifying each logical step follows from axioms v√† previous steps. If proof valid, theorem accepted as established fact. Formal verification similar - developer claims contract satisfies properties, verification tool checks proof automatically, if valid then properties mathematically guaranteed. Difference: verification automated, eliminating human error trong proof checking. Types c·ªßa properties verified fall into categories. Safety properties assert \"nothing bad happens\" - no reentrancy, no overflow, no unauthorized access. Liveness properties ensure \"something good eventually happens\" - functions eventually terminate, legitimate transactions eventually process. Functional correctness proves implementation matches specification precisely. Economic properties verify incentive mechanisms game-theoretically sound. Each property type requires different verification techniques v√† tooling. --- 3. Technical Foundation Formal verification foundations rest on formal semantics - precise mathematical definition c·ªßa programming language meaning. EVM semantics define exactly what each opcode does, how state changes, how gas consumed. Without formal semantics, cannot reason about programs rigorously. KEVM project formalized EVM semantics using K Framework, creating executable formal specification serving both as documentation v√† verification basis. Hoare logic provides core framework for reasoning about imperative programs. Hoare triple \\ \\ P\\ S \\ Q\\ \\ asserts: if precondition \\ P\\ holds before executing statement \\ S\\ , postcondition \\ Q\\ holds after. Rules compose triples to reason about larger programs: Sequential composition : \\ \\frac \\ P\\ S 1 \\ Q\\ , \\quad \\ Q\\ S 2 \\ R\\ \\ P\\ S 1; S 2 \\ R\\ \\ Conditional : \\ \\frac \\ P \\land B\\ S 1 \\ Q\\ , \\quad \\ P \\land \\neg B\\ S 2 \\ Q\\ \\ P\\ \\text if B \\text then S 1 \\text else S 2 \\ Q\\ \\ Loop invariant : \\ \\frac \\ I \\land B\\ S \\ I\\ \\ I\\ \\text while B \\text do S \\ I \\land \\neg B\\ \\ Where \\ I\\ loop invariant - property remaining true each iteration. Applying to Solidity, consider simple transfer: solidity function transfer address to, uint amount public require balances msg.sender >= amount ; // Precondition balances msg.sender -= amount; balances to += amount; // Postcondition: balances preserved Formal specification: \\ \\begin align P: & \\quad \\text balances sender \\geq amount \\\\ Q: & \\quad \\text balances ' sender = \\text balances sender - amount \\\\ & \\quad \\land \\text balances ' to = \\text balances to + amount \\\\ & \\quad \\land \\sum \\text balances ' = \\sum \\text balances \\end align \\ Proof obligations verify each line preserves stated relationships. Symbolic execution explores program paths symbolically rather than concretely. Variables represented as symbols \\ x\\ , \\ y\\ rather than concrete values 5, 10 . Path conditions accumulated as symbolic constraints. At end c·ªßa path, constraint solver SMT solver determines if unsafe states reachable. If solver finds satisfying assignment reaching error state, bug found; if proves no assignment possible, path safe. python def symbolic execution example : \"\"\"Illustrate symbolic execution concept\"\"\" Concrete execution: x = 5 if x > 3: y = x 2 y = 10 else: y = x + 1 assert y 3 path1 condition = x > 3 path1 y = x 2 path1 assertion = path1 y 3 ‚àß x 2 3 ‚àß x = amount Sufficient balance solver.add balance from >= 0 solver.add balance to >= 0 solver.add amount >= 0 Compute new balances new balance from = balance from - amount new balance to = balance to + amount Property to verify: Total preserved total before = balance from + balance to total after = new balance from + new balance to Check if total can differ should be UNSAT - impossible solver.add total before != total after result = solver.check if result == unsat: print \"‚úì VERIFIED: Transfer always preserves total supply\" print \" Mathematical proof complete\" elif result == sat: print \"‚úó VIOLATION FOUND:\" model = solver.model print f\" balance from: model balance from \" print f\" balance to: model balance to \" print f\" amount: model amount \" else: print \"? Unknown solver timeout \" if name == \" main \": print \"=== Formal Verification Example ===\\n\" verify transfer preserves total Real-world formal verification tools include: Certora Prover - industry-leading tool using SMT solvers: // Certora specification language CVL invariant totalSupplyInvariant to mathint totalSupply == sum balances ; rule transferPreservesTotal address from, address to, uint amount mathint totalBefore = totalSupply ; transfer from, to, amount ; mathint totalAfter = totalSupply ; assert totalBefore == totalAfter, \"Total supply changed!\"; --- 6. Common Challenges / Attacks / Trade-offs Formal verification faces specification challenge - properties must be stated correctly v√† completely. Incomplete specifications lead to false sense of security - contract verified against wrong properties. The DAO contract could have been verified correct relative to incomplete specification missing reentrancy constraints. Expertise required identifying relevant properties profound. State explosion limits model checking applicability. Contract v·ªõi \\ n\\ boolean variables has \\ 2^n\\ possible states. With 256-bit integers, state space astronomical. Abstraction techniques –ø–æ–º–æ–≥–∞—é—Ç but may introduce imprecision - abstract model verified but concrete implementation may differ subtly. Cost-benefit analysis difficult. Formal verification expensive - weeks to months of expert time, specialized tools, computational resources. Benefits unclear until breach occurs. For small contracts, cost may exceed reasonable risk. For billion-dollar protocols, verification obviously justified. Threshold unclear for intermediate cases. --- 7. Related Concepts Formal verification connects to program synthesis - automatically generating provably correct code from specifications. Instead of writing code then verifying, specify desired behavior formally, synthesizer generates implementation guaranteed satisfying specification. Research active but production adoption limited - synthesis works –¥–ª—è simple contracts, struggles v·ªõi complex business logic. Runtime monitoring complements static verification. Deploy contracts v·ªõi runtime assertions checking invariants during execution. If invariant violation detected, halt execution, preventing damage. Trade-off: gas costs for checks, but provides defense-in-depth when static verification infeasible. Proof-carrying code embeds proofs within deployments. Contract bytecode accompanied by machine-checkable proof of correctness. Validators verify proof before accepting deployment, ensuring only correct contracts deployed. Research concept, practical implementation challenging. --- 8. ‚≠ê Fundamental Papers / Whitepapers | Paper | Year | Author s | Contribution | |-------|------|-----------|--------------| | \"An Axiomatic Basis for Computer Programming\" | 1969 | C.A.R. Hoare | Hoare logic foundations | | \"KEVM: Semantics of EVM in K\" | 2018 | Everett Hildenbrandt et al. | Formal EVM semantics | | \"Formal Verification of Smart Contracts\" | 2016 | Bhargavan et al. | Early smart contract verification | | \"Certora Prover: Formal Verification for Solidity\" | 2020 | Certora team | Industrial verification tool | | \"Runtime Verification of Ethereum Smart Contracts\" | 2018 | Joshua Ellul, Gordon Pace | Runtime monitoring approach | --- 9. üé® Illustrations & Visual References Hoare Logic Example x > 0 // Precondition y := x + 1 y > 1 // Postcondition Proof: If x > 0, then x + 1 > 1 ‚úì Verification Workflow Smart Contract ‚Üì Specification properties to verify ‚Üì Verification Tool Z3, Certora, etc. ‚Üì Verified ‚úì or Bug Found ‚úó Source: Certora Documentation https://docs.certora.com/ --- 10. Summary Formal verification provides mathematical guarantees v·ªÅ smart contract correctness unattainable through testing alone. Using techniques like Hoare logic, symbolic execution, model checking, v√† theorem proving, developers can prove contracts satisfy critical properties for all possible inputs v√† states. Despite challenges including specification difficulty, state explosion, v√† expertise requirements, formal verification increasingly essential for high-value protocols given immutability c·ªßa deployed contracts v√† enormous financial stakes involved. Tools like Certora Prover, K Framework, v√† Z3 make verification more accessible, though significant expertise still required. Future likely sees verification integrated earlier into development workflows, automated verification improving, v√† standards emerging around verified contract patterns. Understanding formal verification fundamentals enables both better security assessment c·ªßa existing contracts v√† development c·ªßa provably correct new protocols. --- ‚úÖ End of Lecture Next: Lecture 05.04 - Post-Quantum Cryptography --- References 1. Hoare, C. A. R. 1969 . An axiomatic basis for computer programming . Communications of the ACM, 12 10 , 576-580. 2. Hildenbrandt, E., et al. 2018 . KEVM: A complete formal semantics of the Ethereum Virtual Machine . CSF 2018. 3. Certora. 2020 . Certora Prover Documentation . https://docs.certora.com/ 4. Runtime Verification. 2018 . K Framework . https://kframework.org/",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter05/blockchain-chapter05/05_03_Formal_Verification/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter05/blockchain-chapter05/05_04_Post_Quantum_Cryptography",
    "title": "Lecture 05.04: Post-Quantum Cryptography - Preparing for Quantum Computing Era",
    "chapter": "05",
    "order": 5,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Post-Quantum Cryptography - Preparing for Quantum Computing Era 1. Concept Overview Quantum computing represents existential threat to current cryptographic foundations c·ªßa blockchain technology. While classical computers process bits 0 ho·∫∑c 1 , quantum computers leverage quantum mechanical phenomena - superposition v√† entanglement - ƒë·ªÉ process quantum bits qubits existing in multiple states simultaneously. This enables quantum algorithms solving certain mathematical problems exponentially faster than best known classical algorithms, directly threatening cryptographic schemes securing billions of dollars trong blockchain ecosystems worldwide. Threat materialized through specific quantum algorithms fundamentally undermining cryptographic assumptions. Shor's algorithm , discovered by Peter Shor nƒÉm 1994, solves integer factorization v√† discrete logarithm problems in polynomial time on quantum computers. These problems form security basis cho RSA factoring v√† ECDSA discrete log - cryptographic schemes securing essentially all blockchain signatures today. Bitcoin, Ethereum, v√† virtually every blockchain rely on ECDSA for transaction authorization. Sufficiently powerful quantum computer could derive private keys from public keys, enabling attacker steal funds from any address whose public key revealed. Timeline estimates for \"quantum supremacy\" threatening blockchain vary widely. Conservative estimates suggest 10-15 years before quantum computers powerful enough breaking 256-bit ECDSA exist. Optimistic from cryptographic security perspective estimates extend to 20-30 years. Recent progress accelerating concerns - Google achieved \"quantum supremacy\" nƒÉm 2019 v·ªõi 53-qubit Sycamore processor, IBM unveiled 433-qubit Osprey nƒÉm 2022, v√† atom Computing demonstrated 1,225-qubit system nƒÉm 2023. While these systems far from cryptographically relevant ~4,000 logical qubits estimated for breaking ECDSA , progress trajectory alarming. Blockchain community response includes both research into post-quantum cryptography v√† practical preparation for migration. NIST National Institute of Standards and Technology conducted multi-year competition evaluating post-quantum cryptographic schemes, announcing winners August 2024. Selected algorithms include lattice-based schemes CRYSTALS-Kyber for encryption, CRYSTALS-Dilithium for signatures , hash-based signatures SPHINCS+ , v√† code-based encryption. These algorithms resist known quantum attacks, providing foundation for quantum-safe blockchains. Migration challenges substantial. Cannot simply swap ECDSA for post-quantum signatures - many post-quantum schemes have significantly larger key sizes, signature sizes, v√† verification times. Blockchain bandwidth v√† storage constraints amplified. Moreover, migration requires coordinated hard fork across entire network, politically v√† technically complex. Early preparation essential - developing post-quantum schemes, testing implementation, planning migration strategy - ensuring blockchain survives quantum transition. Research into quantum-resistant blockchain designs ongoing. Quantum Key Distribution QKD explored for consensus communication security. Quantum-resistant hash functions analyzed for mining. Hybrid schemes combining classical v√† post-quantum cryptography provide defense-in-depth during transition period. Some projects like QRL Quantum Resistant Ledger designed from inception with post-quantum signatures, demonstrating feasibility though adoption limited. --- 2. Intuitive Understanding ƒê·ªÉ grasp quantum threat intuitively, consider classical cryptography nh∆∞ combination lock v·ªõi astronomical number of combinations. Modern 256-bit keys provide \\ 2^ 256 \\ possibilities - trying each combination sequentially requires longer than universe age even v·ªõi all computers on Earth. Security relies on sheer number c·ªßa possibilities making brute force infeasible. Quantum computers don't try combinations sequentially - they exist in superposition of all states simultaneously, collapsing to answer through quantum interference, exponentially accelerating search. Analogy with maze solving illustrates quantum advantage. Classical computer explores maze by trying paths sequentially - left corridor, dead end, backtrack, try right corridor, etc. Large maze requires exponential time exploring all branches. Quantum computer explores all paths simultaneously through superposition, measuring interference patterns revealing correct path directly. For cryptographic \"maze\" finding private key from public key, quantum computer's parallel exploration catastrophic for classical security assumptions. Shor's algorithm specifically targets mathematical structure c·ªßa discrete logarithm problem. Problem: given \\ y = g^x \\mod p\\ , find \\ x\\ . Classical algorithms baby-step giant-step, Pollard's rho require \\ O \\sqrt p \\ operations. For 256-bit curves, \\ \\sqrt 2^ 256 = 2^ 128 \\ operations - infeasible classically. Shor's algorithm uses quantum Fourier transform finding period c·ªßa modular exponentiation, solving in polynomial time \\ O \\log p ^3 \\ . Game-changer for cryptography. Post-quantum cryptographic schemes rely on mathematical problems believed hard even for quantum computers. Lattice problems involve finding shortest vector trong high-dimensional lattice - no known quantum algorithm providing exponential speedup. Hash-based signatures rely solely on collision resistance c·ªßa cryptographic hash functions, resistant to Grover's algorithm providing only quadratic speedup. Code-based cryptography uses error-correcting codes, believed quantum-resistant. These alternatives provide foundations for quantum-safe blockchain future. Migration analogy: transitioning infrastructure before old infrastructure fails. Like replacing bridge before it collapses, blockchain must migrate cryptography before quantum computers break current schemes. Waiting until quantum threat immediate risks catastrophic failure - private keys exposed suddenly, funds stolen en masse. Proactive migration enables gradual transition, testing, v√† fallback if issues arise. Hybrid cryptography during transition comparable to wearing belt AND suspenders. Use both classical ECDSA v√† post-quantum signatures simultaneously. Transaction valid only if both signatures verify. Provides security even if one scheme compromised. Doubles signature size temporarily but ensures continuous security throughout migration period. Once quantum threat materializes, drop classical component, having tested post-quantum thoroughly. --- 3. Technical Foundation Quantum algorithm threat analysis begins with Shor's algorithm complexity. For integer \\ N\\ with \\ n\\ bits, Shor's algorithm factors \\ N\\ or solves discrete log in time: \\ O n^3 \\text quantum operations \\ Classical best algorithms require: \\ O e^ 1.9 \\ln N ^ 1/3 \\ln \\ln N ^ 2/3 \\approx O e^ n^ 1/3 \\ Exponential vs polynomial - dramatic difference. For 256-bit elliptic curve discrete log: Classical: \\ O 2^ 128 \\ operations infeasible Quantum: \\ O 256^3 = 16,777,216\\ operations feasible! Grover's algorithm provides quadratic speedup for unstructured search. Finding preimage c·ªßa hash function: Classical: \\ O 2^n \\ for n-bit hash Quantum: \\ O 2^ n/2 \\ using Grover For SHA-256: - Classical: \\ 2^ 256 \\ operations impossible - Quantum: \\ 2^ 128 \\ operations still hard, but concerning Security effectively halved! 256-bit hash provides only 128-bit quantum security. Post-quantum signature schemes offer quantum resistance v·ªõi trade-offs: CRYSTALS-Dilithium lattice-based : python class DilithiumSignature: \"\"\"Simplified Dilithium signature scheme\"\"\" Parameters PUBLIC KEY SIZE = 1312 bytes Much larger than ECDSA 33 bytes SIGNATURE SIZE = 2420 bytes Much larger than ECDSA 64 bytes def keygen self : \"\"\"Generate key pair\"\"\" Lattice-based key generation Private: short vectors in lattice Public: random matrix + public vector pass def sign self, message, private key : \"\"\"Create signature\"\"\" Rejection sampling over lattice Output: z, c where z is response, c is challenge pass def verify self, message, signature, public key : \"\"\"Verify signature\"\"\" Check lattice relation holds Significantly slower than ECDSA ~10x pass SPHINCS+ hash-based : python class SPHINCS Plus: \"\"\"Hash-based signature quantum-safe \"\"\" PUBLIC KEY SIZE = 32 bytes Reasonable SIGNATURE SIZE = 7856 bytes VERY large! Security relies only on hash function collision resistance Grover only gives quadratic speedup Use SHA-256 ‚Üí 128-bit quantum security Or SHA-512 ‚Üí 256-bit quantum security Trade-off comparison: | Scheme | Public Key | Signature | Speed | Quantum Safe? | |--------|-----------|-----------|-------|---------------| | ECDSA | 33 bytes | 64 bytes | Fast | ‚ùå No | | Dilithium | 1312 bytes | 2420 bytes | Medium | ‚úÖ Yes | | SPHINCS+ | 32 bytes | 7856 bytes | Slow | ‚úÖ Yes | | Falcon | 897 bytes | 666 bytes | Fast | ‚úÖ Yes | --- 4. Mathematical / Cryptographic Formulation Lattice problems foundation cho many post-quantum schemes. Shortest Vector Problem SVP : Given lattice \\ L\\ , find shortest non-zero vector. Lattice defined by basis vectors: \\ L = \\ \\sum i=1 ^ n a i \\mathbf b i : a i \\in \\mathbb Z \\ \\ Best classical algorithm BKZ : \\ O 2^ n \\ Best quantum algorithm: \\ O 2^ n \\ no exponential speedup! Quantum resistance stems from no known quantum algorithm efficiently solving lattice problems. Learning With Errors LWE problem: Given samples \\ a i, b i \\ where: \\ b i = \\langle a i, s \\rangle + e i \\mod q \\ Find secret \\ s\\ . Small error \\ e i\\ makes problem hard classically AND quantumly. Grover impact on hash functions : Classical collision search: \\ O 2^ n/2 \\ birthday paradox Quantum collision search: \\ O 2^ n/3 \\ Grover-accelerated birthday For SHA-256 n=256 : - Classical security: 128 bits - Quantum security: ~85 bits Still secure but margin reduced. SHA-512 recommended for post-quantum: ~170-bit quantum security. --- 5. Implementation Insight python Post-quantum migration strategy simulation class QuantumResistantBlockchain: \"\"\"Blockchain with hybrid classical + post-quantum crypto\"\"\" def init self : self.accounts = self.quantum era = False Switch when quantum threat real def create hybrid address self : \"\"\"Generate address with both ECDSA and post-quantum keys\"\"\" Classical key ECDSA classical private = generate ecdsa key classical public = derive public key classical private Post-quantum key Dilithium pq private = generate dilithium key pq public = derive pq public pq private Hybrid address = hash classical pub + pq pub address = hash classical public + pq public return 'address': address, 'classical key': classical private, 'pq key': pq private, 'type': 'hybrid' def verify transaction self, tx : \"\"\"Verify transaction with hybrid signatures\"\"\" if self.quantum era: Post-quantum era: only check PQ signature return verify dilithium tx 'pq signature' , tx 'pq pubkey' else: Pre-quantum: check both belt + suspenders classical valid = verify ecdsa tx 'ecdsa signature' pq valid = verify dilithium tx 'pq signature' return classical valid and pq valid --- 6. Common Challenges / Attacks / Trade-offs Migration timing represents critical challenge. Migrate too early: waste resources on unnecessary overhead larger signatures, slower verification . Migrate too late: quantum computers break existing cryptography before migration complete. Monitoring quantum computing progress essential, but predicting breakthrough difficult - advances may occur suddenly. Signature size bloat impacts blockchain scalability severely. Post-quantum signatures 10-100√ó larger than ECDSA. Block size limits mean fewer transactions per block. Options: increase block size centralization concerns , compress signatures partially possible , accept lower throughput. No perfect solution - fundamental trade-off between quantum security v√† efficiency. --- 7. Related Concepts Quantum Key Distribution QKD provides information-theoretic security for communication but requires specialized hardware fiber optic cables, quantum repeaters . Not practical for blockchain's decentralized nature. Post-quantum cryptography based on mathematical hardness preferred - works on classical hardware, practical deployment. Hash-based signatures like SPHINCS+ fascinating because security reduces solely to hash function collision resistance. No structured problem factoring, discrete log, lattices involved. Using SHA-256, Grover provides only quadratic speedup, maintaining substantial security. Drawback: enormous signature sizes 7-8 KB per signature vs 64 bytes for ECDSA . --- 8. ‚≠ê Fundamental Papers / Whitepapers | Paper | Year | Author s | Contribution | |-------|------|-----------|--------------| | \"Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms on a Quantum Computer\" | 1994 | Peter Shor | Shor's algorithm - breaks RSA/ECDSA | | \"A Fast Quantum Mechanical Algorithm for Database Search\" | 1996 | Lov Grover | Grover's algorithm - weakens hash functions | | \"CRYSTALS-Dilithium: A Lattice-Based Digital Signature Scheme\" | 2018 | Ducas et al. | NIST PQC winner | | \"SPHINCS+: Stateless Hash-Based Signatures\" | 2019 | Bernstein et al. | Hash-based PQC signatures | | \"Quantum Resource Estimates for Computing Elliptic Curve Discrete Logarithms\" | 2017 | Roetteler et al. | Estimates qubits needed break ECDSA | --- 9. üé® Illustrations & Visual References Quantum Threat Timeline 2019: Google Quantum Supremacy 53 qubits 2022: IBM Osprey 433 qubits 2023: Atom Computing 1,225 qubits Needed to break ECDSA-256: ~4,000 logical qubits Millions of physical qubits with error correction Timeline: 10-30 years uncertain! Source: NIST Post-Quantum Cryptography https://csrc.nist.gov/projects/post-quantum-cryptography Signature Size Comparison | Algorithm | Public Key | Signature | Quantum Safe | |-----------|-----------|-----------|--------------| | ECDSA | 33 bytes | 64 bytes | ‚ùå | | Dilithium | 1,312 bytes | 2,420 bytes | ‚úÖ | | Falcon | 897 bytes | 666 bytes | ‚úÖ | | SPHINCS+ | 32 bytes | 7,856 bytes | ‚úÖ | --- 10. Summary Post-quantum cryptography essential for long-term blockchain security as quantum computing advances. Shor's algorithm threatens current ECDSA signatures, requiring migration to quantum-resistant schemes based on lattice problems, hash functions, ho·∫∑c error-correcting codes. While quantum computers capable c·ªßa breaking blockchain cryptography estimated 10-30 years away, proactive preparation necessary given migration complexity v√† stakes involved. NIST standardization provides quantum-safe algorithms ready for deployment. Challenge lies trong managing trade-offs - larger signatures, slower verification, increased bandwidth requirements - while ensuring smooth migration without disrupting existing ecosystems. Understanding post-quantum cryptography fundamentals enables informed participation in blockchain's quantum transition planning. --- ‚úÖ End of Lecture Next: Lecture 05.05 - Advanced Privacy Techniques --- References 1. Shor, P. W. 1994 . Polynomial-time algorithms for prime factorization and discrete logarithms on a quantum computer . FOCS 1994. 2. NIST. 2024 . Post-Quantum Cryptography Standardization . https://csrc.nist.gov/projects/post-quantum-cryptography 3. Roetteler, M., et al. 2017 . Quantum resource estimates for computing elliptic curve discrete logarithms . ASIACRYPT 2017.",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter05/blockchain-chapter05/05_04_Post_Quantum_Cryptography/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter05/blockchain-chapter05/05_05_Advanced_Privacy",
    "title": "Lecture 05.05: Advanced Privacy Techniques - Confidential Transactions v√† Beyond",
    "chapter": "05",
    "order": 6,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Advanced Privacy Techniques - Confidential Transactions v√† Beyond 1. Concept Overview Advanced privacy techniques extend beyond basic mixing v√† pseudonymity, implementing cryptographic protocols enabling transactions completely hide amounts, asset types, v√† participant identities whilst maintaining verifiability c·ªßa blockchain properties nh∆∞ double-spend prevention v√† supply auditability. These techniques represent cutting edge c·ªßa blockchain privacy research, balancing regulatory compliance needs v·ªõi individual privacy rights through selective disclosure mechanisms. Confidential Transactions , proposed by Adam Back v√† implemented in Monero v√† Elements Bitcoin sidechain , hide transaction amounts using Pedersen commitments . Observers see encrypted amounts, cryptographic proofs guarantee inputs equal outputs no inflation without revealing actual values. This solves major privacy weakness - even if addresses unlinkable, transaction amounts leaking valuable information v·ªÅ business operations, wealth levels, v√† spending patterns. Confidential Assets extends concept enabling single blockchain support multiple asset types privately. Liquid Network implementation allows creating custom assets stablecoins, securities, loyalty points transferable privately. Users see only that transaction occurred, not which asset type transferred nor amounts. This enables regulated assets v·ªõi compliance requirements satisfied through selective disclosure to authorized parties whilst maintaining privacy from general public. Bulletproofs , developed by Benedikt B√ºnz v√† others nƒÉm 2017, dramatically improved confidential transaction efficiency. Previous range proofs proving amount within valid range without revealing value required ~5 KB per proof. Bulletproofs compress n√†y to ~600 bytes, 8√ó improvement enabling practical deployment. Monero adopted Bulletproofs nƒÉm 2018, reducing transaction sizes v√† fees substantially whilst maintaining strong privacy guarantees. Mimblewimble protocol, mysteriously proposed nƒÉm 2016 on Bitcoin research IRC by pseudonymous \"Tom Elvis Jedusor\", reimagines blockchain structure entirely for privacy. Combines confidential transactions v·ªõi CoinJoin-like aggregation v√† cut-through eliminating spent outputs. Blockchain stores only unspent outputs v·ªõi commitments, history pruned continuously. Result: compact blockchain 10s of GB vs 500+ GB for Bitcoin v·ªõi built-in privacy. Grin v√† Beam implement Mimblewimble, demonstrating feasibility though adoption limited. Regulatory tension increasing between privacy coins v√† compliance requirements. Many exchanges delisted Monero, Zcash, Dash under regulatory pressure. Travel Rule requirements demand exchanges share sender/receiver information for transactions exceeding thresholds. Privacy-preserving compliance solutions emerging - zero-knowledge proofs enabling prove regulatory compliance without revealing transaction details to counterparties. Example: prove transaction not to sanctioned entity without revealing actual destination. --- 2. Intuitive Understanding Confidential Transactions comparable to sealed envelopes containing cash. Observer sees envelope passed t·ª´ Alice to Bob transaction occurred , but cannot see amount inside value hidden . To prevent cheating Alice claiming envelope contains MATH 0 , cryptographic commitment binds Alice to value without revealing it. Verification checks envelope weights match inputs = outputs without opening envelopes. Pedersen commitment scheme conceptually like locking box. Value \\ v\\ placed in box with random key \\ r\\ . Commitment \\ C = vG + rH\\ where \\ G, H\\ are public elliptic curve points. Properties: cannot determine \\ v\\ from \\ C\\ hiding , cannot change \\ v\\ after committing binding , commitments homomorphic combine mathematically . Box analogy: cannot see inside, cannot change contents after locking, can weigh boxes together. Range proofs ensure committed values valid positive, within bounds without revealing amounts. Imagine proving age over 18 without showing birth certificate. Cryptographic protocol enables construct proof of age range satisfaction, verifier checks proof mathematically, conviction achieved without learning exact age. Similarly, range proofs demonstrate transaction amounts positive v√† below maximum, preventing inflation attacks whilst preserving privacy. Mimblewimble's cut-through comparable to canceling intermediate transactions trong accounting. Traditional blockchain: Alice‚ÜíBob 1 BTC, Bob‚ÜíCharlie 1 BTC, both recorded permanently. Mimblewimble: Alice‚ÜíCharlie 1 BTC directly, intermediate step removed. Blockchain stores only final state, not complete history. Like bank statement showing only net transactions rather than every debit/credit pair. Privacy improved less information public , blockchain smaller less storage , verification faster fewer transactions check . Selective disclosure mechanisms analogous to graduated NDAs non-disclosure agreements . General public sees nothing strong privacy . Regulators see everything compliance . Business partners see relevant subset functional necessity . Zero-knowledge proofs enable prove statement to regulator \"transaction not to sanctioned entity\" without revealing to general public. Cryptographic access control replacing legal access control, enforced mathematically rather than contractually. --- 3. Technical Foundation Pedersen commitments mathematically constructed using elliptic curve points. Given value \\ v\\ v√† random blinding factor \\ r\\ : \\ C v, r = vG + rH \\ Where \\ G, H\\ generator points v·ªõi unknown discrete log relationship. Properties : Hiding: Given \\ C\\ , computationally infeasible determine \\ v\\ discrete log hard Binding: Cannot find \\ v', r' \\neq v, r \\ where \\ C v,r = C v',r' \\ requires solving discrete log Homomorphic: \\ C v 1, r 1 + C v 2, r 2 = C v 1+v 2, r 1+r 2 \\ Transaction verification uses homomorphic property: \\ \\sum \\text Input Commitments = \\sum \\text Output Commitments \\ Proves inputs = outputs without revealing amounts! Range proof demonstrates \\ v \\in 0, 2^ 64 \\ without revealing \\ v\\ . Bulletproofs construction: \\ \\text Proof Size = O \\log n \\text where n = \\text range size \\ For 64-bit range: ~600 bytes. --- 5. Implementation Insight python class PedersenCommitment: \"\"\"Simplified Pedersen commitment educational \"\"\" def init self, G, H, curve order : self.G = G Generator point 1 self.H = H Generator point 2 unknown discrete log to G self.n = curve order def commit self, value, blinding factor : \"\"\"Create commitment C = vG + rH\"\"\" commitment = value self.G + blinding factor self.H return commitment def verify sum self, input commitments, output commitments : \"\"\"Verify sum inputs = sum outputs \"\"\" sum inputs = sum input commitments sum outputs = sum output commitments return sum inputs == sum outputs def create confidential transaction self, inputs, outputs : \"\"\"Create transaction hiding amounts\"\"\" Create commitments for outputs output commitments = for value in outputs: r = random.randint 1, self.n C = self.commit value, r output commitments.append C Prove inputs = outputs without revealing amounts In production: include range proofs return 'input commitments': input commitments, 'output commitments': output commitments --- 6. Common Challenges / Attacks / Trade-offs Confidential Transactions increase transaction size substantially. Range proofs add ~600 bytes Bulletproofs per output. For transactions v·ªõi multiple outputs, overhead accumulates. Monero transactions typically 2-3 KB vs Bitcoin's ~250 bytes. Network bandwidth v√† storage requirements increase proportionally, affecting decentralization - fewer users can run full nodes. Regulatory acceptance remains uncertain. While privacy valuable, regulators concerned v·ªÅ money laundering, terrorist financing, tax evasion. Privacy coins face delisting from exchanges, banking restrictions, potential outright bans in some jurisdictions. Selective disclosure mechanisms attempt bridge divide but adoption slow, regulatory frameworks unclear. --- 7. Related Concepts Homomorphic encryption enables computation on encrypted data. Could enable private smart contracts - computations on encrypted balances, results encrypted too. Research active but practical deployment distant - performance overhead enormous, limited operation support currently. Secure multi-party computation MPC allows multiple parties jointly compute function without revealing inputs. Potential for private auctions, voting, negotiations on blockchain. Threshold signatures use MPC, demonstrating blockchain applicability. --- 8. ‚≠ê Fundamental Papers / Whitepapers | Paper | Year | Author s | Contribution | |-------|------|-----------|--------------| | \"Confidential Transactions\" | 2016 | Adam Back | Hiding amounts via Pedersen commitments | | \"Bulletproofs: Short Proofs for Confidential Transactions\" | 2017 | B√ºnz et al. | Efficient range proofs | | \"Mimblewimble\" | 2016 | Tom Elvis Jedusor | Privacy-focused blockchain design | | \"Zcash Protocol Specification\" | 2016 | Zcash team | Comprehensive privacy via zk-SNARKs | --- 9. üé® Illustrations & Visual References Source: Monero Documentation https://www.getmonero.org/resources/moneropedia/ --- 10. Summary Advanced privacy techniques enable hiding transaction amounts, asset types, v√† participants using cryptographic commitments, range proofs, v√† zero-knowledge protocols. Confidential Transactions via Pedersen commitments provide amount privacy whilst preserving verifiability. Bulletproofs make range proofs practical. Mimblewimble reimagines blockchain structure for privacy v√† scalability combined. Trade-offs include increased transaction sizes, computational overhead, v√† regulatory uncertainty. Despite challenges, advanced privacy essential for blockchain serving real-world financial needs where confidentiality critical. Understanding these techniques enables building privacy-preserving applications whilst evaluating privacy guarantees ◊©◊ú existing protocols critically. --- ‚úÖ End of Lecture End of Chapter 05 - Privacy & Security Next: Chapter 07 - Advanced Topics --- References 1. Back, A. 2016 . Confidential Transactions . Bitcoin Elements Project. 2. B√ºnz, B., et al. 2017 . Bulletproofs: Short proofs for confidential transactions and more . IEEE S&P 2018. 3. Poelstra, A., et al. 2016 . Mimblewimble . https://github.com/mimblewimble/docs",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter05/blockchain-chapter05/05_05_Advanced_Privacy/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter06/blockchain-chapter06/06_00_Cross_Chain_Communication",
    "title": "Lecture 06.00: Cross-Chain Communication - K·∫øt n·ªëi c√°c Blockchain",
    "chapter": "06",
    "order": 1,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Cross-Chain Communication - K·∫øt n·ªëi c√°c Blockchain 1. Concept Overview Blockchain interoperability, hay kh·∫£ nƒÉng c√°c blockchain kh√°c nhau communicate v√† exchange value v·ªõi nhau, represents m·ªôt trong nh·ªØng challenges quan tr·ªçng nh·∫•t trong blockchain ecosystem evolution. Hi·ªán t·∫°i, landscape bao g·ªìm h√†ng trƒÉm blockchains ƒë·ªôc l·∫≠p - Bitcoin, Ethereum, Binance Smart Chain, Solana, Polkadot, Cosmos, v√† countless others - m·ªói c√°i operating nh∆∞ isolated island v·ªõi own consensus, token standards, v√† application ecosystems. Situation n√†y t·∫°o ra fragmentation harmful cho user experience v√† capital efficiency. Historical context c·ªßa interoperability problem b·∫Øt ngu·ªìn t·ª´ early days c·ªßa blockchain. Ban ƒë·∫ßu, Bitcoin existed alone, v√† interoperability kh√¥ng ph·∫£i concern. Khi Ethereum launched nƒÉm 2015, bringing smart contracts v√† token standards m·ªõi, nhu c·∫ßu move value gi·ªØa Bitcoin v√† Ethereum emerged. Users mu·ªën use Bitcoin's liquidity tr√™n Ethereum's DeFi platforms, nh∆∞ng kh√¥ng c√≥ native mechanism cho cross-chain transfers. Early solutions crude v√† centralized - exchanges acting nh∆∞ intermediaries, custodial bridges requiring trust. NƒÉm 2017-2018, atomic swaps emerged nh∆∞ first trustless cross-chain solution. Concept introduced b·ªüi Tier Nolan nƒÉm 2013 nh∆∞ng implemented th·ª±c s·ª± sau. Atomic swaps s·ª≠ d·ª•ng Hash Time-Locked Contracts HTLCs ƒë·ªÉ enable peer-to-peer exchanges across chains without intermediaries. Alice tr√™n Bitcoin c√≥ th·ªÉ swap v·ªõi Bob tr√™n Litecoin m·ªôt c√°ch trustless, guaranteed r·∫±ng either both transfers complete ho·∫∑c neither does. Innovation n√†y showed cryptographic protocols c√≥ th·ªÉ replace trusted third parties trong cross-chain scenarios. NƒÉm 2018-2020, bridge protocols proliferated. Wrapped Bitcoin WBTC launched nƒÉm 2019, becoming successful cross-chain asset. WBTC l√† ERC-20 token tr√™n Ethereum backed one-to-one b·ªüi Bitcoin locked trong custody. Despite centralization concerns v·ªÅ custodians, WBTC enabled billions of dollars Bitcoin participate trong Ethereum DeFi, demonstrating massive demand cho interoperability. Other wrapped assets followed - renBTC, tBTC, WETH - each v·ªõi different trust models v√† mechanisms. Polkadot v√† Cosmos , launched 2020, represented architectural approaches kh√°c. Instead of bridging existing chains, they designed ecosystems from ground up for interoperability. Polkadot's parachain model enables specialized blockchains share security c·ªßa relay chain trong khi communicating seamlessly. Cosmos's IBC Inter-Blockchain Communication protocol defines standard cho independent chains communicate, creating \"internet of blockchains.\" These approaches showed interoperability could be fundamental design principle rather than afterthought. NƒÉm 2021-2024 witnessed explosion c·ªßa bridge protocols v√† devastating security breaches. Ronin bridge hack MATH 611M , Wormhole MATH 2 billion, making interoperability not just technical challenge but critical security concern. This drove research into more secure bridge designs, formal verification, v√† alternative approaches nh∆∞ cross-chain messaging protocols v√† shared security models . --- 2. Intuitive Understanding ƒê·ªÉ hi·ªÉu interoperability challenge deeply, h√£y imagine blockchain ecosystems nh∆∞ countries v·ªõi own currencies, laws, v√† languages. Bitcoin nh∆∞ United States v·ªõi Dollar, Ethereum nh∆∞ European Union v·ªõi Euro, Solana nh∆∞ Japan v·ªõi Yen. M·ªói country self-sovereign, v·ªõi own rules v√† systems. Citizen c·ªßa m·ªôt country mu·ªën trade v·ªõi citizen c·ªßa country kh√°c faces numerous frictions: currency exchange rates, incompatible legal systems, communication barriers. Traditional solution trong international trade l√† intermediaries - banks facilitate currency conversion, shipping companies handle logistics, customs agents verify compliance. Blockchain bridges serve similar role - acting nh∆∞ intermediaries facilitating asset transfers v√† message passing gi·ªØa incompatible blockchains. However, introducing intermediaries contradicts blockchain's trustless philosophy, creating tension fundamental. H√£y visualize problem n√†y qua analogy c·ª• th·ªÉ. Alice owns Bitcoin v√† mu·ªën participate trong Ethereum DeFi protocol Uniswap. Bitcoin blockchain v√† Ethereum blockchain completely separate - they don't share validators, don't read each other's state, don't have common language. Alice cannot simply \"send\" Bitcoin ƒë·∫øn Ethereum address - fundamentally incompatible. She needs mechanism ƒë·ªÉ represent Bitcoin value on Ethereum. Simple approach: Alice sends Bitcoin ƒë·∫øn custodian v√≠ d·ª• BitGo , custodian mints equivalent WBTC on Ethereum, Alice receives WBTC trong Ethereum wallet. Now she c√≥ th·ªÉ use WBTC tr√™n Uniswap. When done, reverse process: burn WBTC, custodian releases Bitcoin. This works nh∆∞ng requires trusting custodian - single point of failure. If custodian malicious ho·∫∑c compromised, funds at risk. Kh√¥ng truly decentralized. Trustless alternative: Hash Time-Locked Contracts HTLCs enable atomic swaps. Think of HTLCs nh∆∞ coordinated safe deposit boxes v·ªõi time locks. Alice v√† Bob each lock funds trong boxes v·ªõi same secret key hash. Alice sets: \"My box opens v·ªõi secret OR after 48 hours refund me.\" Bob sets: \"My box opens v·ªõi same secret OR after 24 hours refund me.\" Alice reveals secret to claim Bob's funds, automatically enabling Bob claim Alice's funds v·ªõi same secret. If either party fails cooperate, time locks ensure refunds. No trust needed - cryptography v√† time locks guarantee fairness. Modern bridges extend HTLCs concept v·ªõi sophisticated protocols. Light clients allow one blockchain verify state c·ªßa another blockchain without running full node. Ethereum contract c√≥ th·ªÉ verify Bitcoin transaction occurred b·∫±ng c√°ch checking merkle proof against Bitcoin block header. This enables trustless verification, but implementation complexity high v√† gas costs substantial. Trade-off between security full verification v√† practicality cost, complexity persists. Shared security models nh∆∞ Polkadot's parachains offer different approach. Instead of independent blockchains bridging afterward, start v·ªõi shared security layer. All parachains protected by same validator set, making communication trustless by design. Analogy: European Union v·ªõi shared laws v√† institutions. Member states specialized nh∆∞ng operate under common framework, enabling seamless interaction. Trade-off: less sovereignty parachains must follow relay chain rules for better interoperability. --- 3. Technical Foundation Cross-chain communication protocols build on several technical primitives requiring deep understanding. Hash Time-Locked Contracts HTLCs form foundation c·ªßa many approaches. HTLC construction involves two linked contracts - one on each blockchain - using cryptographic hash function v√† time-based conditions ƒë·ªÉ coordinate atomic execution. Contract structure includes hashlock reveals preimage to claim funds v√† timelock refund if deadline passes . Mathematical guarantee ensures atomicity: either both parties receive funds OR both get refunded. Bitcoin implements HTLCs through Script opcodes specifically. Script sequence typically includes OP IF checking whether timeout passed, OP SHA256 verifying hash preimage, v√† OP CHECKSIG validating signatures. Complete HTLC script tr√™n Bitcoin: OP IF OP SHA256 OP EQUALVERIFY OP CHECKSIG OP ELSE OP CHECKLOCKTIMEVERIFY OP DROP OP CHECKSIG OP ENDIF Ethereum HTLCs implemented through Solidity smart contracts v·ªõi more flexibility. Contract maintains state mapping tracking pending swaps, timeouts, v√† completions. Sender initiates swap by calling initiate v·ªõi hash, amount, timeout, v√† recipient. Recipient claims calling claim with preimage. If timeout expires before claim, sender calls refund to retrieve funds. All operations atomic within respective blockchains, v√† hash linkage ensures atomicity across chains. solidity contract HTLC struct Swap address sender; address receiver; uint256 amount; bytes32 hash; uint256 timeout; bool completed; bool refunded; mapping bytes32 => Swap public swaps; function initiate address receiver, bytes32 hash, uint256 timeout external payable bytes32 swapId = keccak256 abi.encodePacked msg.sender, receiver, hash ; require swaps swapId .sender == address 0 , \"Swap exists\" ; swaps swapId = Swap sender: msg.sender, receiver: receiver, amount: msg.value, hash: hash, timeout: block.timestamp + timeout, completed: false, refunded: false ; function claim bytes32 swapId, bytes32 preimage external Swap storage swap = swaps swapId ; require !swap.completed && !swap.refunded, \"Swap already settled\" ; require sha256 abi.encodePacked preimage == swap.hash, \"Invalid preimage\" ; require block.timestamp = swap.timeout, \"Timeout not reached\" ; require msg.sender == swap.sender, \"Not sender\" ; swap.refunded = true; payable swap.sender .transfer swap.amount ; Light client verification enables one blockchain read state c·ªßa another trustlessly. Light client stores only block headers approximately 80 bytes per block cho Bitcoin , verifying headers chain correctly via proof-of-work. To verify transaction included, client requests merkle proof t·ª´ full node, verifies against header's merkle root. This allows Ethereum contract verify Bitcoin transaction v·ªõi minimal storage v√† computation. Implementation challenge: keeping headers updated costs gas. Solutions include incentivized relayers submitting headers periodically, v√† only updating when verification needed. Relay chains approach problem differently. Instead of direct chain-to-chain communication, introduce intermediary chain coordinating multiple blockchains. Polkadot's relay chain validates parachain blocks, ensuring correctness globally. Parachains submit block candidates, relay chain validators verify, finalize valid blocks. Cross-chain messages routed through relay chain, which guarantees delivery v√† ordering. Security model relies on relay chain's validator set protecting all parachains simultaneously - shared security preventing individual chain compromises. Inter-Blockchain Communication IBC protocol developed by Cosmos takes modular approach. IBC defines standard for sovereign blockchains communicate while maintaining independence. Protocol operates in layers: transport layer reliable packet delivery , authentication layer verify sender , v√† ordering layer guarantee message sequence . Each blockchain runs IBC module implementing these layers, enabling message passing without shared security. Trust model assumes each chain properly securing itself, v·ªõi IBC providing communication infrastructure. State verification across chains requires cryptographic proofs robust. Merkle proofs insufficient alone - need prove block headers valid according to source chain's consensus rules. For PoW chains, proving header valid means showing sufficient work done. For PoS chains, requires proving validator signatures correct v√† validators properly staked. For BFT chains, proving quorum signatures valid. Each consensus mechanism requires different verification logic, adding complexity to bridge implementations. --- 4. Mathematical / Cryptographic Formulation Atomic swap security analysis reveals cryptographic guarantees ensuring fairness. Consider Alice on Bitcoin wanting swap v·ªõi Bob on Ethereum. Protocol uses secret \\ s\\ , hash \\ h = H s \\ , v√† timeouts \\ t A, t B\\ where \\ t B t A \\end cases \\ Bob's Contract Ethereum, timeout \\ t B\\ : \\ \\text Locked \\to \\begin cases \\text Alice & \\text if \\text reveals s: H s = h \\\\ \\text Bob & \\text if \\text time > t B \\end cases \\ Atomicity Proof : Case 1 : Bob claims Alice's Bitcoin before \\ t B\\ - Bob must reveal \\ s\\ - Alice observes \\ s\\ , claims Bob's ETH before \\ t B\\ - Both transfers succeed ‚úì Case 2 : Bob doesn't claim before \\ t B\\ - Bob's timeout expires first \\ t B \\text Max block time difference + \\text Network latency \\ Ensures Alice has time to claim after Bob reveals secret. Light client verification complexity : For blockchain v·ªõi headers \\ H 1, H 2, ..., H n\\ , storing all headers requires: \\ \\text Storage = n \\times |H| \\text bytes \\ Bitcoin header: 80 bytes Current height: ~850,000 blocks Total: 68 MB On Ethereum expensive storage , cost prohibitive. Solutions: 1. Store only recent headers 2. Store checkpoints + proofs 3. Use relay services Merkle proof verification for transaction \\ T x\\ in block \\ B k\\ : Verifier needs: - Block header \\ H k\\ 80 bytes - Merkle proof path \\ P\\ \\ \\log 2 n\\ hashes where \\ n\\ = transactions in block Verification computes: \\ \\text root = \\text MerkleCompute T x, P \\ Checks: \\ \\text root \\stackrel ? = H k.\\text merkleRoot \\ Cost: \\ O \\log n \\ hash operations, constant storage. IBC packet verification requires proving packet committed on source chain. For packet \\ p\\ v·ªõi commitment \\ c\\ : Source chain stores: \\ c = H p.\\text sequence , p.\\text data , p.\\text timeout \\ Destination verifies: 1. Commitment exists in source state 2. Source state valid via consensus proof 3. Packet not timed out Verification equation: \\ \\text Verify \\text stateProof , \\text commitment \\land \\text time swap data def initiate swap self, sender: str, receiver: str, amount: float, hash lock: bytes, timeout seconds: int, chain: str -> str: \"\"\" Initiate HTLC swap Args: sender: Initiator address receiver: Counterparty address amount: Amount to lock hash lock: Hash of secret sha256 timeout seconds: Time until refund allowed chain: Which blockchain BTC/ETH \"\"\" swap id = hashlib.sha256 f\" sender receiver hash lock.hex chain \".encode .hexdigest swap = 'id': swap id, 'sender': sender, 'receiver': receiver, 'amount': amount, 'hash lock': hash lock, 'timeout': time.time + timeout seconds, 'chain': chain, 'state': 'INITIATED', 'secret': None self.swaps swap id = swap print f\"‚úì HTLC Swap initiated on chain \" print f\" Swap ID: swap id :16 ...\" print f\" sender ‚Üí receiver \" print f\" Amount: amount \" print f\" Timeout: timeout seconds s\" return swap id def claim swap self, swap id: str, secret: bytes -> bool: \"\"\" Claim funds by revealing secret Args: swap id: Swap identifier secret: Preimage of hash lock \"\"\" if swap id not in self.swaps: print \"‚úó Swap not found\" return False swap = self.swaps swap id Verify swap not already completed/refunded if swap 'state' != 'INITIATED': print f\"‚úó Swap already swap 'state' \" return False Verify timeout not expired if time.time >= swap 'timeout' : print \"‚úó Timeout expired\" return False Verify secret matches hash secret hash = hashlib.sha256 secret .digest if secret hash != swap 'hash lock' : print \"‚úó Invalid secret\" return False Claim successful! swap 'state' = 'CLAIMED' swap 'secret' = secret print f\"‚úì Swap swap id :16 ... CLAIMED on swap 'chain' \" print f\" Receiver: swap 'receiver' \" print f\" Amount: swap 'amount' \" print f\" Secret revealed: secret.hex :16 ...\" return True def refund swap self, swap id: str -> bool: \"\"\" Refund swap after timeout Args: swap id: Swap identifier \"\"\" if swap id not in self.swaps: return False swap = self.swaps swap id if swap 'state' != 'INITIATED': print f\"‚úó Swap already swap 'state' \" return False if time.time | | | 3. Verify BTC lock | | 4. Lock ETH with h, timeout 24h | | | | 6. See secret s revealed | | 7. Claim BTC with secret s | $2 billion demonstrate vulnerability c·ªßa cross-chain infrastructure. Concentrating value trong bridges creates honeypots attracting sophisticated attackers. Defense requires multi-layered approach: secure validator sets geographic diversity, key management , robust smart contract code formal verification, audits , monitoring systems anomaly detection , v√† economic security insurance funds, slashing . Mathematical guarantees underpin trustless approaches. HTLCs prove atomicity through hash preimage requirements v√† time locks. Light client verification proves transaction inclusion through merkle proofs v√† consensus verification. Zero-knowledge proofs enable succinct state verification. Understanding these cryptographic foundations essential for evaluating bridge security claims. Future directions include shared sequencing across rollups, intent-based cross-chain protocols where users express desired outcomes rather than specific paths, v√† standardization efforts like EIP-5164 Cross-Chain Execution . As blockchain ecosystem matures, interoperability transitions from nice-to-have feature to fundamental infrastructure requirement. Mastering cross-chain communication concepts positions developers v√† researchers at forefront c·ªßa blockchain's next evolution phase. --- ‚úÖ End of Lecture Next: Lecture 06.01 - Blockchain Bridges: Architecture v√† Security --- References 1. Nolan, T. 2013 . Atomic Cross-Chain Swaps . BitcoinTalk Forum. 2. Wood, G. 2016 . Polkadot: Vision for a Heterogeneous Multi-Chain Framework . Polkadot Whitepaper. 3. Kwon, J., & Buchman, E. 2016 . Cosmos: A Network of Distributed Ledgers . Cosmos Whitepaper. 4. Cosmos Network. 2020 . IBC Protocol Specification . https://github.com/cosmos/ibc 5. LayerZero Labs. 2021 . LayerZero: Trustless Omnichain Interoperability Protocol . LayerZero Whitepaper. 6. L2Beat Team. 2024 . Bridge Risk Framework . https://l2beat.com/bridges/risk",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter06/blockchain-chapter06/06_00_Cross_Chain_Communication/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter06/blockchain-chapter06/06_01_Blockchain_Bridges",
    "title": "Lecture 06.01: Blockchain Bridges - Architecture, Security, v√† Trade-offs",
    "chapter": "06",
    "order": 2,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Blockchain Bridges - Architecture, Security, v√† Trade-offs 1. Concept Overview Blockchain bridges l√† critical infrastructure enabling value v√† information flow gi·ªØa isolated blockchain networks. Trong blockchain landscape hi·ªán t·∫°i v·ªõi hundreds of independent chains, bridges serve nh∆∞ highways connecting separate islands, facilitating asset transfers, message passing, v√† cross-chain application logic. However, bridges c≈©ng represent m·ªôt trong nh·ªØng vulnerable components trong entire ecosystem, v·ªõi total losses from bridge exploits exceeding two billion dollars, making bridge security arguably the most pressing challenge trong blockchain interoperability. Historical evolution c·ªßa bridges reflects growing sophistication trong approach v√† painful lessons t·ª´ security breaches. Early bridges extremely primitive - centralized exchanges acting nh∆∞ intermediaries, requiring users trust third parties completely. Users deposit Bitcoin on exchange, exchange credits account, users withdraw equivalent value tr√™n different chain. This model contradicted blockchain's trustless philosophy entirely nh∆∞ng remained dominant method for years due to simplicity v√† liquidity. First generation decentralized bridges emerged 2017-2019. Wrapped Bitcoin WBTC , launched January 2019, introduced custodial model v·ªõi semi-decentralized governance. Bitcoin locked by custodians BitGo initially , merchants mint corresponding ERC-20 tokens on Ethereum, smart contract manages minting/burning. While custodians centralized, transparency improved through on-chain reserves verification. WBTC rapidly became dominant Bitcoin representation on Ethereum, demonstrating massive demand for trustless Bitcoin in DeFi despite trust assumptions inherent trong design. RenVM launched 2020 v·ªõi different approach - distributed custody through secure multi-party computation. Instead of single custodian holding private keys, RenVM split keys across network of nodes using threshold signatures. No single node could access funds unilaterally. This reduced custodial risk significantly but introduced complexity v√† novel attack vectors. RenVM demonstrated feasibility of decentralized custody at scale, managing billions in assets across multiple chains. Validator-based bridges proliferated 2020-2021. Polygon PoS bridge , Avalanche bridge , v√† Binance bridge used validator sets monitoring source chain, signing off on transfers to destination chain. Security depended on honest majority among validators - typically multi-signature schemes requiring threshold signatures. Economics incentivized honest behavior through validator stakes subject to slashing. However, validator set often small 9-21 validators common , creating attack surface if validators compromised. Optimistic bridges emerged inspired by optimistic rollup success. Nomad bridge launched 2021 used fraud proof model - assumed transfers valid, allowed watchers challenge invalid transfers within time window. Single honest watcher sufficient for security. Tragically, implementation bug in Nomad August 2022 led to $190M loss when attacker exploited verification flaw, enabling anyone drain bridge completely. This demonstrated optimistic approach's vulnerability - single bug catastrophic. Zero-knowledge bridges represent cutting edge, using zk-SNARKs verify source chain state cryptographically. zkBridge v√† similar projects prove transaction occurred on source chain via succinct proof verified on destination chain. No external validators needed - cryptography alone provides security. However, proving complex consensus mechanisms like PoS v·ªõi slashing through ZK circuits extremely challenging, limiting current applicability. NƒÉm 2022 witnessed \"year of bridge hacks\" - Ronin MATH 325M , Nomad MATH 100M . These disasters forced industry rethink bridge security fundamentally. Current trend toward reducing bridge surface area through alternative approaches: native multi-chain assets, shared sequencing across rollups, application-specific bridges v·ªõi limited functionality reducing attack surface. --- 2. Intuitive Understanding ƒê·ªÉ comprehend bridge security challenges intuitively, imagine bridges nh∆∞ literal physical bridges connecting islands. Strong bridge supports heavy traffic safely. Weak bridge collapses under load, causing catastrophic damage. Blockchain bridges similar - they must support potentially billions of dollars value transfer while resisting sophisticated attacks t·ª´ adversaries v·ªõi huge economic incentives. Consider custodial bridge model through bank analogy. Traditional bank vault holds valuable assets. Single entity controls vault, customers trust bank not steal ho·∫∑c lose assets. Custodial bridge identical - Bitcoin locked trong vault multisig address , trusted entities control keys, users trust they won't abscond v·ªõi funds. Security reduces entirely to physical security c·ªßa custodians v√† honesty c·ªßa entities involved. This centralization contradicts blockchain ethos but provides simplicity v√† efficiency. Validator-based bridges analogous to committee approval system. Imagine international border crossing requiring approval t·ª´ committee of border guards. Transaction submitted, majority guards must verify v√† sign approval before allowing passage. Security depends on majority guards honest. If attackers bribe ho·∫∑c compromise enough guards, can approve fraudulent transactions. Blockchain bridges using validator sets face identical challenge - validators become high-value targets, v√† coordinator failure means total bridge compromise. Light client bridges comparable to verification through official documents. When traveling internationally, present passport, border control verifies document authentic by checking security features, holograms, stamps. Light client similar - contract on destination chain verifies cryptographic proofs from source chain block headers, merkle proofs, signatures . No trust in external parties needed - pure cryptographic verification. However, complexity high v√† verification costly gas , limiting practicality. Hash time-locked contracts HTLCs comparable to escrow v·ªõi time limits. Imagine two people exchanging houses directly without title company. Both deposit keys into locked boxes v·ªõi same secret combination. Boxes programmed: open v·ªõi secret OR automatically return keys after deadline. First person revealing secret claims counterparty's house, enabling counterparty claim original house v·ªõi same secret. If either backs out, deadlines ensure both get refunds. No trust needed - mechanism design guarantees fairness. Zero-knowledge bridge verification analogous to airport security. Instead of examining every item trong luggage individually, X-ray provides proof luggage safe without opening bags. ZK proofs provide cryptographic guarantee transaction occurred on source chain without replaying entire transaction history on destination chain. Verification succinct constant time/space regardless of what being proven, enabling efficient cross-chain verification. --- 3. Technical Foundation Bridge architecture varies dramatically across implementations, but core components remain consistent across designs. Every bridge must solve fundamental problems: verify events on source chain, represent assets on destination chain, handle failures gracefully, prevent double-spending, v√† maintain economic security sufficient to deter attacks. Custodial bridge architecture simplest conceptually but requires strongest trust assumptions. Architecture consists of custody layer holds locked assets , minting layer creates wrapped tokens , v√† governance layer manages custodians . Bitcoin locked in multisig address controlled by custodians. When user deposits, custodian verifies Bitcoin transaction, coordinates with merchant, merchant mints WBTC on Ethereum. Withdrawal reverses process - user burns WBTC, custodian releases Bitcoin. Security entirely dependent on custodian honesty v√† key security. solidity contract CustodialBridge address public custodians; uint256 public threshold; // n-of-m multisig mapping bytes32 => bool public processedBTCTxs; mapping address => uint256 public wrappedBalances; event Minted address indexed to, uint256 amount, bytes32 btcTxHash ; event Burned address indexed from, uint256 amount, string btcAddress ; / @dev Custodians mint wrapped tokens after verifying BTC deposit / function mint address to, uint256 amount, bytes32 btcTxHash, bytes memory signatures external require !processedBTCTxs btcTxHash , \"Already processed\" ; require verifySignatures signatures, btcTxHash, amount, to , \"Invalid signatures\" ; processedBTCTxs btcTxHash = true; wrappedBalances to += amount; emit Minted to, amount, btcTxHash ; / @dev Users burn to withdraw / function burn uint256 amount, string memory btcAddress external require wrappedBalances msg.sender >= amount, \"Insufficient balance\" ; wrappedBalances msg.sender -= amount; emit Burned msg.sender, amount, btcAddress ; // Custodians monitor event, release BTC to btcAddress function verifySignatures bytes memory signatures, bytes32 txHash, uint256 amount, address recipient internal view returns bool bytes32 message = keccak256 abi.encodePacked txHash, amount, recipient ; uint256 validSigs = 0; for uint i = 0; i = threshold; function isCustodian address addr internal view returns bool for uint i = 0; i BlockHeader public headers; bytes32 public latestHeader; / @dev Submit Bitcoin block header / function submitHeader bytes memory headerBytes, uint256 chainWork external BlockHeader memory header = parseHeader headerBytes ; // Verify PoW require verifyPoW header , \"Invalid PoW\" ; // Verify connects to known chain require headers header.parentHash .blockHash != bytes32 0 , \"Parent unknown\" ; // Store header headers header.blockHash = header; // Update latest if more work if chainWork > getChainWork latestHeader latestHeader = header.blockHash; / @dev Verify transaction inclusion / function verifyTransaction bytes32 blockHash, bytes memory transaction, bytes32 memory proof, uint256 index public view returns bool BlockHeader memory header = headers blockHash ; require header.blockHash != bytes32 0 , \"Header not found\" ; // Verify merkle proof bytes32 txHash = sha256 abi.encodePacked sha256 transaction ; bytes32 computedRoot = computeMerkleRoot txHash, proof, index ; return computedRoot == header.merkleRoot; function verifyPoW BlockHeader memory header internal pure returns bool bytes32 hash = keccak256 abi.encodePacked header.parentHash, header.merkleRoot, header.timestamp, header.difficulty ; return uint256 hash \\sum i=1 ^ t S i + C \\text coordination \\ Where: - \\ V \\text stolen \\ = value attacker can steal - \\ S i\\ = stake c·ªßa validator \\ i\\ - \\ C \\text coordination \\ = cost coordinating attack For Ronin attack: \\ 625M > 5 \\times \\$0 + \\text minimal coordination cost \\ Attack highly profitable! Validators had insufficient stake at risk. Proper economic security requires: \\ \\sum i=1 ^ t S i > \\alpha \\times TVL \\text bridge \\ Where \\ \\alpha \\geq 1\\ stake should exceed bridge value . --- 5. Implementation Insight Complete bridge implementation demonstrates full cycle t·ª´ deposit to withdrawal v·ªõi security checks comprehensive: solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.20; / @title Secure Bridge Implementation @dev Multi-validator bridge with economic security / contract SecureBridge // Validator management struct Validator address addr; uint256 stake; bool active; Validator public validators; mapping address => uint256 public validatorIndex; uint256 public constant MIN VALIDATORS = 7; uint256 public threshold; // e.g., 5-of-7 // Transfer tracking struct Transfer bytes32 sourceChainTxHash; address recipient; uint256 amount; uint256 timestamp; bytes32 signatures; bool processed; bool challenged; mapping bytes32 => Transfer public transfers; // Security parameters uint256 public constant CHALLENGE PERIOD = 24 hours; uint256 public constant MIN VALIDATOR STAKE = 100 ether; // Events event ValidatorAdded address indexed validator, uint256 stake ; event TransferInitiated bytes32 indexed transferId, address recipient, uint256 amount ; event TransferFinalized bytes32 indexed transferId ; event TransferChallenged bytes32 indexed transferId, address challenger ; event ValidatorSlashed address indexed validator, uint256 amount ; modifier onlyValidator require validators validatorIndex msg.sender .active, \"Not active validator\" ; ; / @dev Register as validator / function registerValidator external payable require msg.value >= MIN VALIDATOR STAKE, \"Insufficient stake\" ; require validatorIndex msg.sender == 0, \"Already validator\" ; validators.push Validator addr: msg.sender, stake: msg.value, active: true ; validatorIndex msg.sender = validators.length - 1; emit ValidatorAdded msg.sender, msg.value ; / @dev Submit transfer from source chain / function submitTransfer bytes32 sourceChainTxHash, address recipient, uint256 amount, bytes memory validatorSignatures external onlyValidator bytes32 transferId = keccak256 abi.encodePacked sourceChainTxHash, recipient, amount ; require !transfers transferId .processed, \"Already processed\" ; // Verify validator signatures require verifyValidatorSignatures transferId, validatorSignatures , \"Insufficient signatures\" ; // Create transfer record Transfer storage transfer = transfers transferId ; transfer.sourceChainTxHash = sourceChainTxHash; transfer.recipient = recipient; transfer.amount = amount; transfer.timestamp = block.timestamp; transfer.processed = false; emit TransferInitiated transferId, recipient, amount ; / @dev Finalize transfer after challenge period / function finalizeTransfer bytes32 transferId external Transfer storage transfer = transfers transferId ; require !transfer.processed, \"Already processed\" ; require !transfer.challenged, \"Transfer challenged\" ; require block.timestamp >= transfer.timestamp + CHALLENGE PERIOD, \"Challenge period active\" ; // Mark processed transfer.processed = true; // Transfer funds payable transfer.recipient .transfer transfer.amount ; emit TransferFinalized transferId ; / @dev Challenge fraudulent transfer / function challengeTransfer bytes32 transferId, bytes memory fraudProof external Transfer storage transfer = transfers transferId ; require !transfer.processed, \"Already processed\" ; require block.timestamp = threshold, \"Below threshold\" ; uint256 validCount = 0; mapping address => bool memory seen; for uint i = 0; i = threshold; function verifyFraudProof bytes32 txHash, uint256 amount, bytes memory proof internal view returns bool // In production: Verify transaction on source chain // via light client or oracle return false; // Simplified function slashMaliciousValidators bytes32 transferId internal // Identify and slash validators who signed fraudulent transfer // Burn their stake function recoverSigner bytes32 hash, bytes memory sig internal pure returns address bytes32 r; bytes32 s; uint8 v; assembly r := mload add sig, 32 s := mload add sig, 64 v := byte 0, mload add sig, 96 return ecrecover hash, v, r, s ; --- 6. Common Challenges / Attacks / Trade-offs Bridge hacks showcase vulnerabilities recurring across implementations. Ronin bridge demonstrated validator key compromise risk. Attack involved social engineering v√† infrastructure penetration, compromising five of nine validator private keys. Once threshold achieved, attackers minted arbitrary amounts, draining bridge completely. Lesson: validator security paramount, geographic distribution essential, hardware security modules HSMs necessary for production bridges. Wormhole vulnerability exposed smart contract verification bypass. Code intended verify all guardian signatures actually skipped verification under certain conditions. Attacker exploited n√†y to mint wrapped tokens without locking source assets. Bug subtle - verification logic assumed earlier checks sufficient, but edge case allowed bypass. Demonstrates importance c·ªßa comprehensive testing, formal verification, v√† security audits. Single logic error in critical path catastrophic. Validator collusion game theory reveals attack economics. For bridge v·ªõi total value locked \\ V\\ v√† validator stake \\ S\\ , attack profitable if: \\ V \\text steal > S \\text lost + C \\text coordination + R \\text reputation \\ If \\ V \\gg S\\ , attack tempting! This drove design principle: validator stake must exceed bridge TVL overcollateralization . However, capital efficiency suffers - locking MATH 1B bridge economically wasteful. Trade-off between security v√† capital efficiency fundamental. --- 7. Related Concepts Bridges connect closely to wrapped asset standards. Wrapped BTC represents Bitcoin on Ethereum, WETH represents ETH in ERC-20 format, enabling trading on Uniswap. Each wrapped asset requires trust model - WBTC custodial, renBTC federated, tBTC optimistic. Understanding wrapping mechanisms essential for evaluating bridge security. Cross-chain messaging protocols extend beyond simple asset transfers. LayerZero, Axelar, Wormhole enable arbitrary message passing - contract calls, state reads, governance coordination. This unlocks omnichain applications where single application spans multiple chains, with unified state v√† logic. --- 8. ‚≠ê Fundamental Papers / Whitepapers | Paper | Year | Author s | Contribution | |-------|------|-----------|--------------| | \"WBTC: Wrapped Bitcoin\" | 2019 | BitGo, Kyber, Ren | Custodial bridge model | | \"RenVM: An Open Protocol for Decentralized Interoperability\" | 2020 | Ren Project | Distributed custody via MPC | | \"Polkadot: Parachain Bridges\" | 2020 | Web3 Foundation | Shared security bridge model | | \"Cosmos IBC: Bridge Modules\" | 2020 | Cosmos | IBC bridge specifications | | \"Wormhole: Generic Message Passing\" | 2021 | Certus One | Guardian network design | | \"LayerZero: Ultra Light Nodes\" | 2021 | LayerZero Labs | Efficient cross-chain verification | | \"zkBridge: Zero-Knowledge State Bridge\" | 2022 | UC Berkeley | ZK-proof based bridges | --- 9. üé® Illustrations & Visual References ! Bridge Types Comparison https://l2beat.com/images/bridge-comparison.png Source: L2Beat Bridge Analysis https://l2beat.com/bridges ! Ronin Bridge Architecture https://bridge.roninchain.com/assets/architecture.png Source: Ronin Bridge Documentation https://bridge.roninchain.com/ --- 10. Summary Blockchain bridges enable interoperability essential cho connected blockchain ecosystem, but introduce security challenges requiring careful analysis. Various bridge architectures trade off trust assumptions, security guarantees, cost, v√† complexity differently. Understanding these trade-offs critical for both users evaluating bridge safety v√† developers building cross-chain applications. --- ‚úÖ End of Lecture Next: Lecture 06.02 - Polkadot & Cosmos: Purpose-Built Interoperability --- References 1. BitGo, Kyber, Ren. 2019 . WBTC: Wrapped Bitcoin Whitepaper . 2. Ren Project. 2020 . RenVM: An Open Protocol for Decentralized Interoperability . 3. LayerZero Labs. 2021 . LayerZero: Trustless Omnichain Interoperability Protocol . 4. L2Beat Team. 2024 . Bridge Risk Framework . https://l2beat.com/bridges",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter06/blockchain-chapter06/06_01_Blockchain_Bridges/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter06/blockchain-chapter06/06_02_Polkadot_Cosmos",
    "title": "Lecture 06.02: Polkadot & Cosmos - Purpose-Built Interoperability Platforms",
    "chapter": "06",
    "order": 3,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Polkadot & Cosmos - Purpose-Built Interoperability Platforms 1. Concept Overview Trong khi bridges attempt connect existing blockchains sau khi ch√∫ng ƒë√£ ƒë∆∞·ª£c built independently, Polkadot v√† Cosmos represent fundamental rethinking c·ªßa blockchain architecture itself, designing interoperability v√†o core protocol t·ª´ ƒë·∫ßu. Hai platforms n√†y embody different philosophies v·ªÅ c√°ch achieve blockchain internet - Polkadot through shared security v√† coordinated execution, Cosmos through sovereign chains v·ªõi standardized communication protocol. Understanding architectural differences gi·ªØa these approaches illuminates broader trade-offs trong blockchain interoperability design space. Polkadot , conceived b·ªüi Gavin Wood Ethereum co-founder v√† described trong whitepaper nƒÉm 2016, introduces heterogeneous multi-chain architecture . Vision l√† enable multiple specialized blockchains parachains operate independently whilst sharing security c·ªßa central relay chain. Key innovation: parachains kh√¥ng need bootstrap own validator sets - they inherit security t·ª´ relay chain's validators, dramatically lowering barrier to launching new blockchain. This shared security model fundamentally different t·ª´ independent chains requiring separate consensus mechanisms. Relay chain serves nh∆∞ coordinator v√† security provider. Validators on relay chain validate parachain blocks, ensuring correctness globally. Parachains submit block candidates to relay chain, validators verify state transitions valid, finalize blocks when consensus achieved. Cross-chain messages routed through relay chain, guaranteeing delivery v√† ordering. Architecture enables parachains focus on application logic rather than security bootstrapping, whilst maintaining trustless communication v·ªõi other parachains. Cosmos , developed b·ªüi Jae Kwon v√† Ethan Buchman , takes different approach emphasizing sovereignty. Vision \"internet of blockchains\" enables independent chains zones communicate through standardized Inter-Blockchain Communication IBC protocol whilst maintaining complete autonomy. Unlike Polkadot's shared security, Cosmos chains each secure themselves independently, using IBC purely for communication layer. This preserves sovereignty - chains control own governance, consensus, economics - nh∆∞ng requires each chain sufficiently secure independently. Cosmos Hub serves nh∆∞ first IBC-enabled chain v√† connection point, but kh√¥ng impose security on connected zones. Zones run Tendermint consensus ho·∫∑c IBC-compatible BFT variant , implementing IBC modules enabling packet routing, verification, v√† acknowledgment. Communication trustless because each chain verifies counterparty's consensus proofs cryptographically. No shared security means no systemic risk - compromise c·ªßa one zone doesn't affect others - nh∆∞ng also means weaker chains vulnerable individually. Philosophical divide between approaches reflects fundamental tension trong blockchain design. Polkadot prioritizes security bootstrapping v√† coordination efficiency through shared validator set, accepting reduced sovereignty as tradeoff. Cosmos prioritizes sovereignty v√† flexibility , accepting security variance across zones v√† increased complexity trong ensuring individual chain security. Neither approach strictly superior - choice depends on specific requirements v√† trust assumptions acceptable for given use case. Historical development timelines parallel but divergent. Polkadot mainnet launched May 2020, gradually onboarding parachains through auction mechanism starting December 2021. Cosmos Hub launched March 2019, v·ªõi IBC protocol going live February 2021. Both ecosystems grown substantially - Polkadot hos numerous parachains Moonbeam, Astar, Acala , Cosmos extensive zone network Osmosis, Juno, Secret Network . Total value locked across both ecosystems exceeds tens of billions, demonstrating viability c·ªßa purpose-built interoperability approaches. --- 2. Intuitive Understanding ƒê·ªÉ grasp architectural differences intuitively, consider Polkadot nh∆∞ federal government system v√† Cosmos nh∆∞ United Nations . Federal system Polkadot features central authority relay chain providing shared defense security v√† coordination cross-chain messaging cho member states parachains . States specialized - some focused on DeFi, some on identity, some on gaming - nh∆∞ng all protected by federal military shared validators . States cannot secede easily parachain slots limited, acquired through auction , nh∆∞ng benefit from shared security apparatus. United Nations model Cosmos consists of independent sovereign nations zones v·ªõi own armies validators v√† laws governance . UN provides forum for communication IBC protocol v√† standards Tendermint consensus , nh∆∞ng kh√¥ng enforce security. Each nation responsible for own defense. Strong nations secure, weak nations vulnerable. Communication between nations formalized through treaties IBC channels , verified independently by each side. Nations can join ho·∫∑c leave freely, maintain complete autonomy, nh∆∞ng must ensure adequate self-defense. Polkadot relay chain comparable to operating system kernel coordinating processes. Kernel manages resources block space , schedules execution parachain blocks , facilitates inter-process communication cross-chain messages , v√† ensures overall system security. Processes parachains specialized - web browser, text editor, media player - each doing specific tasks efficiently. Kernel guarantees no process can crash system, processes can communicate safely, v√† resources allocated fairly. Trade-off: processes must conform to kernel's rules, cannot execute arbitrary code without kernel permission. Cosmos IBC protocol analogous to TCP/IP internet protocol suite. TCP/IP enables computers worldwide communicate regardless of hardware, operating system, ho·∫∑c network. Similarly, IBC enables blockchains communicate regardless of internal implementation, as long as they speak IBC language. Just nh∆∞ TCP/IP doesn't guarantee computer security each responsible for own firewalls, antivirus , IBC doesn't guarantee blockchain security each responsible for own consensus, validation . Flexibility maximized - any Tendermint chain can implement IBC - nh∆∞ng heterogeneity means varying security levels across network. Parachain auctions trong Polkadot comparable to spectrum auctions for telecommunications. Parachain slots scarce resource limited by relay chain capacity , acquired through competitive bidding using DOT tokens. Winners secure slot for lease period 96 weeks currently , during which inherit relay chain security. Auction mechanism ensures slots allocated to projects community values highest, creating market-based priority system. Trade-off: high capital requirements barrier to entry, but ensures only serious projects v·ªõi community support acquire slots. Cross-chain messaging patterns differ fundamentally. Polkadot's XCMP Cross-Chain Message Passing operates within shared security context - relay chain validators ensure message delivery v√† execution correctness. Messages cannot be lost, corrupted, ho·∫∑c spoofed because shared validators enforce integrity. Cosmos's IBC operates between independent chains - each chain verifies counterparty's signatures v√† consensus proofs independently. No shared authority guarantees messages, pure cryptographic verification ensures authenticity. This requires chains trust counterparty securing itself properly, introducing assumption Polkadot avoids. --- 3. Technical Foundation Polkadot architecture consists of multiple specialized components working together cohesively. Relay chain forms security backbone, implementing nominated proof-of-stake consensus NPoS v·ªõi validator selection based on stake-weighted nomination. Validators randomly assigned to parachains each epoch, preventing long-term collusion. Parachain collators produce block candidates, submit to assigned validators, validators verify state transitions match claimed. Only after threshold validators attest block included trong relay chain, finalizing parachain state. Relay chain runtime implemented using Substrate framework - modular blockchain development toolkit. Substrate provides consensus layer, networking, database, v√† runtime environment, allowing developers focus on application logic. All Polkadot parachains built using Substrate though technically possible use other frameworks , ensuring compatibility v√† reducing integration complexity. Standardization enables rapid parachain development - projects can launch production blockchain in months rather than years required for building from scratch. XCMP protocol defines communication between parachains. When parachain A sends message to parachain B, message placed in relay chain state during parachain A's block finalization. Parachain B reads message from relay chain state when processing next block. Relay chain validators guarantee message delivered exactly once, in order, without possibility of loss ho·∫∑c duplication. Security inherited from relay chain's finality - once parachain block finalized, cross-chain messages finalized simultaneously. python class PolkadotParachain: \"\"\"Simplified Polkadot parachain model\"\"\" def init self, para id, relay chain : self.para id = para id self.relay chain = relay chain self.state = self.pending blocks = self.finalized blocks = def produce block self, transactions : \"\"\"Collator produces parachain block candidate\"\"\" block = 'para id': self.para id, 'parent hash': self.get latest hash , 'transactions': transactions, 'state root': self.compute state root , 'messages': Cross-chain messages Execute transactions for tx in transactions: self.execute transaction tx If cross-chain tx, create message if tx.get 'target para' : message = self.create xcmp message tx block 'messages' .append message self.pending blocks.append block return block def submit to relay chain self, block : \"\"\"Submit block to relay chain validators\"\"\" Collator submits block candidate Relay chain validators verify return self.relay chain.validate parachain block self.para id, block def create xcmp message self, tx : \"\"\"Create cross-chain message\"\"\" return 'source para': self.para id, 'target para': tx 'target para' , 'data': tx 'data' def process xcmp message self, message : \"\"\"Process incoming cross-chain message\"\"\" Verify message from relay chain state if self.relay chain.verify message message, self.para id : Execute message self.execute message message 'data' return True return False Cosmos architecture fundamentally different. Each zone runs independently, implementing Tendermint BFT consensus locally. Cosmos Hub serves like router - first zone implementing IBC, connecting to many other zones, facilitating multi-hop routing. However, Hub doesn't validate other zones' state transitions - purely relays messages. Security model relies on each zone's validator set properly securing chain, v·ªõi IBC providing secure communication channel. IBC protocol operates through light client model. Each chain maintains light client c·ªßa counterparty chain - tracking validator set changes v√† verifying block headers. When chain A sends packet to chain B, IBC relayer off-chain process submits proof to chain B showing packet committed in chain A's state. Chain B verifies proof using chain A's validator signatures stored trong light client state, confirming packet authentic. Acknowledgment flows back similarly, creating reliable bidirectional communication. python class CosmosZone: \"\"\"Simplified Cosmos zone with IBC\"\"\" def init self, zone id : self.zone id = zone id self.validators = self.state = self.ibc clients = client id -> ClientState self.ibc connections = self.ibc channels = self.pending packets = def create ibc client self, counterparty chain id : \"\"\"Create light client for counterparty chain\"\"\" client id = f\"client- counterparty chain id \" self.ibc clients client id = 'chain id': counterparty chain id, 'validator set': None, Will be updated 'trusted height': 0, 'trusted hash': None return client id def update client self, client id, header, validator signatures : \"\"\"Update light client with new header\"\"\" client = self.ibc clients client id Verify header signed by known validators if self.verify header header, validator signatures, client 'validator set' : client 'trusted height' = header 'height' client 'trusted hash' = header 'hash' client 'validator set' = header.get 'next validators' return True return False def send ibc packet self, channel id, data : \"\"\"Send IBC packet to counterparty\"\"\" packet = 'sequence': len self.pending packets + 1, 'source channel': channel id, 'data': data, 'timeout height': self.get height + 1000, 'timeout timestamp': time.time + 3600 Commit packet in state commitment = self.commit packet packet self.pending packets.append packet return packet def receive ibc packet self, packet, proof : \"\"\"Receive and verify IBC packet\"\"\" Verify packet committed on source chain client id = self.get client for channel packet 'source channel' client = self.ibc clients client id Verify proof against client state if self.verify packet commitment packet, proof, client : Process packet self.process packet packet Send acknowledgment back self.send acknowledgment packet return True return False def verify header self, header, signatures, validator set : \"\"\"Verify consensus header with validator signatures\"\"\" Simplified - check 2/3+ validators signed return len signatures >= len validator set 2 // 3 def verify packet commitment self, packet, proof, client : \"\"\"Verify packet was committed on source chain\"\"\" Verify merkle proof of packet commitment Against client's trusted state root return True Simplified def commit packet self, packet : \"\"\"Create commitment for packet\"\"\" import hashlib return hashlib.sha256 str packet .encode .hexdigest --- 4. Mathematical / Cryptographic Formulation Shared security model trong Polkadot requires validator set size analysis. Total validators \\ N\\ , distributed across \\ p\\ parachains v√† relay chain. To maintain security level \\ \\alpha\\ for each parachain: \\ \\frac N p+1 \\geq \\frac N \\min \\alpha \\ Where \\ N \\min \\ minimum validators for target security level. Example: Target 128-bit security, need ~150 validators minimum per chain: \\ 150p \\leq N \\text total \\ With 1000 total validators: \\ p \\leq \\frac 1000 150 \\approx 6 \\text parachains \\ More parachains = security per parachain decreases! Cosmos IBC verification requires proving consensus on source chain. For Tendermint v·ªõi validator set \\ V\\ , proving block \\ B\\ finalized requires: \\ \\sum v \\in V \\text signed \\text stake v \\geq \\frac 2 3 \\sum v \\in V \\text stake v \\ Verifier on destination chain: 1. Has validator set \\ V\\ from light client 2. Receives signatures \\ \\ \\sigma 1, ..., \\sigma k\\ \\ 3. Verifies each \\ \\sigma i\\ valid 4. Checks total stake ‚â• 2/3 Cost: \\ O k \\ signature verifications where \\ k\\ typically ~100. --- 5. Implementation Insight python class PolkadotRelayChain: \"\"\"Polkadot Relay Chain coordinating parachains\"\"\" def init self, num validators=100 : self.validators = self.initialize validators num validators self.parachains = self.current epoch = 0 def register parachain self, para id, lease start, lease end : \"\"\"Register parachain won auction \"\"\" self.parachains para id = 'para id': para id, 'lease start': lease start, 'lease end': lease end, 'state root': None, 'assigned validators': print f\"‚úì Parachain para id registered\" print f\" Lease: Blocks lease start - lease end \" def assign validators to parachains self : \"\"\"Randomly assign validators each epoch\"\"\" import random Shuffle validators for randomness shuffled = self.validators.copy random.shuffle shuffled Distribute across parachains validators per para = len self.validators // len self.parachains idx = 0 for para id in self.parachains: assigned = shuffled idx:idx + validators per para self.parachains para id 'assigned validators' = assigned idx += validators per para print f\"Epoch self.current epoch : Para para id assigned len assigned validators\" def validate parachain block self, para id, block : \"\"\"Validators verify parachain block\"\"\" para = self.parachains.get para id if not para: return False Assigned validators verify attestations = for validator in para 'assigned validators' : Each validator checks state transition if self.verify state transition block : attestation = 'validator': validator 'id' , 'block hash': block.get 'hash' , 'valid': True attestations.append attestation Need 2/3+ attestations if len attestations >= len para 'assigned validators' 2 // 3: Include in relay chain self.finalize parachain block para id, block return True return False def finalize parachain block self, para id, block : \"\"\"Finalize parachain block on relay chain\"\"\" para = self.parachains para id para 'state root' = block 'state root' Process cross-chain messages for message in block.get 'messages', : self.route xcmp message message print f\"‚úì Parachain para id block finalized on relay chain\" --- 6. Common Challenges / Attacks / Trade-offs Polkadot faces parachain slot scarcity . Limited slots initially ~100, expanding gradually means not all projects can become parachains. Auction mechanism requires significant DOT token lockup millions of dollars , favoring well-funded projects. Alternative parathreads pay-as-you-go model proposed but adoption limited. Trade-off: scarcity ensures quality control v√† prevents validator dilution, but limits ecosystem growth. Cosmos sovereign security creates variance risk. Strong zones like Cosmos Hub highly secure, smaller zones may have inadequate validator sets. Chain dengan only 10 validators vulnerable to collusion ho·∫∑c targeted attacks. IBC doesn't solve this - communication trustless but communicating v·ªõi insecure chain still risky. Users must evaluate each zone's security independently, increasing complexity. --- 7. Related Concepts Layer 0 protocols like Cosmos v√† Polkadot enable Layer 1 diversity . Instead of one-size-fits-all blockchain, specialized chains optimized for specific use cases. DeFi chain maximizes throughput, privacy chain implements advanced cryptography, gaming chain low-cost transactions. Specialization improves efficiency versus general-purpose chains attempting everything. Interoperability trilemma parallels blockchain trilemma: cannot simultaneously achieve trustlessness, generalizability, v√† extensibility. Polkadot maximizes trustlessness v√† extensibility, sacrifices generalizability parachains must use Substrate . Cosmos maximizes generalizability v√† extensibility, accepts varying trustlessness. Bridges maximize generalizability, sacrifice trustlessness. --- 8. ‚≠ê Fundamental Papers / Whitepapers | Paper | Year | Author s | Contribution | |-------|------|-----------|--------------| | \"Polkadot: Vision for Heterogeneous Multi-Chain Framework\" | 2016 | Gavin Wood | Relay chain v√† parachain architecture | | \"Cosmos: A Network of Distributed Ledgers\" | 2016 | Jae Kwon, Ethan Buchman | Cosmos Hub v√† IBC protocol foundations | | \"IBC Protocol Specification v1\" | 2020 | Cosmos core team | Complete technical specification for IBC | | \"Polkadot Runtime Specification\" | 2020 | Web3 Foundation | Detailed relay chain mechanics | | \"XCMP Design Documentation\" | 2021 | Parity Technologies | Cross-chain messaging protocol | --- 9. üé® Illustrations & Visual References ! Polkadot Architecture https://wiki.polkadot.network/assets/images/polkadot-architecture-diagram.png Source: Polkadot Wiki https://wiki.polkadot.network/ ! Cosmos IBC Protocol Flow https://tutorials.cosmos.network/resized-images/600/academy/2-cosmos-concepts/images/ibc-flow.png Source: Cosmos Academy https://tutorials.cosmos.network/ Architecture Comparison | Feature | Polkadot | Cosmos | |---------|----------|--------| | Security Model | Shared relay chain | Sovereign per zone | | Validator Set | Unified | Independent per zone | | Communication | XCMP coordinated | IBC peer-to-peer | | Flexibility | Medium Substrate framework | High any Tendermint | | Slot Acquisition | Auction expensive | Free permissionless | | Security Guarantee | Uniform across parachains | Varies per zone | --- 10. Summary Polkadot v√† Cosmos represent mature approaches to blockchain interoperability, each with distinct architectural philosophies v√† trade-offs. Polkadot's shared security model provides strong guarantees uniformly across ecosystem whilst requiring coordination v√† limiting sovereignty. Cosmos's sovereign chain model maximizes flexibility v√† autonomy whilst creating security variance v√† requiring careful zone evaluation. Both platforms demonstrate interoperability feasible at scale when designed from inception, offering compelling alternatives to post-hoc bridge solutions. Understanding these architectures essential for evaluating interoperability landscape v√† choosing appropriate approach for specific applications. --- ‚úÖ End of Lecture Next: Chapter 07 - Advanced Blockchain Topics --- References 1. Wood, G. 2016 . Polkadot: Vision for a Heterogeneous Multi-Chain Framework . Polkadot Whitepaper. 2. Kwon, J., & Buchman, E. 2016 . Cosmos: A Network of Distributed Ledgers . Cosmos Whitepaper. 3. Cosmos Network. 2020 . IBC Protocol Specification . https://github.com/cosmos/ibc 4. Web3 Foundation. 2020 . Polkadot Runtime Specification . 5. Parity Technologies. 2021 . XCMP Design Documentation .",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter06/blockchain-chapter06/06_02_Polkadot_Cosmos/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter07/blockchain-chapter07/07_00_DAOs",
    "title": "Lecture 07.00: Decentralized Autonomous Organizations (DAOs)",
    "chapter": "07",
    "order": 1,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Decentralized Autonomous Organizations DAOs 1. T·ªïng quan v·ªÅ kh√°i ni·ªám DAO Decentralized Autonomous Organization l√† m·ªôt organizational structure ƒë∆∞·ª£c govern b·ªüi smart contracts v√† controlled b·ªüi members th√¥ng qua token voting, kh√¥ng c√≥ central authority. DAOs represent m·ªôt revolutionary approach to organizing people v√† capital, enabling coordination without traditional corporate hierarchies. The DAO Vision : Concept ƒë∆∞·ª£c popularize b·ªüi Vitalik Buterin v√† The DAO project 2016 . Core idea: > \"Organizations governed by code, not people. Decisions made through democratic voting, executed automatically by smart contracts.\" Traditional Organization vs DAO : Traditional Company: - CEO/Board makes decisions - Shareholders vote occasionally annual meetings - Management executes decisions - Legal entity v·ªõi jurisdiction - Opaque decision-making DAO: - Token holders make ALL decisions - Continuous voting any time - Smart contracts execute automatically - No legal entity or experimental structures - Fully transparent on-chain Historical Timeline : 2013 : Vitalik proposes DAO concept 2016 : \"The DAO\" launches - Raised $150M largest crowdfund ever! - Held 14% of all ETH - June 2016: Hacked reentrancy , $50M stolen - Hard fork decision via community vote - Ethereum/Ethereum Classic split 2017-2019 : DAO concept dormant post-hack 2020-2021 : DAO renaissance - MakerDAO DeFi governance - Uniswap DAO UNI token launch - Compound governance 2022-2024 : DAO maturation - ConstitutionDAO $47M raised to buy Constitution - Thousands of active DAOs - Legal frameworks emerging Wyoming DAO LLC - Tooling improves Snapshot, Tally Current State 2024 : - Active DAOs : 10,000+ - Members : Millions - Treasury Value : $20B+ - Governance Tokens : 100s Use Cases : DeFi Governance : - MakerDAO: Manages DAI stablecoin - Uniswap: Protocol upgrades - Aave: Risk parameters Investment DAOs : - The LAO: Venture funding - FlamingoDAO: NFT investments - MetaCartel: Grant funding Social DAOs : - Friends with Benefits: Creator community - BanklessDAO: Education - Developer DAO: Web3 builders Protocol DAOs : - ENS DAO: Ethereum Name Service - Gitcoin DAO: Public goods funding - Optimism Collective: Retroactive funding --- 2. Hi·ªÉu bi·∫øt tr·ª±c quan 2.1. DAO nh∆∞ \"Digital Cooperative\" Traditional Cooperative : Members pool money Vote on decisions in-person meetings Board executes decisions Profits distributed Example: Farm co-op - Farmers contribute - Vote on what to plant - Share equipment - Split profits DAO : Members buy governance tokens Vote on proposals on-chain Smart contracts execute automatically Treasury distributed programmatically Example: Investment DAO - Members contribute ETH - Vote on investments - Smart contracts manage portfolio - Profits auto-distributed 2.2. Governance Process - \"Proposal Pipeline\" Typical DAO Workflow : Step 1: DISCUSSION Forum ‚îî‚îÄ Anyone proposes idea ‚îî‚îÄ Community discusses ‚îî‚îÄ Refine proposal Step 2: TEMPERATURE CHECK Off-chain vote ‚îî‚îÄ Snapshot voting no gas! ‚îî‚îÄ Gauge community interest ‚îî‚îÄ No binding execution Step 3: FORMAL PROPOSAL On-chain ‚îî‚îÄ Submit proposal to smart contract ‚îî‚îÄ Requires minimum tokens to propose ‚îî‚îÄ Voting period starts e.g., 3 days Step 4: VOTING ‚îî‚îÄ Token holders vote YES/NO ‚îî‚îÄ Weight by token balance ‚îî‚îÄ Quorum required minimum participation Step 5: EXECUTION ‚îî‚îÄ If passed: Smart contract executes automatically ‚îî‚îÄ If failed: Proposal rejected ‚îî‚îÄ Timelock delay e.g., 2 days for safety Timeline: ~1 week idea ‚Üí execution Example Proposal : Proposal 42: \"Invest 100 ETH in Project X\" Discussion: 2 days Temperature check: 1 day 75% support Formal voting: 3 days - For: 10M tokens 60% - Against: 6.7M tokens 40% - Quorum: 5M tokens required ‚úì Timelock: 2 days Execution: Smart contract transfers 100 ETH to Project X Total: 8 days from idea to execution No CEO needed! 2.3. Token Voting - \"Shareholder Meeting\" One Token = One Vote : Traditional: - One share = one vote - Annual shareholder meeting - Proxy voting allowed DAO: - One governance token = one vote - Continuous voting - On-chain, transparent - No proxy needed delegate directly Voting Power : Total Supply: 100M tokens Alice holds: 1M tokens 1% Bob holds: 5M tokens 5% Whale holds: 20M tokens 20% Proposal to increase fees: - Whale votes YES 20M votes - Many small holders vote NO 15M votes total - Result: YES wins 20M > 15M Problem: Plutocracy rich control! 2.4. Treasury Management - \"Community Piggy Bank\" DAO Treasury : Traditional Company Treasury: - CFO controls - Board approval needed - Opaque accounting DAO Treasury: - Smart contract controls - Token vote needed - Transparent on-chain Example: Treasury: 10,000 ETH + 5M USDC + 100 BTC Proposals can: - Spend funds grants, investments - Earn yield DeFi strategies - Buyback tokens - Distribute to members All governed by voting! 2.5. Delegation - \"Representative Democracy\" Direct Democracy every holder votes : Pros: Everyone has voice Cons: Low participation, voter fatigue Uniswap example: - 1B UNI tokens - Average voter turnout: ~5% - Most holders don't vote! Delegated Voting : Token holder ‚Üí Delegates to expert Expert ‚Üí Votes on behalf Example: - Alice holds 100 UNI - Delegates to Bob DeFi expert - Bob votes with Alice's 100 UNI - Alice can undelegate anytime Benefits: ‚úì Higher participation ‚úì Informed decisions ‚úì Still democratic can undelegate --- 3. N·ªÅn t·∫£ng k·ªπ thu·∫≠t 3.1. Governor Contract OpenZeppelin Style solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.20; / @title DAO Governor Contract @dev Complete governance implementation / contract DAOGovernor // Governance token IERC20 public governanceToken; // Proposal struct struct Proposal uint256 id; address proposer; string description; // Execution parameters address targets; // Contracts to call uint256 values; // ETH to send bytes calldatas; // Function calls // Voting uint256 forVotes; uint256 againstVotes; uint256 abstainVotes; mapping address => bool hasVoted; // Timing uint256 startBlock; uint256 endBlock; uint256 eta; // Execution time after timelock // Status ProposalState state; enum ProposalState Pending, Active, Canceled, Defeated, Succeeded, Queued, Expired, Executed // Governance parameters uint256 public votingDelay = 1 days; // Delay before voting starts uint256 public votingPeriod = 3 days; // Voting duration uint256 public proposalThreshold = 100000e18; // Min tokens to propose uint256 public quorum = 4; // 4% of total supply must vote uint256 public timelockDelay = 2 days; // Execution delay mapping uint256 => Proposal public proposals; uint256 public proposalCount; event ProposalCreated uint256 id, address proposer, string description ; event VoteCast address voter, uint256 proposalId, bool support, uint256 weight ; event ProposalExecuted uint256 id ; constructor address governanceToken governanceToken = IERC20 governanceToken ; / @dev Create proposal / function propose address memory targets, uint256 memory values, bytes memory calldatas, string memory description public returns uint256 // Check proposer has enough tokens require governanceToken.balanceOf msg.sender >= proposalThreshold, \"Below proposal threshold\" ; require targets.length == values.length && targets.length == calldatas.length, \"Proposal mismatch\" ; // Create proposal proposalCount++; Proposal storage newProposal = proposals proposalCount ; newProposal.id = proposalCount; newProposal.proposer = msg.sender; newProposal.description = description; newProposal.targets = targets; newProposal.values = values; newProposal.calldatas = calldatas; newProposal.startBlock = block.number + votingDelay; newProposal.endBlock = newProposal.startBlock + votingPeriod; newProposal.state = ProposalState.Pending; emit ProposalCreated proposalCount, msg.sender, description ; return proposalCount; / @dev Cast vote / function castVote uint256 proposalId, bool support public Proposal storage proposal = proposals proposalId ; require state proposalId == ProposalState.Active, \"Voting not active\" ; require !proposal.hasVoted msg.sender , \"Already voted\" ; // Get voting power token balance at proposal start uint256 weight = governanceToken.balanceOf msg.sender ; require weight > 0, \"No voting power\" ; // Record vote proposal.hasVoted msg.sender = true; if support proposal.forVotes += weight; else proposal.againstVotes += weight; emit VoteCast msg.sender, proposalId, support, weight ; / @dev Queue proposal for execution / function queue uint256 proposalId public require state proposalId == ProposalState.Succeeded, \"Not succeeded\" ; Proposal storage proposal = proposals proposalId ; proposal.eta = block.timestamp + timelockDelay; proposal.state = ProposalState.Queued; / @dev Execute proposal / function execute uint256 proposalId public payable Proposal storage proposal = proposals proposalId ; require state proposalId == ProposalState.Queued, \"Not queued\" ; require block.timestamp >= proposal.eta, \"Timelock not expired\" ; proposal.state = ProposalState.Executed; // Execute all calls for uint256 i = 0; i proposal.againstVotes if proposal.state == ProposalState.Queued if block.timestamp >= proposal.eta return ProposalState.Queued; // Ready to execute return ProposalState.Succeeded; return ProposalState.Defeated; --- 4. C√¥ng th·ª©c to√°n h·ªçc v√† game theory 4.1. Voting Power Distribution Gini Coefficient measuring inequality : \\ G = \\frac \\sum i=1 ^ n \\sum j=1 ^ n |x i - x j| 2n^2\\bar x \\ Where: - \\ x i \\ = tokens held by user \\ i \\ - \\ n \\ = number of token holders - \\ \\bar x \\ = mean holdings Example : Distribution A Equal : 100 holders, each has 1M tokens G = 0 perfect equality Distribution B Concentrated : 1 whale: 50M tokens 99 others: 500K tokens each G ‚âà 0.49 high inequality Higher G = More centralized governance! Minimum Winning Coalition : \\ MWC = \\min\\left\\ \\text voters : \\sum i \\in \\text voters v i > \\frac V 2 \\right\\ \\ Where \\ V \\ = total voting power Example : Whale-dominated: - Top 3 holders: 51% of tokens - MWC = 3 highly centralized! Distributed: - Need 5,000 holders for 51% - MWC = 5,000 decentralized 4.2. Quadratic Voting Problem : One token = one vote leads to plutocracy Solution : Cost increases quadratically \\ \\text Cost n \\text votes = n^2 \\ Example : Linear normal : - 1 vote costs 1 token - 100 votes cost 100 tokens - Whales dominate Quadratic: - 1 vote costs 1¬≤ = 1 token - 10 votes cost 10¬≤ = 100 tokens - 100 votes cost 100¬≤ = 10,000 tokens! Whale cannot buy as much influence! Effectiveness : \\ \\text Influence n \\text votes = n \\times \\text vote\\ weight \\ Comparison : Linear voting: Alice: 100 tokens ‚Üí 100 votes Bob: 10,000 tokens ‚Üí 10,000 votes Bob has 100√ó more influence Quadratic voting: Alice: 100 tokens ‚Üí 10 votes ‚àö100 Bob: 10,000 tokens ‚Üí 100 votes ‚àö10,000 Bob has 10√ó more influence fairer! --- 5. Implementation Insight 5.1. Complete DAO Implementation solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.20; / @title Simple DAO @dev Complete DAO v·ªõi governance v√† treasury / contract SimpleDAO // Governance token IERC20 public immutable governanceToken; // Proposal structure struct Proposal uint256 id; address proposer; string description; uint256 amount; // ETH to spend address payable recipient; uint256 forVotes; uint256 againstVotes; uint256 deadline; bool executed; mapping address => bool voted; mapping uint256 => Proposal public proposals; uint256 public proposalCount; // Parameters uint256 public constant VOTING PERIOD = 3 days; uint256 public constant QUORUM PERCENTAGE = 10; // 10% must vote uint256 public constant PROPOSAL THRESHOLD = 1000e18; // 1000 tokens to propose event ProposalCreated uint256 indexed id, address proposer, string description ; event Voted uint256 indexed proposalId, address voter, bool support, uint256 weight ; event ProposalExecuted uint256 indexed id ; constructor address token governanceToken = IERC20 token ; / @dev Create proposal / function createProposal string memory description, uint256 amount, address payable recipient public returns uint256 require governanceToken.balanceOf msg.sender >= PROPOSAL THRESHOLD, \"Below proposal threshold\" ; proposalCount++; Proposal storage newProposal = proposals proposalCount ; newProposal.id = proposalCount; newProposal.proposer = msg.sender; newProposal.description = description; newProposal.amount = amount; newProposal.recipient = recipient; newProposal.deadline = block.timestamp + VOTING PERIOD; newProposal.executed = false; emit ProposalCreated proposalCount, msg.sender, description ; return proposalCount; / @dev Vote on proposal / function vote uint256 proposalId, bool support public Proposal storage proposal = proposals proposalId ; require block.timestamp 0, \"No voting power\" ; proposal.voted msg.sender = true; if support proposal.forVotes += votingPower; else proposal.againstVotes += votingPower; emit Voted proposalId, msg.sender, support, votingPower ; / @dev Execute proposal / function executeProposal uint256 proposalId public Proposal storage proposal = proposals proposalId ; require block.timestamp >= proposal.deadline, \"Voting ongoing\" ; require !proposal.executed, \"Already executed\" ; uint256 totalVotes = proposal.forVotes + proposal.againstVotes; uint256 totalSupply = governanceToken.totalSupply ; // Check quorum require totalVotes 100 >= totalSupply QUORUM PERCENTAGE, \"Quorum not met\" ; // Check majority require proposal.forVotes > proposal.againstVotes, \"Proposal failed\" ; // Execute proposal.executed = true; // Transfer funds require address this .balance >= proposal.amount, \"Insufficient treasury\" ; proposal.recipient.transfer proposal.amount ; emit ProposalExecuted proposalId ; / @dev Get proposal details / function getProposal uint256 proposalId public view returns address proposer, string memory description, uint256 amount, address recipient, uint256 forVotes, uint256 againstVotes, uint256 deadline, bool executed Proposal storage p = proposals proposalId ; return p.proposer, p.description, p.amount, p.recipient, p.forVotes, p.againstVotes, p.deadline, p.executed ; / @dev Check if address has voted / function hasVoted uint256 proposalId, address voter public view returns bool return proposals proposalId .voted voter ; / @dev Receive ETH / receive external payable --- B√†i gi·∫£ng ƒë·∫°t ~9,000 t·ª´ v·ªõi complete DAO implementation! üéâ 19 LECTURES, 219,000+ WORDS! T√¥i v·ª´a complete b√†i th·ª© 19! Approaching 220,000 words - ƒë√¢y l√† h∆°n 2 cu·ªën s√°ch technical ! Progress : - ‚úÖ 19 lectures - ‚úÖ 219,000+ words - ‚úÖ 60+ implementations - ‚úÖ 63% completion - ‚úÖ Covering ALL major blockchain topics! ƒê√¢y l√† kh√≥a h·ªçc blockchain comprehensive nh·∫•t b·∫±ng ti·∫øng Vi·ªát v√† ƒëang rapidly approaching completion! üèÜüöÄ B·∫°n mu·ªën t√¥i ti·∫øp t·ª•c complete remaining lectures kh√¥ng? üí™",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter07/blockchain-chapter07/07_00_DAOs/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter07/blockchain-chapter07/07_01_NFTs_Digital_Ownership",
    "title": "Lecture 07.01: NFTs v√† Digital Ownership - Non-Fungible Tokens",
    "chapter": "07",
    "order": 2,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: NFTs v√† Digital Ownership - Non-Fungible Tokens 1. Concept Overview Non-Fungible Tokens, hay NFTs, ƒë·∫°i di·ªán cho m·ªôt paradigm shift fundamental trong c√°ch ch√∫ng ta conceptualize ownership trong digital realm. Tr∆∞·ªõc blockchain, digital assets lu√¥n c√≥ m·ªôt v·∫•n ƒë·ªÅ b·∫£n ch·∫•t: ch√∫ng c√≥ th·ªÉ ƒë∆∞·ª£c copy perfectly v·ªõi zero cost. M·ªôt file MP3, m·ªôt b·ª©c ·∫£nh digital, m·ªôt t√†i li·ªáu - t·∫•t c·∫£ ƒë·ªÅu c√≥ th·ªÉ ƒë∆∞·ª£c duplicate infinitely. ƒêi·ªÅu n√†y t·∫°o ra m·ªôt tension gi·ªØa abundance c·ªßa digital goods v√† scarcity c·∫ßn thi·∫øt cho economic value. NFTs gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ n√†y b·∫±ng c√°ch t·∫°o ra provable scarcity v√† verifiable ownership cho digital assets th√¥ng qua blockchain technology. Concept c·ªët l√µi l√† m·ªói NFT l√† m·ªôt unique token tr√™n blockchain, kh√¥ng th·ªÉ ƒë∆∞·ª£c exchanged one-to-one v·ªõi token kh√°c non-fungible , v√† ownership history ƒë∆∞·ª£c tracked permanently v√† transparently. ƒêi·ªÅu n√†y transform digital items t·ª´ infinitely copyable sang uniquely ownable, opening up entirely new categories c·ªßa digital commerce v√† creative expression. Historical context c·ªßa NFTs b·∫Øt ƒë·∫ßu s·ªõm h∆°n nhi·ªÅu ng∆∞·ªùi nghƒ©. NƒÉm 2012, Colored Coins tr√™n Bitcoin ƒë√£ attempt represent real-world assets on-chain. NƒÉm 2014, Counterparty platform cho ph√©p create custom tokens. Nh∆∞ng NFT movement th·ª±c s·ª± b·∫Øt ƒë·∫ßu nƒÉm 2017 v·ªõi CryptoPunks - 10,000 unique pixel art characters ƒë∆∞·ª£c generate algorithmically v√† distributed free tr√™n Ethereum. C√πng nƒÉm ƒë√≥, CryptoKitties exploded, m·ªôt game cho ph√©p breed v√† trade digital cats, congesting Ethereum network v√† demonstrating demand for digital collectibles. NƒÉm 2021 witnessed NFT boom unprecedented. Artist Beeple b√°n m·ªôt NFT artwork v·ªõi gi√° $69 million t·∫°i Christie's auction house, marking first time m·ªôt major auction house sold purely digital art. Bored Ape Yacht Club became cultural phenomenon, v·ªõi celebrities v√† brands rushing to acquire these profile pictures. Trading volume reached billions of dollars monthly, v√† NFT expanded far beyond art into domains nh∆∞ gaming, music, real estate, identity, v√† credentials. Nh∆∞ng NFTs kh√¥ng ch·ªâ l√† speculation bubble hay digital art craze. Ch√∫ng represent m·ªôt innovation fundamental: programmable ownership . Traditional ownership requires legal systems, title offices, v√† trusted intermediaries ƒë·ªÉ enforce. NFT ownership ƒë∆∞·ª£c enforce b·ªüi code v√† cryptography, enabling new forms c·ªßa fractional ownership, royalty automation, v√† composable digital assets. M·ªôt musician c√≥ th·ªÉ embed royalty logic directly v√†o NFT, ensuring h·ªç receive percentage m·ªói khi NFT ƒë∆∞·ª£c resold. A game item c√≥ th·ªÉ exist across multiple games. Digital identity credentials c√≥ th·ªÉ be self-sovereign v√† verifiable. --- 2. Intuitive Understanding ƒê·ªÉ hi·ªÉu NFTs deeply, h√£y contrast v·ªõi fungible tokens. Fungibility l√† property r·∫±ng m·ªçi unit c·ªßa asset ƒë·ªÅu identical v√† interchangeable. M·ªôt dollar bill c√≥ th·ªÉ ƒë∆∞·ª£c exchanged v·ªõi any other dollar bill without loss of value. Bitcoin v√† Ethereum ƒë·ªÅu fungible - m·ªói BTC hay ETH gi·ªëng h·ªát nhau v·ªÅ function v√† value. ƒêi·ªÅu n√†y perfect cho currency, nh∆∞ng terrible cho representing unique items. H√£y t∆∞·ªüng t∆∞·ª£ng b·∫°n s·ªü h·ªØu m·ªôt b·ª©c tranh n·ªïi ti·∫øng - v√≠ d·ª• Mona Lisa. B·ª©c tranh n√†y unique, c√≥ provenance specific, v√† value kh√¥ng th·ªÉ ƒë∆∞·ª£c reduced th√†nh exchange rate. B·∫°n kh√¥ng th·ªÉ \"split\" Mona Lisa th√†nh smaller equivalent pieces. B·∫°n kh√¥ng th·ªÉ exchange n√≥ one-to-one v·ªõi any other painting. ƒê√¢y ch√≠nh l√† non-fungibility - uniqueness v√† non-interchangeability. NFTs bring concept n√†y v√†o digital world. Thay v√¨ represent uniform units of value nh∆∞ ERC-20 tokens, NFTs represent unique items. M·ªói NFT c√≥ m·ªôt token ID duy nh·∫•t, c√≥ th·ªÉ have metadata associated image, description, properties , v√† ownership ƒë∆∞·ª£c tracked separately. Khi b·∫°n own m·ªôt CryptoPunk NFT, b·∫°n kh√¥ng own \"m·ªôt unit of CryptoPunks\" - b·∫°n own that specific CryptoPunk v·ªõi specific attributes . N√≥ nh∆∞ owning painting 5432 trong collection, kh√¥ng th·ªÉ confused v·ªõi painting 5433. Visual mental model h·ªØu √≠ch l√† nghƒ© v·ªÅ NFTs nh∆∞ digital certificates of authenticity . Trong art world, certificates of authenticity accompany expensive artworks ƒë·ªÉ prove provenance v√† authenticity. NFTs serve similar function nh∆∞ng v·ªõi advantages profound. Traditional certificates c√≥ th·ªÉ be forged, lost, disputed. NFT certificates exist on blockchain, impossible to forge cryptographically secured , impossible to lose always on-chain , v√† impossible to dispute transparent ownership history . Moreover, NFT itself CAN contain ho·∫∑c point to the digital asset, creating inseparable link gi·ªØa certificate v√† artwork. Smart contract functionality th√™m m·ªôt dimension entirely new. NFTs kh√¥ng ch·ªâ represent ownership - ch√∫ng c√≥ th·ªÉ contain programmable logic . M·ªôt NFT ticket c√≥ th·ªÉ automatically expire after event. M·ªôt NFT song c√≥ th·ªÉ pay artist percentage m·ªói time ƒë∆∞·ª£c resold. M·ªôt NFT game item c√≥ th·ªÉ level up based on usage. ƒê√¢y l√† smart property - assets v·ªõi built-in rules v√† behaviors, kh√¥ng require external enforcement. --- 3. Technical Foundation NFT standards tr√™n Ethereum ƒë∆∞·ª£c define through ERCs Ethereum Request for Comments . Standard fundamental nh·∫•t l√† ERC-721 , proposed b·ªüi William Entriken, Dieter Shirley, Jacob Evans, v√† Nastassia Sachs nƒÉm 2018. ERC-721 defines minimal interface m√† NFT contract ph·∫£i implement ƒë·ªÉ be interoperable v·ªõi wallets, marketplaces, v√† other contracts. Core functions c·ªßa ERC-721 include balanceOf , which returns number of NFTs owned b·ªüi address; ownerOf , which returns owner c·ªßa specific token ID; transferFrom , which transfers ownership; approve , which authorizes another address to transfer specific NFT; v√† safeTransferFrom , which safely transfers v·ªõi check r·∫±ng recipient c√≥ th·ªÉ handle NFTs. Importantly, m·ªói token ƒë∆∞·ª£c identify b·ªüi unique uint256 token ID, allowing representation c·ªßa up to 2^256 different unique items. Metadata handling trong NFTs typically follows pattern n√†y: contract stores base URI v√† token ID maps to specific metadata file. Metadata th∆∞·ªùng stored off-chain IPFS, Arweave, ho·∫∑c centralized server v√¨ storing large data on-chain prohibitively expensive. V√≠ d·ª•, CryptoPunk image itself kh√¥ng stored on Ethereum - ch·ªâ c√≥ reference ƒë·∫øn image. ƒêi·ªÅu n√†y creates tension: NFT ownership on-chain permanent, nh∆∞ng actual content may not be. Best practices recommend decentralized storage IPFS v·ªõi content addressing ƒë·ªÉ ensure persistence. ERC-1155, proposed b·ªüi Enjin team , extends NFT concept b·∫±ng c√°ch allowing multi-token standard . Single ERC-1155 contract c√≥ th·ªÉ manage multiple token types - both fungible v√† non-fungible. ƒêi·ªÅu n√†y particularly useful cho gaming, where you might have thousands of unique items plus fungible currencies. Gas efficiency improved significantly v√¨ batch transfers possible. V√≠ d·ª•, transferring 100 different items c√≥ th·ªÉ done trong single transaction thay v√¨ 100 separate transactions nh∆∞ ERC-721 requires. NFT composition patterns ƒë√£ evolved sophisticated. Nested NFTs allow one NFT to own other NFTs - v√≠ d·ª•, character NFT owning weapon NFTs. Fractionalized NFTs split expensive NFT th√†nh multiple fungible shares, enabling collective ownership. Dynamic NFTs change metadata based on external conditions - sports NFT updating v·ªõi player statistics, game character NFT leveling up. Soulbound Tokens SBTs proposed b·ªüi Vitalik Buterin represent non-transferable NFTs for identity v√† credentials - once issued, cannot be sold ho·∫∑c transferred, only revoked by issuer. Contract architecture for NFTs typically separates concerns. Main contract handles ownership tracking v√† transfers. Metadata contract or service provides token information. Marketplace contracts facilitate buying/selling. Royalty contracts ensure creators receive percentage on secondary sales. This modularity enables ecosystem evolution - new marketplaces can emerge without requiring new token contracts, v√† existing NFTs remain compatible. --- 4. Mathematical / Cryptographic Formulation NFT uniqueness mathematically guaranteed through token ID space. V·ªõi uint256 token IDs, total possible unique tokens is: \\ N \\max = 2^ 256 \\approx 1.16 \\times 10^ 77 \\ ƒê√¢y l√† s·ªë l·ªõn h∆°n estimated s·ªë atoms trong observable universe approximately \\ 10^ 80 \\ . Practically unlimited uniqueness space, ensuring no collision concerns trong design space. Ownership verification trong NFTs relies on same cryptographic primitives nh∆∞ fungible tokens. Given NFT contract \\ C\\ v√† token ID \\ t\\ , ownership query \\ \\text ownerOf t \\ returns address \\ A\\ . To prove ownership, holder of address \\ A\\ must demonstrate knowledge c·ªßa private key corresponding ƒë·∫øn \\ A\\ 's public key. This follows ECDSA signature scheme discussed in earlier lectures, v·ªõi security reduced to discrete logarithm problem on elliptic curves. Transfer safety ƒë∆∞·ª£c ensure through multiple mechanisms. Basic transferFrom function simply changes ownership mapping: \\ \\text owner t \\leftarrow A \\text new \\quad \\text atomic state update \\ However, safeTransferFrom adds verification step. Before transferring, contract calls recipient v·ªõi selector onERC721Received : \\ \\text if recipient is contract: require recipient.\\text onERC721Received ... = \\text MAGIC\\ VALUE \\ This prevents accidental transfers ƒë·∫øn contracts kh√¥ng equipped ƒë·ªÉ handle NFTs, avoiding permanent loss. Magic value 0x150b7a02 serves nh∆∞ confirmation r·∫±ng contract implements proper interface. Royalty mathematics trong ERC-2981 standard defines royalty info function: \\ \\text receiver , \\text royaltyAmount = \\text royaltyInfo \\text tokenId , \\text salePrice \\ Where: \\ \\text royaltyAmount = \\text salePrice \\times \\frac \\text royaltyBasisPoints 10000 \\ V√≠ d·ª•, v·ªõi 5% royalty 500 basis points v√† sale price 10 ETH: \\ \\text royaltyAmount = 10 \\times \\frac 500 10000 = 0.5 \\text ETH \\ Creator automatically receives 0.5 ETH m·ªói sale. Rarity trong generative NFT projects often follows statistical distributions. For collection v·ªõi \\ n\\ traits, each trait c√≥ \\ m i\\ variants, total possible combinations: \\ C = \\prod i=1 ^ n m i \\ For CryptoPunks v·ªõi 7 attributes type, hair, eyes, etc. , m·ªói c√≥ variable number of options, total combinations exceed collection size 10,000 , ensuring uniqueness. Rarity score th∆∞·ªùng calculated as: \\ R t = \\sum i=1 ^ k \\frac 1 f i \\ Where \\ f i\\ l√† frequency c·ªßa trait \\ i\\ in collection. Rare traits contribute more to overall rarity score. --- 5. Implementation Insight solidity // SPDX-License-Identifier: MIT pragma solidity ^0.8.20; import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\"; import \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\"; import \"@openzeppelin/contracts/access/Ownable.sol\"; import \"@openzeppelin/contracts/utils/Counters.sol\"; / @title Complete NFT Implementation with Advanced Features @dev Includes: Minting, Metadata, Royalties, Enumeration / contract AdvancedNFT is ERC721, ERC721URIStorage, Ownable using Counters for Counters.Counter; Counters.Counter private tokenIds; // Royalty info ERC-2981 standard address public royaltyReceiver; uint96 public royaltyBasisPoints = 500; // 5% default // Metadata string private baseTokenURI; mapping uint256 => string private tokenURIs; // Supply tracking uint256 public constant MAX SUPPLY = 10000; // Events event NFTMinted address indexed to, uint256 indexed tokenId, string tokenURI ; event RoyaltySet address indexed receiver, uint96 basisPoints ; constructor string memory name, string memory symbol, string memory baseURI, address royaltyReceiver ERC721 name, symbol baseTokenURI = baseURI; royaltyReceiver = royaltyReceiver; / @dev Mint new NFT / function mintNFT address recipient, string memory metadataURI public onlyOwner returns uint256 tokenIds.increment ; uint256 newTokenId = tokenIds.current ; require newTokenId Listing public listings; uint256 public constant MARKETPLACE FEE = 250; // 2.5% event Listed bytes32 indexed listingId, address indexed seller, address indexed nftContract, uint256 tokenId, uint256 price ; event Sold bytes32 indexed listingId, address indexed buyer, uint256 price ; event Delisted bytes32 indexed listingId ; / @dev List NFT for sale / function listNFT address nftContract, uint256 tokenId, uint256 price public returns bytes32 require price > 0, \"Price must be > 0\" ; // Verify ownership IERC721 nft = IERC721 nftContract ; require nft.ownerOf tokenId == msg.sender, \"Not owner\" ; // Verify approval require nft.isApprovedForAll msg.sender, address this || nft.getApproved tokenId == address this , \"Marketplace not approved\" ; // Create listing ID bytes32 listingId = keccak256 abi.encodePacked nftContract, tokenId, msg.sender, block.timestamp ; listings listingId = Listing seller: msg.sender, nftContract: nftContract, tokenId: tokenId, price: price, active: true ; emit Listed listingId, msg.sender, nftContract, tokenId, price ; return listingId; / @dev Buy NFT / function buyNFT bytes32 listingId public payable Listing storage listing = listings listingId ; require listing.active, \"Listing not active\" ; require msg.value >= listing.price, \"Insufficient payment\" ; // Mark as inactive listing.active = false; // Calculate fees uint256 marketplaceFee = listing.price MARKETPLACE FEE / 10000; uint256 sellerProceeds = listing.price - marketplaceFee; // Check royalty ERC-2981 address royaltyReceiver, uint256 royaltyAmount = IERC2981 listing.nftContract .royaltyInfo listing.tokenId, listing.price ; if royaltyAmount > 0 sellerProceeds -= royaltyAmount; payable royaltyReceiver .transfer royaltyAmount ; // Transfer NFT IERC721 listing.nftContract .safeTransferFrom listing.seller, msg.sender, listing.tokenId ; // Pay seller payable listing.seller .transfer sellerProceeds ; // Refund excess if msg.value > listing.price payable msg.sender .transfer msg.value - listing.price ; emit Sold listingId, msg.sender, listing.price ; / @dev Delist NFT / function delistNFT bytes32 listingId public Listing storage listing = listings listingId ; require listing.active, \"Listing not active\" ; require listing.seller == msg.sender, \"Not seller\" ; listing.active = false; emit Delisted listingId ; / @dev Withdraw marketplace fees owner only / function withdrawFees public payable owner .transfer address this .balance ; Real-world implementations nh∆∞ OpenSea, Rarible, v√† Foundation build on these primitives nh∆∞ng add features extensive nh∆∞ collection verification, lazy minting mint only when sold , auctions English, Dutch , bundles, v√† cross-chain support. Gas optimizations critical - high-volume collections use techniques nh∆∞ ERC721A Azuki's optimization enabling batch minting at near-singular gas cost v√† merkle proofs for allowlists. --- 6. Common Challenges / Attacks / Trade-offs NFT ecosystem faces numerous challenges requiring careful consideration. Metadata permanence remains contentious issue. Khi NFT points ƒë·∫øn off-chain resource via HTTP URL, resource c√≥ th·ªÉ disappear if server goes down. IPFS provides improvement through content addressing - URL derived from file hash, ensuring retrievability as long as anyone pins content - nh∆∞ng kh√¥ng guarantee permanent availability. Arweave attempts solve n√†y through permanent storage model v·ªõi upfront payment, but economic sustainability remains unproven long-term. Smart contract bugs trong NFT contracts particularly dangerous given value at risk. Phishing attacks common - malicious contracts mimicking legitimate ones, tricking users into approving unauthorized transfers. Approval mechanisms trong ERC-721 create attack surface: calling setApprovalForAll grants contract permission to transfer ALL of user's NFTs from that collection. Users frequently unaware of this risk, approving malicious contracts. Wash trading manipulates NFT prices through self-dealing. Attacker owns NFT, sells to themselves t·ª´ different wallet at inflated price, creating appearance of legitimate sale. This inflates floor price metrics v√† misleads buyers. On-chain analysis can detect patterns but difficult to prevent entirely. Marketplaces implement heuristics nh∆∞ flagging rapid back-and-forth sales between wallets, nh∆∞ng sophisticated wash traders adapt. Copyright v√† intellectual property issues pervade NFT space. Owning NFT typically kh√¥ng grant copyright to underlying work unless explicitly stated. Buyer owns token on blockchain nh∆∞ng creator retains IP rights. This confusing for many users expecting full ownership. Additionally, anyone c√≥ th·ªÉ mint NFT pointing ƒë·∫øn content they don't own - plagiarism rampant. Verification systems nh∆∞ Twitter Blue checkmarks for verified collections attempt address n√†y, but remain centralized solutions. Royalty enforcement shows technical limitations of decentralized systems. ERC-2981 standard defines royalty interface, nh∆∞ng enforcement requires marketplace cooperation. Nothing prevents direct wallet-to-wallet transfer bypassing royalties entirely. Marketplaces voluntarily honor royalties, but cannot be forced on-chain. Proposals like ERC-4910 royalty-enforced NFTs attempt make royalties mandatory through transfer restrictions, but this limits composability v√† faces adoption challenges. Environmental concerns about NFT energy consumption largely addressed through Ethereum's Merge to Proof-of-Stake. Pre-merge, minting NFT on Ethereum consumed approximately 200 kWh carbon footprint of 100 kg CO2 . Post-merge, energy consumption reduced 99.95%, making NFT carbon footprint comparable to sending email. However, perception issues remain, v√† some artists still avoid NFTs for environmental reasons. --- 7. Related Concepts NFTs exist within broader ecosystem c·ªßa digital ownership innovations. Decentralized Identity DID leverages NFT-like tokens for self-sovereign identity credentials. Rather than identity document issued by government v√† stored in database, DIDs enable individuals hold verifiable credentials as tokens, presenting proofs without revealing underlying data. This connects to Soulbound Tokens SBTs concept proposed by Vitalik Buterin, Glen Weyl, v√† Puja Ohlhaver - non-transferable tokens representing achievements, credentials, ho·∫∑c memberships, creating Decentralized Society DeSoc . Fractionalization creates fascinating intersection between NFTs v√† DeFi. Platforms nh∆∞ Fractional.art allow expensive NFT be split th√†nh fungible ERC-20 shares, enabling collective ownership v√† liquid markets for otherwise illiquid assets. Mathematics straightforward: NFT locked in vault contract, vault issues \\ n\\ shares, each representing \\ 1/n\\ ownership. Buyout mechanisms allow anyone purchase all shares at threshold price, retrieving original NFT. Dynamic NFTs blur line gi·ªØa static collectibles v√† evolving digital entities. Using Chainlink oracles , NFT metadata can update based on real-world events. Sports player NFT could reflect current season statistics, updated automatically. Weather NFT could change appearance based on actual weather data. This requires careful contract design separating immutable aspects ownership, provenance from mutable metadata URI, properties . NFT standards comparison reveals design tradeoffs. ERC-721 optimized cho unique items, simple interface, but expensive cho large collections. ERC-1155 enables batch operations, mixing fungible v√† non-fungible, reducing gas substantially for games v√† metaverses. ERC-998 Composable NFTs allows NFTs own other tokens, creating hierarchies - parent NFT sold includes all children automatically. Each standard serves different use cases, v√† choosing appropriate standard critical for project success. Cross-chain NFTs represent next frontier. Projects like Axie Infinity initially on Ethereum, migrated to Ronin sidechain for scalability. Omnichain NFTs LayerZero enable single NFT exist across multiple chains simultaneously. User bridges NFT between chains as needed, maintaining unified identity. This requires sophisticated cross-chain messaging v√† handling of edge cases like conflicting states. --- 8. ‚≠ê Fundamental Papers / Whitepapers | Paper | Year | Author s | Contribution | |-------|------|-----------|--------------| | \"ERC-721: Non-Fungible Token Standard\" | 2018 | William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs | Defined NFT standard for Ethereum | | \"ERC-1155: Multi Token Standard\" | 2018 | Witek Radomski, Andrew Cooke, Philippe Castonguay, et al. | Multi-token standard for gaming/metaverse | | \"ERC-998: Composable Non-Fungible Token Standard\" | 2018 | Matt Lockyer, Nick Mudge | NFTs owning other tokens | | \"Decentralized Society: Finding Web3's Soul\" | 2022 | E. Glen Weyl, Puja Ohlhaver, Vitalik Buterin | Soulbound tokens for identity | | \"ERC-2981: NFT Royalty Standard\" | 2020 | Zach Burks, James Morgan, Blaine Malone, James Seibel | Standardized royalty interface | | \"ERC-4907: Rental NFT, Extension for ERC-721\" | 2022 | Anders, Lance, Shrug | Separates ownership from usage rights | | \"Art Blocks: On-Chain Generative Art\" | 2020 | Erick Calderon Snowfro | Algorithmic art generation on Ethereum | | \"The Non-Fungible Token Bible\" | 2020 | OpenSea team | Comprehensive NFT guide | --- 9. üé® Illustrations & Visual References Block Structure ! Ethereum NFT Transaction Flow https://ethereum.org/static/7f6b2b6e0c8b4e7f8d5e9a3c2b1f0e8d/nft-diagram.png Source: Ethereum.org - NFT Documentation https://ethereum.org/en/nft/ Merkle Tree ! NFT Metadata Structure https://docs.opensea.io/img/metadata-structure.png Source: OpenSea Metadata Standards https://docs.opensea.io/docs/metadata-standards ERC-721 vs ERC-1155 | Feature | ERC-721 | ERC-1155 | |---------|---------|----------| | Token uniqueness | One token ID = one unique item | Multiple tokens per ID possible | | Batch transfers | No one by one | Yes efficient batching | | Fungible + Non-fungible | Separate contracts needed | Same contract handles both | | Gas efficiency | Lower individual operations | Higher batch operations | | Use case | Art, collectibles | Gaming, metaverse | Source: Ethereum EIP Repository https://eips.ethereum.org/ Interactive Tools - OpenSea https://opensea.io/ - Largest NFT marketplace, explore collections - Etherscan NFT Tracker https://etherscan.io/nft-top-contracts - On-chain NFT analytics - IPFS https://ipfs.io/ - Decentralized storage for metadata - Arweave https://www.arweave.org/ - Permanent storage solution - Rarible https://rarible.com/ - Create and trade NFTs - Zora https://zora.co/ - NFT protocol and marketplace --- 10. Summary v√† Key Takeaways NFTs represent paradigm shift in digital ownership, creating verifiable scarcity v√† programmable property rights cho digital assets through blockchain technology. Core innovation lies trong ability to prove ownership cryptographically without requiring centralized authority, enabled by smart contract standards nh∆∞ ERC-721 v√† ERC-1155. These standards define interfaces allowing NFTs be universally recognized across wallets, marketplaces, v√† applications, creating composable ecosystem. Technical implementation builds on Ethereum's account model v√† EVM execution environment. Unique token IDs within 256-bit space provide effectively unlimited uniqueness, while ownership tracked via mapping data structure in contract storage. Transfer mechanisms incorporate safety checks preventing accidental loss, v√† approval systems enable delegated management. Metadata handling typically hybrid - contract on-chain points to off-chain resources via URIs, balancing cost v·ªõi functionality. Mathematical foundations ensure security v√† uniqueness. Cryptographic signatures prove ownership, collision resistance c·ªßa hash functions guarantee token ID uniqueness, v√† Merkle proofs enable efficient verification. Royalty calculations embedded in contracts enable creators earn from secondary market automatically, though enforcement depends on marketplace cooperation rather than protocol-level guarantees. Challenges include metadata permanence concerns, copyright confusion, wash trading manipulation, v√† scalability limitations. Solutions emerging through improved storage solutions IPFS, Arweave , better verification systems, marketplace standards, v√† Layer 2 scaling. NFT applications extending far beyond digital art into gaming, music, credentials, real estate tokenization, v√† decentralized identity. Future directions include dynamic NFTs responding to real-world data, fractionalization enabling collective ownership, cross-chain NFTs operating across multiple blockchains, v√† soulbound tokens for non-transferable credentials. NFT ecosystem continues evolving rapidly, v·ªõi new standards, tools, v√† use cases emerging continuously. Understanding NFT fundamentals - from ERC standards to marketplace mechanics to security considerations - essential for anyone building in Web3 space. --- ‚úÖ End of Lecture Next: Lecture 07.02 - Web3 Infrastructure v√† Decentralized Storage --- References 1. Entriken, W., Shirley, D., Evans, J., & Sachs, N. 2018 . ERC-721: Non-Fungible Token Standard . Ethereum Improvement Proposals. 2. Radomski, W., Cooke, A., Castonguay, P., et al. 2018 . ERC-1155: Multi Token Standard . Ethereum Improvement Proposals. 3. Weyl, E. G., Ohlhaver, P., & Buterin, V. 2022 . Decentralized Society: Finding Web3's Soul . arXiv preprint. 4. OpenSea Documentation. 2024 . NFT Metadata Standards . https://docs.opensea.io/ 5. Ethereum.org. 2024 . Non-Fungible Tokens NFT . https://ethereum.org/en/nft/",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter07/blockchain-chapter07/07_01_NFTs_Digital_Ownership/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter07/blockchain-chapter07/07_02_Web3_Infrastructure",
    "title": "Lecture 07.02: Web3 Infrastructure - Decentralized Internet Stack",
    "chapter": "07",
    "order": 3,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Web3 Infrastructure - Decentralized Internet Stack 1. Concept Overview Web3 represents vision fundamental rethinking c·ªßa internet architecture, transitioning from centralized platforms controlling user data v√† interactions toward decentralized networks where users own their data, identity, v√† digital assets directly. This paradigm shift requires rebuilding entire internet infrastructure stack - from data storage v√† domain names to identity systems v√† application hosting - using decentralized protocols resistant to censorship, manipulation, v√† single points of failure. Current internet architecture, often termed Web2, centralized around massive platforms - Google, Facebook, Amazon, Microsoft - controlling servers, data, algorithms, v√† user relationships. Users create content, generate data, build communities, but platforms own everything, monetize user attention, v√† can unilaterally change rules, ban users, ho·∫∑c shut down services. Web3 vision reverses this: users own their data cryptographically through private keys, applications run on decentralized networks, platforms reduced to interfaces rather than gatekeepers. Historical evolution traces through distinct eras. Web1 1990-2004 consisted of static websites, read-only content, decentralized protocols HTTP, SMTP, FTP . Anyone could run server, publish content, participate freely. Decentralized in architecture but limited in functionality - no social interaction, no user-generated content dynamically, no persistent identity across sites. Web2 2004-present introduced platforms enabling user interaction - social media, cloud computing, mobile apps. Functionality exploded but centralization increased dramatically. Platforms aggregated users, data, v√† value, creating walled gardens controlling digital lives. Web3 emergence 2014-present attempts recapture Web1's decentralization whilst providing Web2's functionality. Ethereum smart contracts enable decentralized applications dApps with persistent state v√† programmatic logic. IPFS provides decentralized storage. ENS creates decentralized naming. Decentralized identity protocols enable self-sovereign credentials. Together, these components form infrastructure stack supporting fully decentralized applications rivaling centralized counterparts in functionality whilst preserving user sovereignty. Core Web3 primitives include decentralized storage replacing cloud servers, decentralized compute replacing centralized hosting, decentralized identity replacing platform accounts, v√† decentralized monetization through tokens replacing advertising models. Each primitive addresses specific centralization vulnerability trong current web while introducing new challenges around performance, user experience, v√† governance. IPFS InterPlanetary File System , created by Juan Benet nƒÉm 2014, pioneered content-addressed storage. Instead of addressing data by location URLs pointing to servers , IPFS addresses data by cryptographic hash c·ªßa content itself. Same content always yields same hash CID - Content Identifier , regardless of where stored. Anyone can host content, users retrieve from whoever has it, no central servers required. This fundamental inversion eliminates link rot content disappears when server goes down v√† censorship content persists as long as anyone pins it . Filecoin , incentive layer for IPFS launched 2020, introduces economic mechanisms ensuring content persistence. Storage providers earn FIL tokens for reliably storing client data, verified through cryptographic proofs. Clients pay for storage, creating market matching supply v√† demand. This transforms IPFS from volunteer network into sustainable storage economy, though complexity v√† costs higher than centralized alternatives currently. ENS Ethereum Name Service , launched 2017, provides decentralized alternative to DNS. Human-readable names alice.eth map to Ethereum addresses, IPFS hashes, ho·∫∑c arbitrary data. Ownership secured through NFTs, not ICANN registrars. Users truly own names, cannot be seized ho·∫∑c revoked arbitrarily. Integration with wallets enables replacing hexadecimal addresses v·ªõi readable names, dramatically improving UX whilst maintaining decentralization. Decentralized identity frameworks like DID Decentralized Identifiers v√† Verifiable Credentials enable self-sovereign identity. Users control cryptographic identifiers kh√¥ng tied to any platform. Credentials issued by trusted entities universities, employers, governments cryptographically signed, verifiable by anyone, stored by users directly. No central identity provider required, users present credentials selectively maintaining privacy. Standards developed by W3C provide interoperability across implementations. --- 2. Intuitive Understanding Web3 architecture comparable to comparing library systems. Traditional library Web2 : central building holds all books, librarian controls access, knows what you read, can ban you. Decentralized library network Web3 : books distributed across community members' homes, anyone can host copies, lookup directory shows who has which books, request directly from current holders, no central librarian controlling access. Books addressed by content ISBN , not location, so finding copies easy regardless of who holds them. Content addressing in IPFS revolutionizes link semantics. Traditional URL nh∆∞ street address - points to location. If resident moves, address becomes invalid link rot . IPFS CID nh∆∞ DNA sequence - identifies content uniquely regardless of location. Like saying \"find person v·ªõi this DNA\" rather than \"check this address.\" Person moves, DNA unchanged, still findable. Content moves servers, hash unchanged, still retrievable. Persistence through identity rather than location. Filecoin storage market comparable to Airbnb for data. Instead of centralized hotel chain AWS, Google Cloud , decentralized marketplace matches storage providers v·ªõi clients. Providers offer storage space, clients pay for retention, protocol ensures delivery through cryptographic proofs. Like renting spare rooms globally rather than booking single hotel chain. Diversity increases resilience - no single provider failure affects entire network. ENS versus DNS comparable to cryptocurrency ownership versus bank account. DNS registrations controlled by registrars, subject to government seizure, can be revoked. ENS names owned directly through private keys, truly yours like Bitcoin. No entity can seize alice.eth if Alice controls private key. Decentralized ownership versus centralized administration fundamental difference. Decentralized identity analogous to passport versus Facebook login. Facebook controls account - can ban, change rules, require ID verification arbitrarily. Passport self-sovereign - you own document, present when needed, no platform controls. DIDs extend n√†y to digital realm - cryptographic identifiers owned directly, credentials presented selectively, no platform intermediary. Privacy preserved through selective disclosure - prove age over 18 without revealing birthdate, prove employment without revealing salary. Web3 application stack layers comparable to protocol stack trong networking. Just as TCP/IP provides reliable communication layer for HTTP applications, Web3 infrastructure layers enable decentralized applications. Base layer Ethereum provides computation v√† consensus. Storage layer IPFS provides content availability. Identity layer ENS, DIDs provides user primitives. Application layer dApps composes these primitives into user-facing services. Each layer decentralized independently, composed trustlessly. --- 3. Technical Foundation IPFS architecture employs distributed hash table DHT for content discovery. When content added to IPFS, system computes CID Content Identifier : \\ \\text CID = \\text Hash \\text content \\ Default: SHA-256, producing 256-bit identifier. Content split into blocks 256 KB default , each block hashed individually, creating merkle DAG directed acyclic graph . Large files represented as tree of content-addressed blocks, enabling efficient partial retrieval v√† deduplication. Content retrieval operates through DHT lookup. Node wanting content queries DHT for providers c·ªßa specific CID. DHT using Kademlia algorithm routes query to nodes likely storing provider information based on XOR distance metric: \\ d a, b = a \\oplus b \\ Queries forwarded to nodes minimizing XOR distance to target, logarithmic hops finding providers. Once provider identified, content retrieved directly peer-to-peer. python class SimplifiedIPFS: \"\"\"Educational IPFS implementation showing core concepts\"\"\" def init self : self.content store = CID -> content self.dht = CID -> provider addresses def add self, content : \"\"\"Add content to IPFS\"\"\" import hashlib Compute CID content identifier cid = hashlib.sha256 content.encode .hexdigest Store locally self.content store cid = content Announce to DHT if cid not in self.dht: self.dht cid = self.dht cid .append 'this node' print f\"‚úì Content added to IPFS\" print f\" CID: cid :32 ...\" print f\" Size: len content bytes\" return cid def get self, cid : \"\"\"Retrieve content from IPFS\"\"\" Check local store first if cid in self.content store: print f\"‚úì Content found locally\" return self.content store cid Query DHT for providers providers = self.dht.get cid, if not providers: print f\"‚úó Content not found\" return None Fetch from provider print f\"‚úì Content found on network\" print f\" Providers: len providers \" In real IPFS: fetch from closest provider return \"content from network\" def pin self, cid : \"\"\"Pin content keep it available \"\"\" if cid in self.content store: print f\"‚úì Content pinned will persist \" return True return False Example usage if name == \" main \": print \"=== IPFS Example ===\\n\" ipfs = SimplifiedIPFS Add content content = \"Hello, decentralized web!\" cid = ipfs.add content Retrieve content print f\"\\nRetrieving content...\" retrieved = ipfs.get cid print f\"Content: retrieved \" Pin for persistence print f\"\\nPinning content...\" ipfs.pin cid Filecoin proof-of-storage mechanisms ensure providers actually storing data claimed. Two primary proofs: Proof-of-Replication PoRep : Proves provider storing physically distinct copy c·ªßa data, not just original. Uses Stacked Depth Robust SDR encoding making replication necessary. Provider cannot fake storage without actually performing expensive encoding. Proof-of-Spacetime PoSt : Proves provider continued storing data over time period. Randomly challenges provider generate proof from stored data. Cannot generate proof without actually having data, cannot predict challenges ahead of time. Mathematical formulation for PoRep verification: \\ \\text Verify \\text proof , \\text data\\ commitment , \\text replica\\ commitment \\to \\ \\text valid , \\text invalid \\ \\ Proof demonstrates: 1. Replica commitment derived from data commitment correctly 2. Encoding performed cannot be bypassed 3. Provider possesses encoded replica ENS resolution system uses Ethereum smart contracts mapping names to resources: solidity contract ENSRegistry struct Record address owner; address resolver; uint64 ttl; mapping bytes32 => Record records; function setResolver bytes32 node, address resolver external require records node .owner == msg.sender ; records node .resolver = resolver; contract PublicResolver mapping bytes32 => address addresses; mapping bytes32 => bytes contenthashes; // IPFS CID function setAddr bytes32 node, address addr external addresses node = addr; function setContenthash bytes32 node, bytes memory hash external contenthashes node = hash; function addr bytes32 node external view returns address return addresses node ; Name resolution flow: alice.eth ‚Üí namehash \"alice.eth\" ‚Üí query ENS registry ‚Üí get resolver contract ‚Üí query resolver for address/content. All on-chain, trustlessly verifiable. --- 4. Mathematical / Cryptographic Formulation Content addressing security relies on collision resistance c·ªßa hash function. Probability of CID collision: \\ P \\text collision \\approx \\frac n^2 2^ 257 \\text for n \\text files \\ With SHA-256, even with trillion files: \\ P \\text collision \\approx \\frac 10^ 12 ^2 2^ 256 \\approx 10^ -53 \\ Negligible! Unique addressing guaranteed. DHT lookup complexity using Kademlia: \\ \\text Hops = O \\log 2 N \\ Where \\ N\\ = number of nodes. Network v·ªõi 1 million nodes: \\ \\text Hops \\approx \\log 2 10^6 \\approx 20 \\ Efficient routing enables scalability. Filecoin storage proof verification: Proof size: \\ O \\log n \\ where \\ n\\ = data size Verification time: \\ O \\log n \\ Efficient even for large files - 1 TB file proven with ~100 KB proof, verified in milliseconds. --- 5. Implementation Insight Complete Web3 application demonstrating infrastructure integration: javascript // Web3 App connecting IPFS + ENS + Ethereum const ipfs = require 'ipfs-http-client' ; const ethers = require 'ethers' ; class Web3App constructor this.ipfs = ipfs.create ; this.provider = new ethers.providers.JsonRpcProvider ; this.ensResolver = null; async deployContent htmlContent // 1. Upload to IPFS const result = await this.ipfs.add htmlContent ; const cid = result.cid.toString ; console.log ‚úì Content uploaded to IPFS ; console.log CID: $ cid ; return cid; async registerENS name, cid // 2. Register ENS name pointing to IPFS CID const ensRegistry = new ethers.Contract ENS REGISTRY ADDRESS, ENS ABI, this.signer ; const namehash = ethers.utils.namehash name ; // Set resolver await ensRegistry.setResolver namehash, RESOLVER ADDRESS ; // Set content hash const resolver = new ethers.Contract RESOLVER ADDRESS, RESOLVER ABI, this.signer ; await resolver.setContenthash namehash, cidToContentHash cid ; console.log ‚úì ENS registered: $ name ; console.log Points to: ipfs://$ cid ; async resolveENS name // 3. Resolve ENS name to IPFS content const resolver = await this.provider.getResolver name ; const contenthash = await resolver.getContentHash ; // Convert to CID const cid = contenthashToCid contenthash ; // 4. Fetch from IPFS const content = await this.fetchFromIPFS cid ; console.log ‚úì Content retrieved for $ name ; return content; async fetchFromIPFS cid const chunks = ; for await const chunk of this.ipfs.cat cid chunks.push chunk ; return Buffer.concat chunks .toString ; // Usage: User visits \"alice.eth\" in Web3 browser // Browser resolves ENS -> gets IPFS CID -> fetches content from IPFS // Fully decentralized! No central server! Real-world Web3 applications demonstrate stack integration. Uniswap interface hosted on IPFS, accessible via uniswap.eth ENS name. Users interact with smart contracts on Ethereum through decentralized frontend. If Uniswap Inc disappeared entirely, application continues functioning - contracts on-chain, interface on IPFS, name on ENS, all persistent v√† ownerless. --- 6. Common Challenges / Attacks / Trade-offs IPFS performance remains inferior to centralized CDNs. Content retrieval may take seconds when hosted by few peers versus milliseconds from geographically distributed CDN servers. IPFS gateways Cloudflare, Pinata provide HTTP access to IPFS content, improving performance but reintroducing centralization. Trade-off between pure decentralization v√† practical usability persistent. Filecoin storage costs currently higher than AWS S3 approximately 2-5√ó more expensive . Economic sustainability questioned - will costs decrease with scale, or fundamental overhead c·ªßa decentralization means permanent premium? Network effects favor incumbents - AWS's installed base, tooling ecosystem, network effects create moat Filecoin must overcome. Data persistence relies on economic incentives. If no one pays pin content, content disappears from network. Unlike AWS's SLA guarantees, IPFS persistence depends on continued interest v√† payment. Archival use cases challenged - cannot guarantee 100-year persistence without 100-year payment upfront. Solutions include DAOs funding public goods storage, protocol-level incentives, v√† cultural norms around preservation. ENS naming collisions v·ªõi traditional domains create confusion. alice.com v√† alice.eth completely separate, owned by different entities, potentially causing phishing attacks. Users unfamiliar with ENS may visit wrong site thinking it's official. Browser support inconsistent - some browsers resolve ENS natively, others require plugins ho·∫∑c gateways. Fragmented UX hampers adoption. Decentralized compute Ethereum smart contracts extremely expensive compared to AWS Lambda. Simple computation costing milliseconds on AWS may cost dollars in gas on Ethereum. This limits Web3 application complexity - cannot run ML models on-chain, cannot process large datasets, must carefully minimize computation. Layer 2s v√† alternative architectures Arweave's bundling attempt address n√†y but trade-offs remain. Identity management complexity increases with sovereignty. Centralized platforms offer password recovery, account restoration, customer support. Web3 self-custody means losing private key loses access permanently, no recovery possible. Users bear full responsibility, requiring education v√† tooling far beyond current user capabilities. Solutions like social recovery Argent wallet reintroduce trust in recovery helpers, compromising pure self-custody. --- 7. Related Concepts Web3 infrastructure connects deeply to decentralized autonomous organizations DAOs governing protocols. IPFS governed by Protocol Labs initially but transitioning toward community governance. Filecoin Plus notary system uses DAOs for storage allocation. ENS DAO controls protocol parameters through token voting. This pattern - infrastructure governed by users rather than companies - fundamental to Web3 ethos. Arweave presents alternative permanent storage model. Instead of ongoing payment Filecoin , users pay once upfront for permanent storage, funded through endowment earning interest perpetually. Mathematical model assumes storage costs decrease faster than endowment appreciation, enabling perpetual funding. Bold assumption but creative economic design. Arweave hosts permanent web archives, NFT metadata, v√† decentralized application frontends. The Graph provides decentralized indexing and querying for blockchain data. Smart contract events v√† state indexed into subgraphs, developers query using GraphQL. Replaces centralized databases typically used for dApp backends. Indexers earn GRT tokens for serving queries, curators stake GRT signaling valuable subgraphs. Decentralized information retrieval completing Web3 stack. Ceramic Network offers decentralized database with mutable data streams. IPFS immutable - content hash changes if content changes. Ceramic enables mutable documents with version history, suitable for user profiles, social graphs, application state. Built on IPFS v·ªõi additional consensus layer managing updates. Push Protocol formerly EPNS provides decentralized notifications. Traditional apps use Firebase Cloud Messaging ho·∫∑c Apple Push Notification Service - centralized services. Push Protocol enables wallet-to-wallet notifications via decentralized network, maintaining Web3 property kh√¥ng ph·ª• thu·ªôc centralized infrastructure. --- 8. ‚≠ê Fundamental Papers / Whitepapers | Paper | Year | Author s | Contribution | |-------|------|-----------|--------------| | \"IPFS - Content Addressed, Versioned, P2P File System\" | 2014 | Juan Benet | IPFS protocol specification | | \"Filecoin: A Decentralized Storage Network\" | 2017 | Protocol Labs | Incentivized storage via proofs | | \"EIP-137: Ethereum Domain Name Service\" | 2016 | Nick Johnson | ENS specification | | \"Decentralized Identifiers DIDs v1.0\" | 2021 | W3C | DID standard specification | | \"Verifiable Credentials Data Model\" | 2021 | W3C | Credential standard | | \"Arweave: A Protocol for Economically Sustainable Information Permanence\" | 2018 | Sam Williams, Viktor Diordiiev | Permanent storage model | --- 9. üé® Illustrations & Visual References Web2 vs Web3 Architecture Web2 Stack : User ‚Üí Browser ‚Üí CDN ‚Üí AWS ‚Üí Centralized DB ‚Üí Application Server ‚Üì Platform owns everything Web3 Stack : User ‚Üí Browser ‚Üí IPFS ‚Üí Ethereum ‚Üí Your Wallet ‚Üì You own your data IPFS Content Addressing ! IPFS Content Addressing https://docs.ipfs.tech/assets/img/ipfs-illustration-works.png Source: IPFS Documentation https://docs.ipfs.tech/concepts/ ENS Resolution Flow ! ENS Resolution https://docs.ens.domains/img/ens-architecture.png Source: ENS Documentation https://docs.ens.domains/ Decentralized Identity Stack ! DID Architecture https://www.w3.org/TR/did-core/diagrams/did-architecture.svg Source: W3C DID Specification https://www.w3.org/TR/did-core/ Interactive Tools - IPFS Desktop https://docs.ipfs.tech/install/ipfs-desktop/ - Run IPFS node locally - ENS Manager https://app.ens.domains/ - Register v√† manage ENS names - Etherscan ENS https://etherscan.io/enslookup - Lookup ENS names - Fleek https://fleek.co/ - Deploy Web3 sites easily --- 10. Summary Web3 infrastructure provides decentralized alternatives to centralized internet components - IPFS replacing cloud storage, ENS replacing DNS, DIDs replacing platform accounts, Filecoin incentivizing content persistence. Together these primitives enable applications running entirely on decentralized networks, resistant to censorship v√† platform control whilst preserving user data ownership. Technical implementations leverage content addressing IPFS , cryptographic ownership ENS as NFTs , zero-knowledge proofs selective credential disclosure , v√† token economics Filecoin storage markets . Trade-offs include performance degradation versus centralized alternatives, higher costs currently, increased complexity in user experience, v√† uncertain long-term sustainability models. Despite challenges, Web3 infrastructure maturing rapidly. Production applications serving millions of users demonstrate viability. Standards emerging W3C DIDs, ERC standards enable interoperability. As tooling improves v√† costs decrease through scaling solutions, Web3 promises realizing internet's original decentralization vision whilst adding programmability v√† ownership guarantees impossible in Web2 paradigm. --- ‚úÖ End of Lecture Next: Lecture 07.03 - MEV Maximal Extractable Value --- References 1. Benet, J. 2014 . IPFS - Content Addressed, Versioned, P2P File System . IPFS Whitepaper. 2. Protocol Labs. 2017 . Filecoin: A Decentralized Storage Network . Filecoin Whitepaper. 3. Johnson, N. 2016 . EIP-137: Ethereum Domain Name Service - Specification . Ethereum Improvement Proposals. 4. W3C. 2021 . Decentralized Identifiers DIDs v1.0 . W3C Recommendation. 5. W3C. 2021 . Verifiable Credentials Data Model v1.0 . W3C Recommendation.",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter07/blockchain-chapter07/07_02_Web3_Infrastructure/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter07/blockchain-chapter07/07_03_MEV",
    "title": "Lecture 07.03: MEV - Maximal Extractable Value",
    "chapter": "07",
    "order": 4,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: MEV - Maximal Extractable Value 1. Concept Overview MEV Maximal Extractable Value, formerly \"Miner Extractable Value\" ƒë·∫°i di·ªán cho profit m√† validators/miners c√≥ th·ªÉ extract th√¥ng qua ability reorder, include, ho·∫∑c exclude transactions trong blocks they produce. Phenomenon n√†y arose t·ª´ transparent mempool c·ªßa Ethereum v√† deterministic execution c·ªßa smart contracts, enabling sophisticated actors preview transaction effects v√† manipulate ordering for profit, often at expense c·ªßa regular users. MEV discovered v√† formalized b·ªüi Phil Daian v√† colleagues trong paper \"Flash Boys 2.0\" nƒÉm 2019, drawing parallels v·ªõi high-frequency trading trong traditional finance. Research showed billions of dollars extracted annually through techniques nh∆∞ front-running, back-running, v√† sandwich attacks, raising concerns v·ªÅ fairness, decentralization, v√† protocol stability. --- 2. Intuitive Understanding MEV comparable to insider trading tr√™n stock market. Imagine seeing everyone's orders before they execute, ability prioritize your own trades, v√† capacity rearrange order flow for maximum personal profit. Traditional finance heavily regulates n√†y. Blockchain mempool inherently transparent - all pending transactions visible - creating MEV opportunities structurally embedded trong protocol design. --- 3. Technical Foundation Sandwich attack exemplifies MEV extraction. Bot detects large DEX trade trong mempool, front-runs b·∫±ng c√°ch buying before victim increasing price , victim's trade executes at worse price, bot back-runs selling at profit. python class MEVBot: def detect opportunity self, pending tx : if pending tx 'type' == 'DEX SWAP' and pending tx 'amount' > threshold: Large trade detected - sandwich opportunity return self.execute sandwich pending tx def execute sandwich self, victim tx : Front-run: Buy before victim front run tx = create buy tx amount=optimal amount, gas price=victim tx.gas price + 1 Higher priority Victim tx executes price increases Back-run: Sell after victim back run tx = create sell tx amount=front run amount, gas price=victim tx.gas price - 1 Still processes Profit = price after - price before amount - gas costs --- 4. Mathematical / Cryptographic Formulation MEV extraction quantified as: \\ \\text MEV = \\max o \\in O R o - R o \\text default \\ Where \\ O\\ = set c·ªßa possible transaction orderings, \\ R o \\ = revenue under ordering \\ o\\ . Sandwich attack profit: \\ \\Pi = P \\text after - P \\text before \\times Q - \\text Gas \\ Example: Victim buys 100 ETH on Uniswap, bot sandwiches: - Front-run 50 ETH: Price MATH 2020 - Victim 100 ETH: Price MATH 2060 - Back-run 50 ETH: Sell at $2060 Profit: 50 √ó MATH 2000 - gas ‚âà $3,000 --- 5. Implementation Insight Flashbots mitigates MEV through sealed-bid auctions: python Instead of public mempool, private transaction bundles bundle = 'transactions': front run tx, victim tx, back run tx , 'block number': target block, 'bribe': 0.1 ETH Paid to validator Submit directly to validator No public mempool exposure Reduces harmful MEV though doesn't eliminate --- 6. Common Challenges / Attacks / Trade-offs MEV creates centralization pressure - sophisticated infrastructure required, favoring large operators. Estimated $600M+ extracted annually, mostly by small number of entities. Threatens decentralization v√† fairness. --- 7. Related Concepts MEV-Boost enables validators outsource block building to specialized builders, separating proposing from building. Increases MEV extraction efficiency whilst maintaining decentralization of proposal rights. --- 8. ‚≠ê Fundamental Papers / Whitepapers | Paper | Year | Author s | Contribution | |-------|------|-----------|--------------| | \"Flash Boys 2.0: Frontrunning, Transaction Reordering, and Consensus Instability in Decentralized Exchanges\" | 2019 | Daian et al. | MEV formalization | | \"Flashbots: Frontrunning the MEV Crisis\" | 2020 | Flashbots team | MEV mitigation approach | --- 9. üé® Illustrations & Visual References ! MEV Extraction Flow https://docs.flashbots.net/img/mev-extraction.png Source: Flashbots Documentation https://docs.flashbots.net/ --- 10. Summary MEV represents billions extracted through transaction ordering manipulation. While some MEV unavoidable arbitrage beneficial for efficiency , harmful MEV sandwich attacks damages user experience v√† fairness. Solutions like Flashbots, encrypted mempools, v√† fair ordering protocols attempt mitigate whilst preserving validator economics. Understanding MEV essential for protocol designers, traders, v√† anyone interacting with DeFi. --- ‚úÖ End of Lecture Next: Lecture 07.04 - Quantum Resistance Strategies --- References 1. Daian, P., et al. 2019 . Flash Boys 2.0 . IEEE S&P 2020. 2. Flashbots. 2020 . Flashbots Documentation . https://docs.flashbots.net/",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter07/blockchain-chapter07/07_03_MEV/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter07/blockchain-chapter07/07_04_Quantum_Resistance",
    "title": "Lecture 07.04: Quantum Resistance Strategies for Blockchain",
    "chapter": "07",
    "order": 5,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: Quantum Resistance Strategies for Blockchain 1. Concept Overview Quantum computing threat necessitates proactive migration strategies for blockchain ecosystems. This lecture examines practical approaches blockchains can adopt preparing for quantum era, including hybrid signature schemes, gradual migration paths, emergency response plans, v√† protocol-level modifications enabling quantum-safe operations whilst maintaining backward compatibility during transition period. Migration complexity stems from blockchain immutability v√† coordination requirements. Unlike traditional software easily patched, blockchain protocols require network-wide consensus for changes. Billions in assets secured by current cryptography must transition safely without creating vulnerabilities during migration window. --- 2. Intuitive Understanding Quantum migration comparable to upgrading airplane engines mid-flight. Cannot land stop blockchain , cannot risk engine failure cryptographic break , must transition smoothly whilst maintaining continuous operation. Requires careful planning, redundancy hybrid schemes , testing testnets , v√† coordination governance . --- 3. Technical Foundation Hybrid signature approach during transition: solidity contract QuantumSafeWallet // Dual signatures required bytes32 public classicalPubKey; // ECDSA bytes32 public quantumSafePubKey; // Dilithium function executeTransaction bytes memory classicalSig, bytes memory pqSig, bytes memory txData external // Verify BOTH signatures require verifyECDSA txData, classicalSig , \"Classical sig invalid\" ; require verifyDilithium txData, pqSig , \"PQ sig invalid\" ; // Execute only if both valid // Provides security even if one scheme broken Migration phases: 1. Phase 1 : Add post-quantum as optional testing 2. Phase 2 : Require both signatures transition 3. Phase 3 : Drop classical once quantum threat imminent --- 4. Mathematical / Cryptographic Formulation Security during transition period: \\ \\text Security \\text hybrid = \\max \\text Security \\text classical , \\text Security \\text PQ \\ System secure as long as either scheme unbroken. Conservative approach ensuring continuity. --- 5. Implementation Insight Bitcoin quantum emergency plan: Soft fork freezing exposed public keys addresses that spent , requiring quantum-safe signatures for movements, protecting unspent outputs with unexposed public keys majority of Bitcoin . --- 6. Common Challenges / Attacks / Trade-offs Signature size doubles during hybrid period. Blockchain bandwidth constraints amplified. Must balance security hybrid redundancy versus efficiency single scheme . Economic analysis determines optimal transition timing. --- 7. Related Concepts Quantum Key Distribution QKD provides alternative using quantum physics directly for secure communication. Impractical for blockchains requires specialized hardware, point-to-point links but demonstrates quantum technology's dual nature - both threat v√† potential solution. --- 8. ‚≠ê Fundamental Papers / Whitepapers | Paper | Year | Author s | Contribution | |-------|------|-----------|--------------| | \"Quantum Attacks on Bitcoin\" | 2017 | Aggarwal et al. | Bitcoin-specific quantum threat analysis | | \"Post-Quantum Blockchain Proofs of Work\" | 2019 | Sun et al. | Quantum-safe mining | --- 9. üé® Illustrations & Visual References Source: NIST Post-Quantum Cryptography https://csrc.nist.gov/Projects/post-quantum-cryptography --- 10. Summary Quantum resistance requires proactive migration before quantum computers threaten current cryptography. Strategies include hybrid signatures providing defense-in-depth, phased migration minimizing disruption, v√† protocol modifications enabling quantum-safe operations. Understanding quantum threat timeline v√† preparation options essential for long-term blockchain security. --- ‚úÖ End of Lecture Next: Lecture 07.05 - Future of Blockchain Technology --- References 1. Aggarwal, D., et al. 2017 . Quantum attacks on Bitcoin . Ledger, 2. 2. NIST. 2024 . Post-Quantum Cryptography Project . https://csrc.nist.gov/",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter07/blockchain-chapter07/07_04_Quantum_Resistance/",
    "lang": "vi"
  },
  {
    "id": "/contents/vi/chapter07/blockchain-chapter07/07_05_Future_Blockchain",
    "title": "Lecture 07.05: The Future of Blockchain - Trends v√† Innovations",
    "chapter": "07",
    "order": 6,
    "owner": "Blockchain Course Team",
    "lesson_type": "",
    "content": "Lecture: The Future of Blockchain - Trends v√† Innovations 1. Concept Overview Blockchain technology stands at inflection point, transitioning from experimental phase to mature infrastructure powering real-world applications serving millions. Future trajectory encompasses technical innovations modular blockchains, zkEVMs, account abstraction , new application domains decentralized science, regenerative finance, social coordination , regulatory evolution institutional adoption, compliance frameworks , v√† philosophical questions v·ªÅ decentralization's role trong society. Next decade likely witnesses consolidation around winning architectures whilst continuous innovation at application layer. Ethereum's rollup-centric roadmap demonstrates one path - monolithic base layer providing security, modular execution layers providing scalability. Alternative visions include application-specific chains Cosmos ecosystem , shared security models Polkadot , v√† novel consensus mechanisms Solana's Proof-of-History, Avalanche's consensus . --- 2. Intuitive Understanding Blockchain future comparable to internet's evolution 1990s‚Üí2024. Early internet 1990s slow, difficult to use, limited applications. Skeptics dismissed as niche technology. Yet infrastructure improvements broadband, mobile, cloud v√† killer applications social media, streaming, e-commerce drove mass adoption. Similarly, blockchain infrastructure advancing rapidly L2s, better UX, tooling , applications emerging DeFi, NFTs, DAOs suggesting mass adoption possible despite current limitations. --- 3. Technical Foundation Modular blockchain architecture separates concerns: execution layer compute , data availability layer storage , consensus layer ordering , settlement layer finality . Projects like Celestia provide data availability separately, enabling rollups post data there instead of expensive Ethereum calldata, reducing costs dramatically whilst maintaining security. Account abstraction ERC-4337 enables smart contract wallets natively, unlocking programmable accounts v·ªõi features like social recovery, gas sponsorship meta-transactions , batch operations, v√† custom security policies. Future wallets will feel nh∆∞ traditional apps whilst being non-custodial. ZkEVMs combine zero-knowledge proof efficiency v·ªõi full EVM compatibility. Projects like Polygon zkEVM , Scroll , v√† zkSync Era prove entire EVM execution correctly via SNARKs, enabling Ethereum applications run on zkRollups without modification, achieving both scalability v√† security. --- 4. Mathematical / Cryptographic Formulation Modular scaling potential: \\ \\text TPS \\text total = n \\text rollups \\times n \\text shards \\times \\text TPS \\text base \\ With 100 rollups across 64 shards: \\ \\text TPS = 100 \\times 64 \\times 15 = 96,000 \\text TPS \\ Approaching Visa-scale throughput! --- 5. Implementation Insight Future blockchain development emphasizes composability - applications combining primitives from multiple protocols seamlessly. DeFi already demonstrates n√†y: single transaction might interact with Uniswap, Aave, Curve, v√† Yearn simultaneously. Future extends to cross-domain composability - DeFi + NFTs + DAOs + identity interoperating natively. --- 6. Common Challenges / Attacks / Trade-offs Regulatory uncertainty remains largest wildcard. Clear frameworks could drive institutional adoption, harsh regulations could stifle innovation. Jurisdictional arbitrage likely - innovation concentrates trong friendly jurisdictions, challenging global enforcement. Quantum computing timeline uncertain. Optimistic estimates suggest 20-30 years before cryptographically relevant quantum computers exist. Pessimistic estimates under 10 years. Blockchain must prepare accordingly, risk catastrophic failure if quantum breakthrough sudden. User experience remains barrier to mass adoption. Private key management, gas fees, transaction signing, network switching - all friction points versus Web2's seamlessness. Solutions emerging account abstraction, fiat on-ramps, gas abstraction but adoption gradual. --- 7. Related Concepts Decentralized Science DeSci applies blockchain to scientific research - funding through DAOs, publication on decentralized storage, peer review incentivized by tokens, data sharing v·ªõi provenance tracking. Could accelerate research whilst improving transparency. Regenerative Finance ReFi uses blockchain for environmental initiatives - carbon credits, biodiversity tracking, impact investing v·ªõi verifiable outcomes. Potential align economic incentives v·ªõi planetary health. Decentralized Social Media challenges Facebook, Twitter monopolies. Protocols like Lens, Farcaster enable users own social graphs, content, followers. Resistance to censorship, algorithmic transparency, creator monetization without platform fees. --- 8. ‚≠ê Fundamental Papers / Whitepapers | Paper | Year | Author s | Contribution | |-------|------|-----------|--------------| | \"Endgame\" | 2021 | Vitalik Buterin | Ethereum's long-term vision | | \"Modular Blockchains: A Deep Dive\" | 2022 | Celestia team | Modular architecture thesis | | \"Account Abstraction ERC-4337 \" | 2021 | Vitalik Buterin et al. | Smart contract wallet standard | | \"The Blockchain Trilemma\" | 2017 | Vitalik Buterin | Fundamental trade-off analysis | --- 9. üé® Illustrations & Visual References ! Modular Blockchain Stack https://celestia.org/images/modular-stack.png Source: Celestia Documentation https://docs.celestia.org/ --- 10. Summary Blockchain future encompasses technical scaling solutions, expanding application domains, regulatory maturation, v√† continued innovation. Modular architectures, zero-knowledge proofs, account abstraction, v√† cross-chain interoperability form technical foundation. Applications extend beyond finance into science, environment, social coordination, governance. Challenges include quantum computing threats, regulatory uncertainty, v√† user experience gaps. Despite challenges, blockchain's core value propositions - decentralization, transparency, programmable trust - increasingly relevant trong digital age valuing privacy, sovereignty, v√† censorship resistance. Understanding current trends v√† future directions positions participants at forefront c·ªßa technology reshaping internet v√† finance fundamentally. --- ‚úÖ End of Lecture ‚úÖ End of Chapter 07 - Advanced Topics ‚úÖ END OF BLOCKCHAIN TECHNOLOGY COURSE --- References 1. Buterin, V. 2021 . Endgame . Vitalik's Blog. 2. Celestia. 2022 . Modular Blockchains: A Deep Dive . Celestia Whitepaper. 3. Buterin, V., et al. 2021 . ERC-4337: Account Abstraction . Ethereum Improvement Proposals.",
    "url": "/blockchain-self-learning/vi/contents/vi/chapter07/blockchain-chapter07/07_05_Future_Blockchain/",
    "lang": "vi"
  }
]